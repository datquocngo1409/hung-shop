{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport QuadRoot from './quad-root';\nimport QuadNode from './quad-node';\nimport { Rect } from '../geometry';\nimport { Class } from '../common';\nimport { append } from '../util';\nvar ROOT_SIZE = 3000;\nvar LEVEL_STEP = 10000;\nvar MAX_LEVEL = 75;\n\nvar ShapesQuadTree = /*#__PURE__*/function (_Class) {\n  _inherits(ShapesQuadTree, _Class);\n\n  var _super = _createSuper(ShapesQuadTree);\n\n  function ShapesQuadTree() {\n    var _this;\n\n    _classCallCheck(this, ShapesQuadTree);\n\n    _this = _super.call(this);\n\n    _this.initRoots();\n\n    return _this;\n  }\n\n  _createClass(ShapesQuadTree, [{\n    key: \"initRoots\",\n    value: function initRoots() {\n      this.rootMap = {};\n      this.root = new QuadRoot();\n      this.rootElements = [];\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var rootElements = this.rootElements;\n\n      for (var idx = 0; idx < rootElements.length; idx++) {\n        this.remove(rootElements[idx]);\n      }\n\n      this.initRoots();\n    }\n  }, {\n    key: \"pointShape\",\n    value: function pointShape(point) {\n      var sectorRoot = (this.rootMap[Math.floor(point.x / ROOT_SIZE)] || {})[Math.floor(point.y / ROOT_SIZE)];\n      var result = this.root.pointShapes(point);\n\n      if (sectorRoot) {\n        result = result.concat(sectorRoot.pointShapes(point));\n      }\n\n      this.assignZindex(result);\n      result.sort(zIndexComparer);\n\n      for (var idx = 0; idx < result.length; idx++) {\n        if (result[idx].containsPoint(point)) {\n          return result[idx];\n        }\n      }\n    }\n  }, {\n    key: \"assignZindex\",\n    value: function assignZindex(elements) {\n      for (var idx = 0; idx < elements.length; idx++) {\n        var element = elements[idx];\n        var zIndex = 0;\n        var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n        var parents = [];\n\n        while (element) {\n          parents.push(element);\n          element = element.parent;\n        }\n\n        while (parents.length) {\n          element = parents.pop();\n          zIndex += ((element.parent ? element.parent.children : this.rootElements).indexOf(element) + 1) * levelWeight;\n          levelWeight /= LEVEL_STEP;\n        }\n\n        elements[idx]._zIndex = zIndex;\n      }\n    }\n  }, {\n    key: \"optionsChange\",\n    value: function optionsChange(e) {\n      if (e.field === \"transform\" || e.field === \"stroke.width\") {\n        this.bboxChange(e.element);\n      }\n    }\n  }, {\n    key: \"geometryChange\",\n    value: function geometryChange(e) {\n      this.bboxChange(e.element);\n    }\n  }, {\n    key: \"bboxChange\",\n    value: function bboxChange(element) {\n      if (element.nodeType === \"Group\") {\n        for (var idx = 0; idx < element.children.length; idx++) {\n          this.bboxChange(element.children[idx]);\n        }\n      } else {\n        if (element._quadNode) {\n          element._quadNode.remove(element);\n        }\n\n        this._insertShape(element);\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(elements) {\n      var elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];\n      append(this.rootElements, elementsArray);\n\n      this._insert(elementsArray);\n    }\n  }, {\n    key: \"childrenChange\",\n    value: function childrenChange(e) {\n      if (e.action === \"remove\") {\n        for (var idx = 0; idx < e.items.length; idx++) {\n          this.remove(e.items[idx]);\n        }\n      } else {\n        this._insert(Array.prototype.slice.call(e.items, 0));\n      }\n    }\n  }, {\n    key: \"_insert\",\n    value: function _insert(elements) {\n      var element;\n\n      while (elements.length > 0) {\n        element = elements.pop();\n        element.addObserver(this);\n\n        if (element.nodeType === \"Group\") {\n          append(elements, element.children);\n        } else {\n          this._insertShape(element);\n        }\n      }\n    }\n  }, {\n    key: \"_insertShape\",\n    value: function _insertShape(shape) {\n      var bbox = shape.bbox();\n\n      if (bbox) {\n        var sectors = this.getSectors(bbox);\n        var x = sectors[0][0];\n        var y = sectors[1][0];\n\n        if (this.inRoot(sectors)) {\n          this.root.insert(shape, bbox);\n        } else {\n          var rootMap = this.rootMap;\n\n          if (!rootMap[x]) {\n            rootMap[x] = {};\n          }\n\n          if (!rootMap[x][y]) {\n            rootMap[x][y] = new QuadNode(new Rect([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE]));\n          }\n\n          rootMap[x][y].insert(shape, bbox);\n        }\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(element) {\n      element.removeObserver(this);\n\n      if (element.nodeType === \"Group\") {\n        var children = element.children;\n\n        for (var idx = 0; idx < children.length; idx++) {\n          this.remove(children[idx]);\n        }\n      } else if (element._quadNode) {\n        element._quadNode.remove(element);\n\n        delete element._quadNode;\n      }\n    }\n  }, {\n    key: \"inRoot\",\n    value: function inRoot(sectors) {\n      return sectors[0].length > 1 || sectors[1].length > 1;\n    }\n  }, {\n    key: \"getSectors\",\n    value: function getSectors(rect) {\n      var bottomRight = rect.bottomRight();\n      var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n      var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n      var sectors = [[], []];\n\n      for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n        sectors[0].push(x);\n      }\n\n      for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n        sectors[1].push(y);\n      }\n\n      return sectors;\n    }\n  }]);\n\n  return ShapesQuadTree;\n}(Class);\n\nfunction zIndexComparer(x1, x2) {\n  if (x1._zIndex < x2._zIndex) {\n    return 1;\n  }\n\n  if (x1._zIndex > x2._zIndex) {\n    return -1;\n  }\n\n  return 0;\n}\n\nexport default ShapesQuadTree;","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/search/shapes-quad-tree.js"],"names":["QuadRoot","QuadNode","Rect","Class","append","ROOT_SIZE","LEVEL_STEP","MAX_LEVEL","ShapesQuadTree","initRoots","rootMap","root","rootElements","idx","length","remove","point","sectorRoot","Math","floor","x","y","result","pointShapes","concat","assignZindex","sort","zIndexComparer","containsPoint","elements","element","zIndex","levelWeight","pow","parents","push","parent","pop","children","indexOf","_zIndex","e","field","bboxChange","nodeType","_quadNode","_insertShape","elementsArray","Array","isArray","slice","_insert","action","items","prototype","call","addObserver","shape","bbox","sectors","getSectors","inRoot","insert","removeObserver","rect","bottomRight","bottomX","bottomY","origin","x1","x2"],"mappings":"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","sourcesContent":["import QuadRoot from './quad-root';\nimport QuadNode from './quad-node';\nimport { Rect } from '../geometry';\nimport { Class } from '../common';\nimport { append } from '../util';\n\nconst ROOT_SIZE = 3000;\nconst LEVEL_STEP = 10000;\nconst MAX_LEVEL = 75;\n\nclass ShapesQuadTree extends Class {\n\n    constructor() {\n        super();\n\n        this.initRoots();\n    }\n\n    initRoots() {\n        this.rootMap = {};\n        this.root = new QuadRoot();\n        this.rootElements = [];\n    }\n\n    clear() {\n        const rootElements = this.rootElements;\n        for (let idx = 0; idx < rootElements.length; idx++) {\n            this.remove(rootElements[idx]);\n        }\n        this.initRoots();\n    }\n\n    pointShape(point) {\n        const sectorRoot = ( this.rootMap[ Math.floor( point.x / ROOT_SIZE ) ] || {} )[ Math.floor( point.y / ROOT_SIZE ) ];\n        let result = this.root.pointShapes(point);\n\n        if (sectorRoot) {\n            result = result.concat(sectorRoot.pointShapes(point));\n        }\n\n        this.assignZindex(result);\n\n        result.sort(zIndexComparer);\n        for (let idx = 0; idx < result.length; idx++) {\n            if (result[idx].containsPoint(point)) {\n                return result[idx];\n            }\n        }\n    }\n\n    assignZindex(elements) {\n        for (let idx = 0; idx < elements.length; idx++) {\n            let element = elements[idx];\n            let zIndex = 0;\n            let levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n            let parents = [];\n\n            while (element) {\n                parents.push(element);\n                element = element.parent;\n            }\n\n            while (parents.length) {\n                element = parents.pop();\n                zIndex += ((element.parent ? element.parent.children : this.rootElements).indexOf(element) + 1) * levelWeight;\n                levelWeight /= LEVEL_STEP;\n            }\n\n            elements[idx]._zIndex = zIndex;\n        }\n    }\n\n    optionsChange(e) {\n        if (e.field === \"transform\" || e.field === \"stroke.width\") {\n            this.bboxChange(e.element);\n        }\n    }\n\n    geometryChange(e) {\n        this.bboxChange(e.element);\n    }\n\n    bboxChange(element) {\n        if (element.nodeType === \"Group\") {\n            for (let idx = 0; idx < element.children.length; idx++) {\n                this.bboxChange(element.children[idx]);\n            }\n        } else {\n            if (element._quadNode) {\n                element._quadNode.remove(element);\n            }\n            this._insertShape(element);\n        }\n    }\n\n    add(elements) {\n        const elementsArray = Array.isArray(elements) ? elements.slice(0) : [ elements ];\n\n        append(this.rootElements, elementsArray);\n        this._insert(elementsArray);\n    }\n\n    childrenChange(e) {\n        if (e.action === \"remove\") {\n            for (let idx = 0; idx < e.items.length; idx++) {\n                this.remove(e.items[idx]);\n            }\n        } else {\n            this._insert(Array.prototype.slice.call(e.items, 0));\n        }\n    }\n\n    _insert(elements) {\n        let element;\n\n        while (elements.length > 0) {\n            element = elements.pop();\n            element.addObserver(this);\n            if (element.nodeType === \"Group\") {\n                append(elements, element.children);\n            } else {\n                this._insertShape(element);\n            }\n        }\n    }\n\n    _insertShape(shape) {\n        const bbox = shape.bbox();\n        if (bbox) {\n            const sectors = this.getSectors(bbox);\n            const x = sectors[0][0];\n            const y = sectors[1][0];\n\n            if (this.inRoot(sectors)) {\n                this.root.insert(shape, bbox);\n            } else {\n                const rootMap = this.rootMap;\n                if (!rootMap[x]) {\n                    rootMap[x] = {};\n                }\n\n                if (!rootMap[x][y]) {\n                    rootMap[x][y] = new QuadNode(\n                        new Rect([ x * ROOT_SIZE, y * ROOT_SIZE ], [ ROOT_SIZE, ROOT_SIZE ])\n                    );\n                }\n\n                rootMap[x][y].insert(shape, bbox);\n            }\n        }\n    }\n\n    remove(element) {\n        element.removeObserver(this);\n\n        if (element.nodeType === \"Group\") {\n            const children = element.children;\n            for (let idx = 0; idx < children.length; idx++) {\n                this.remove(children[idx]);\n            }\n        } else if (element._quadNode) {\n            element._quadNode.remove(element);\n            delete element._quadNode;\n        }\n    }\n\n    inRoot(sectors) {\n        return sectors[0].length > 1 || sectors[1].length > 1;\n    }\n\n    getSectors(rect) {\n        const bottomRight = rect.bottomRight();\n        const bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n        const bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n        const sectors = [ [], [] ];\n        for (let x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n            sectors[0].push(x);\n        }\n        for (let y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n            sectors[1].push(y);\n        }\n        return sectors;\n    }\n}\n\nfunction zIndexComparer(x1, x2) {\n    if (x1._zIndex < x2._zIndex) {\n        return 1;\n    }\n    if (x1._zIndex > x2._zIndex) {\n        return -1;\n    }\n\n    return 0;\n}\n\nexport default ShapesQuadTree;"]},"metadata":{},"sourceType":"module"}