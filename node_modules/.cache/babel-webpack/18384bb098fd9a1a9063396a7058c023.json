{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createClass from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\nexport var Path = /*#__PURE__*/function (_paintable) {\n  _inherits(Path, _paintable);\n\n  var _super = _createSuper(Path);\n\n  _createClass(Path, [{\n    key: \"nodeType\",\n    get: function get() {\n      return \"Path\";\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(str, options) {\n      return MultiPath.parse(str, options);\n    }\n  }]);\n\n  function Path(options) {\n    var _this;\n\n    _classCallCheck(this, Path);\n\n    _this = _super.call(this, options);\n    _this.segments = new GeometryElementsArray();\n\n    _this.segments.addObserver(_assertThisInitialized(_this));\n\n    if (!defined(_this.options.stroke)) {\n      _this.stroke(\"#000\");\n\n      if (!defined(_this.options.stroke.lineJoin)) {\n        _this.options.set(\"stroke.lineJoin\", \"miter\");\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(Path, [{\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      this.suspend();\n      this.segments.elements([]);\n      this.resume();\n      this.lineTo(x, y);\n      return this;\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo(x, y) {\n      var point = defined(y) ? new Point(x, y) : x;\n      var segment = new Segment(point);\n      this.segments.push(segment);\n      return this;\n    }\n  }, {\n    key: \"curveTo\",\n    value: function curveTo(controlOut, controlIn, point) {\n      if (this.segments.length > 0) {\n        var lastSegment = last(this.segments);\n        var segment = new Segment(point, controlIn);\n        this.suspend();\n        lastSegment.controlOut(controlOut);\n        this.resume();\n        this.segments.push(segment);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n      if (this.segments.length > 0) {\n        var lastSegment = last(this.segments);\n        var anchor = lastSegment.anchor();\n        var start = rad(startAngle);\n        var center = new Point(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));\n        var arc = new Arc(center, {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          radiusX: radiusX,\n          radiusY: radiusY,\n          anticlockwise: anticlockwise\n        });\n\n        this._addArcSegments(arc);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"arcTo\",\n    value: function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n      if (this.segments.length > 0) {\n        var lastSegment = last(this.segments);\n        var anchor = lastSegment.anchor();\n        var arc = Arc.fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\n\n        this._addArcSegments(arc);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_addArcSegments\",\n    value: function _addArcSegments(arc) {\n      this.suspend();\n      var curvePoints = arc.curvePoints();\n\n      for (var i = 1; i < curvePoints.length; i += 3) {\n        this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n      }\n\n      this.resume();\n      this.geometryChange();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.options.closed = true;\n      this.geometryChange();\n      return this;\n    }\n  }, {\n    key: \"rawBBox\",\n    value: function rawBBox() {\n      return this._bbox();\n    }\n  }, {\n    key: \"_containsPoint\",\n    value: function _containsPoint(point) {\n      var segments = this.segments;\n      var length = segments.length;\n      var intersectionsCount = 0;\n      var previous, current;\n\n      for (var idx = 1; idx < length; idx++) {\n        previous = segments[idx - 1];\n        current = segments[idx];\n        intersectionsCount += previous._intersectionsTo(current, point);\n      }\n\n      if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n        intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n      }\n\n      return intersectionsCount % 2 !== 0;\n    }\n  }, {\n    key: \"_isOnPath\",\n    value: function _isOnPath(point, width) {\n      var segments = this.segments;\n      var length = segments.length;\n      var pathWidth = width || this.options.stroke.width;\n\n      if (length > 1) {\n        if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n          return true;\n        }\n\n        for (var idx = 2; idx <= length - 2; idx++) {\n          if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n            return true;\n          }\n        }\n\n        if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_bbox\",\n    value: function _bbox(matrix) {\n      var segments = this.segments;\n      var length = segments.length;\n      var boundingBox;\n\n      if (length === 1) {\n        var anchor = segments[0].anchor().transformCopy(matrix);\n        boundingBox = new Rect(anchor, Size.ZERO);\n      } else if (length > 0) {\n        for (var i = 1; i < length; i++) {\n          var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n\n          if (boundingBox) {\n            boundingBox = Rect.union(boundingBox, segmentBox);\n          } else {\n            boundingBox = segmentBox;\n          }\n        }\n      }\n\n      return boundingBox;\n    }\n  }], [{\n    key: \"fromRect\",\n    value: function fromRect(rect, options) {\n      return new Path(options).moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();\n    }\n  }, {\n    key: \"fromPoints\",\n    value: function fromPoints(points, options) {\n      if (points) {\n        var path = new Path(options);\n\n        for (var i = 0; i < points.length; i++) {\n          var point = Point.create(points[i]);\n\n          if (point) {\n            if (i === 0) {\n              path.moveTo(point);\n            } else {\n              path.lineTo(point);\n            }\n          }\n        }\n\n        return path;\n      }\n    }\n  }, {\n    key: \"fromArc\",\n    value: function fromArc(arc, options) {\n      var path = new Path(options);\n      var startAngle = arc.startAngle;\n      var start = arc.pointAt(startAngle);\n      path.moveTo(start.x, start.y);\n      path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n      return path;\n    }\n  }]);\n\n  return Path;\n}(paintable(measurable(Element)));\nexport var MultiPath = /*#__PURE__*/function (_paintable2) {\n  _inherits(MultiPath, _paintable2);\n\n  var _super2 = _createSuper(MultiPath);\n\n  _createClass(MultiPath, [{\n    key: \"nodeType\",\n    get: function get() {\n      return \"MultiPath\";\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(str, options) {\n      var instance = new MultiPath(options);\n      return parsePath(instance, str);\n    }\n  }]);\n\n  function MultiPath(options) {\n    var _this2;\n\n    _classCallCheck(this, MultiPath);\n\n    _this2 = _super2.call(this, options);\n    _this2.paths = new GeometryElementsArray();\n\n    _this2.paths.addObserver(_assertThisInitialized(_this2));\n\n    if (!defined(_this2.options.stroke)) {\n      _this2.stroke(\"#000\");\n    }\n\n    return _this2;\n  }\n\n  _createClass(MultiPath, [{\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      var path = new Path();\n      path.moveTo(x, y);\n      this.paths.push(path);\n      return this;\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo(x, y) {\n      if (this.paths.length > 0) {\n        last(this.paths).lineTo(x, y);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"curveTo\",\n    value: function curveTo(controlOut, controlIn, point) {\n      if (this.paths.length > 0) {\n        last(this.paths).curveTo(controlOut, controlIn, point);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n      if (this.paths.length > 0) {\n        last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"arcTo\",\n    value: function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n      if (this.paths.length > 0) {\n        last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.paths.length > 0) {\n        last(this.paths).close();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_bbox\",\n    value: function _bbox(matrix) {\n      return elementsBoundingBox(this.paths, true, matrix);\n    }\n  }, {\n    key: \"rawBBox\",\n    value: function rawBBox() {\n      return elementsBoundingBox(this.paths, false);\n    }\n  }, {\n    key: \"_containsPoint\",\n    value: function _containsPoint(point) {\n      var paths = this.paths;\n\n      for (var idx = 0; idx < paths.length; idx++) {\n        if (paths[idx]._containsPoint(point)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_isOnPath\",\n    value: function _isOnPath(point) {\n      var paths = this.paths;\n      var width = this.options.stroke.width;\n\n      for (var idx = 0; idx < paths.length; idx++) {\n        if (paths[idx]._isOnPath(point, width)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_clippedBBox\",\n    value: function _clippedBBox(transformation) {\n      return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n    }\n  }]);\n\n  return MultiPath;\n}(paintable(measurable(Element)));","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/shapes/path.js"],"names":["GeometryElementsArray","Element","paintable","measurable","Arc","Rect","Segment","Point","Size","lineIntersectionsCount","defined","last","rad","parsePath","elementsBoundingBox","elementsClippedBoundingBox","Path","str","options","MultiPath","parse","segments","addObserver","stroke","lineJoin","set","x","y","suspend","elements","resume","lineTo","point","segment","push","controlOut","controlIn","length","lastSegment","startAngle","endAngle","radiusX","radiusY","anticlockwise","anchor","start","center","Math","cos","sin","arc","_addArcSegments","end","rx","ry","largeArc","swipe","rotation","fromPoints","curvePoints","i","curveTo","geometryChange","closed","_bbox","intersectionsCount","previous","current","idx","_intersectionsTo","equals","width","pathWidth","_isOnPathTo","matrix","boundingBox","transformCopy","ZERO","segmentBox","bboxTo","union","rect","moveTo","topLeft","topRight","bottomRight","bottomLeft","close","points","path","create","pointAt","instance","paths","arcTo","_containsPoint","_isOnPath","transformation","currentTransform"],"mappings":"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","sourcesContent":["import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\n\n\nexport class Path extends paintable(measurable(Element)) {\n    static parse(str, options) {\n        return MultiPath.parse(str, options);\n    }\n\n    get nodeType() {\n        return \"Path\";\n    }\n\n    constructor(options) {\n        super(options);\n        this.segments = new GeometryElementsArray();\n        this.segments.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke(\"#000\");\n\n            if (!defined(this.options.stroke.lineJoin)) {\n                this.options.set(\"stroke.lineJoin\", \"miter\");\n            }\n        }\n    }\n\n    moveTo(x, y) {\n        this.suspend();\n        this.segments.elements([]);\n        this.resume();\n\n        this.lineTo(x, y);\n\n        return this;\n    }\n\n    lineTo(x, y) {\n        const point = defined(y) ? new Point(x, y) : x;\n        const segment = new Segment(point);\n\n        this.segments.push(segment);\n\n        return this;\n    }\n\n    curveTo(controlOut, controlIn, point) {\n        if (this.segments.length > 0) {\n            const lastSegment = last(this.segments);\n            const segment = new Segment(point, controlIn);\n            this.suspend();\n            lastSegment.controlOut(controlOut);\n            this.resume();\n\n            this.segments.push(segment);\n        }\n\n        return this;\n    }\n\n    arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.segments.length > 0) {\n            const lastSegment = last(this.segments);\n            const anchor = lastSegment.anchor();\n            const start = rad(startAngle);\n            const center = new Point(anchor.x - radiusX * Math.cos(start),\n                anchor.y - radiusY * Math.sin(start));\n            const arc = new Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radiusX,\n                radiusY: radiusY,\n                anticlockwise: anticlockwise\n            });\n\n            this._addArcSegments(arc);\n        }\n\n        return this;\n    }\n\n    arcTo(end, rx, ry, largeArc, swipe, rotation) {\n        if (this.segments.length > 0) {\n            const lastSegment = last(this.segments);\n            const anchor = lastSegment.anchor();\n            const arc = Arc.fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\n\n            this._addArcSegments(arc);\n        }\n        return this;\n    }\n\n    _addArcSegments(arc) {\n        this.suspend();\n\n        const curvePoints = arc.curvePoints();\n\n        for (let i = 1; i < curvePoints.length; i += 3) {\n            this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n        }\n\n        this.resume();\n        this.geometryChange();\n    }\n\n    close() {\n        this.options.closed = true;\n        this.geometryChange();\n\n        return this;\n    }\n\n    rawBBox() {\n        return this._bbox();\n    }\n\n    _containsPoint(point) {\n        const segments = this.segments;\n        const length = segments.length;\n        let intersectionsCount = 0;\n        let previous, current;\n\n        for (let idx = 1; idx < length; idx++) {\n            previous = segments[idx - 1];\n            current = segments[idx];\n            intersectionsCount += previous._intersectionsTo(current, point);\n        }\n\n        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n            intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n        }\n\n        return intersectionsCount % 2 !== 0;\n    }\n\n    _isOnPath(point, width) {\n        const segments = this.segments;\n        const length = segments.length;\n        const pathWidth = width || this.options.stroke.width;\n\n        if (length > 1) {\n            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n                return true;\n            }\n\n            for (let idx = 2; idx <= length - 2; idx++) {\n                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n                    return true;\n                }\n            }\n\n            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _bbox(matrix) {\n        const segments = this.segments;\n        const length = segments.length;\n        let boundingBox;\n\n        if (length === 1) {\n            let anchor = segments[0].anchor().transformCopy(matrix);\n            boundingBox = new Rect(anchor, Size.ZERO);\n        } else if (length > 0) {\n            for (let i = 1; i < length; i++) {\n                let segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n                if (boundingBox) {\n                    boundingBox = Rect.union(boundingBox, segmentBox);\n                } else {\n                    boundingBox = segmentBox;\n                }\n            }\n        }\n\n        return boundingBox;\n    }\n\n    static fromRect(rect, options) {\n        return new Path(options)\n            .moveTo(rect.topLeft())\n            .lineTo(rect.topRight())\n            .lineTo(rect.bottomRight())\n            .lineTo(rect.bottomLeft())\n            .close();\n    }\n\n    static fromPoints(points, options) {\n        if (points) {\n            const path = new Path(options);\n\n            for (let i = 0; i < points.length; i++) {\n                let point = Point.create(points[i]);\n                if (point) {\n                    if (i === 0) {\n                        path.moveTo(point);\n                    } else {\n                        path.lineTo(point);\n                    }\n                }\n            }\n\n            return path;\n        }\n    }\n\n    static fromArc(arc, options) {\n        const path = new Path(options);\n        const startAngle = arc.startAngle;\n        const start = arc.pointAt(startAngle);\n        path.moveTo(start.x, start.y);\n        path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n        return path;\n    }\n}\n\nexport class MultiPath extends paintable(measurable(Element)) {\n    static parse(str, options) {\n        const instance = new MultiPath(options);\n        return parsePath(instance, str);\n    }\n\n    get nodeType() {\n        return \"MultiPath\";\n    }\n\n    constructor(options) {\n        super(options);\n        this.paths = new GeometryElementsArray();\n        this.paths.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke(\"#000\");\n        }\n    }\n\n    moveTo(x, y) {\n        const path = new Path();\n        path.moveTo(x, y);\n\n        this.paths.push(path);\n\n        return this;\n    }\n\n    lineTo(x, y) {\n        if (this.paths.length > 0) {\n            last(this.paths).lineTo(x, y);\n        }\n\n        return this;\n    }\n\n    curveTo(controlOut, controlIn, point) {\n        if (this.paths.length > 0) {\n            last(this.paths).curveTo(controlOut, controlIn, point);\n        }\n\n        return this;\n    }\n\n    arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.paths.length > 0) {\n            last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n        }\n\n        return this;\n    }\n\n    arcTo(end, rx, ry, largeArc, swipe, rotation) {\n        if (this.paths.length > 0) {\n            last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n        }\n\n        return this;\n    }\n\n    close() {\n        if (this.paths.length > 0) {\n            last(this.paths).close();\n        }\n\n        return this;\n    }\n\n    _bbox(matrix) {\n        return elementsBoundingBox(this.paths, true, matrix);\n    }\n\n    rawBBox() {\n        return elementsBoundingBox(this.paths, false);\n    }\n\n    _containsPoint(point) {\n        const paths = this.paths;\n\n        for (let idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._containsPoint(point)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _isOnPath(point) {\n        const paths = this.paths;\n        const width = this.options.stroke.width;\n\n        for (let idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._isOnPath(point, width)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _clippedBBox(transformation) {\n        return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}