{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\nvar accessors = [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"];\n\nvar Arc = /*#__PURE__*/function (_withAccessors) {\n  _inherits(Arc, _withAccessors);\n\n  var _super = _createSuper(Arc);\n\n  function Arc() {\n    var _this;\n\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Point();\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Arc);\n\n    _this = _super.call(this);\n\n    _this.setCenter(center);\n\n    _this.radiusX = options.radiusX;\n    _this.radiusY = options.radiusY || options.radiusX;\n    _this.startAngle = options.startAngle;\n    _this.endAngle = options.endAngle;\n    _this.anticlockwise = options.anticlockwise || false;\n    _this.xRotation = options.xRotation;\n    return _this;\n  }\n\n  _createClass(Arc, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Arc(this.center, {\n        radiusX: this.radiusX,\n        radiusY: this.radiusY,\n        startAngle: this.startAngle,\n        endAngle: this.endAngle,\n        anticlockwise: this.anticlockwise\n      });\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter(value) {\n      this._observerField(\"center\", Point.create(value));\n\n      this.geometryChange();\n      return this;\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(angle) {\n      var center = this.center;\n      var radian = rad(angle);\n      return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n    }\n  }, {\n    key: \"curvePoints\",\n    value: function curvePoints() {\n      var startAngle = this.startAngle;\n      var dir = this.anticlockwise ? -1 : 1;\n      var curvePoints = [this.pointAt(startAngle)];\n\n      var interval = this._arcInterval();\n\n      var intervalAngle = interval.endAngle - interval.startAngle;\n      var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n      var subIntervalAngle = intervalAngle / subIntervalsCount;\n      var currentAngle = startAngle;\n      var transformation;\n\n      if (this.xRotation) {\n        transformation = transform().rotate(this.xRotation, this.center);\n      }\n\n      for (var i = 1; i <= subIntervalsCount; i++) {\n        var nextAngle = currentAngle + dir * subIntervalAngle;\n\n        var points = this._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n        curvePoints.push(points.cp1, points.cp2, points.p2);\n        currentAngle = nextAngle;\n      }\n\n      return curvePoints;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox(matrix) {\n      var interval = this._arcInterval();\n\n      var startAngle = interval.startAngle;\n      var endAngle = interval.endAngle;\n      var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n      var extremeX = deg(extremeAngles.x);\n      var extremeY = deg(extremeAngles.y);\n      var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n      var currentAngleX = bboxStartAngle(extremeX, startAngle);\n      var currentAngleY = bboxStartAngle(extremeY, startAngle);\n      var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n      var minPoint = Point.min(currentPoint, endPoint);\n      var maxPoint = Point.max(currentPoint, endPoint);\n\n      while (currentAngleX < endAngle || currentAngleY < endAngle) {\n        var currentPointX = void 0;\n\n        if (currentAngleX < endAngle) {\n          currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);\n          currentAngleX += 90;\n        }\n\n        var currentPointY = void 0;\n\n        if (currentAngleY < endAngle) {\n          currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);\n          currentAngleY += 90;\n        }\n\n        currentPoint = new Point(currentPointX.x, currentPointY.y);\n        minPoint = Point.min(minPoint, currentPoint);\n        maxPoint = Point.max(maxPoint, currentPoint);\n      }\n\n      return Rect.fromPoints(minPoint, maxPoint);\n    }\n  }, {\n    key: \"_arcInterval\",\n    value: function _arcInterval() {\n      var startAngle = this.startAngle,\n          endAngle = this.endAngle,\n          anticlockwise = this.anticlockwise;\n\n      if (anticlockwise) {\n        var oldStart = startAngle;\n        startAngle = endAngle;\n        endAngle = oldStart;\n      }\n\n      if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n        endAngle += 360;\n      }\n\n      return {\n        startAngle: startAngle,\n        endAngle: endAngle\n      };\n    }\n  }, {\n    key: \"_intervalCurvePoints\",\n    value: function _intervalCurvePoints(startAngle, endAngle, transformation) {\n      var p1 = this.pointAt(startAngle);\n      var p2 = this.pointAt(endAngle);\n\n      var p1Derivative = this._derivativeAt(startAngle);\n\n      var p2Derivative = this._derivativeAt(endAngle);\n\n      var t = (rad(endAngle) - rad(startAngle)) / 3;\n      var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n      var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n\n      if (transformation) {\n        p1.transform(transformation);\n        p2.transform(transformation);\n        cp1.transform(transformation);\n        cp2.transform(transformation);\n      }\n\n      return {\n        p1: p1,\n        cp1: cp1,\n        cp2: cp2,\n        p2: p2\n      };\n    }\n  }, {\n    key: \"_derivativeAt\",\n    value: function _derivativeAt(angle) {\n      var radian = rad(angle);\n      return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var interval = this._arcInterval();\n\n      var intervalAngle = interval.endAngle - interval.startAngle;\n      var center = this.center,\n          radiusX = this.radiusX,\n          radiusY = this.radiusY;\n      var distance = center.distanceTo(point);\n      var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n      var pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n      var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n      var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n      var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n      var containsPoint;\n\n      if (intervalAngle < 180) {\n        containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n      } else {\n        var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n\n        if (angle !== 360) {\n          angle = (360 + angle) % 360;\n        }\n\n        var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n        containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n      }\n\n      return containsPoint;\n    }\n  }, {\n    key: \"_isOnPath\",\n    value: function _isOnPath(point, width) {\n      var interval = this._arcInterval();\n\n      var center = this.center;\n      var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n\n      if (angle !== 360) {\n        angle = (360 + angle) % 360;\n      }\n\n      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n      return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n    }\n  }], [{\n    key: \"fromPoints\",\n    value: function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n      // eslint-disable-line max-params\n      var arcParameters = normalizeArcParameters({\n        x1: start.x,\n        y1: start.y,\n        x2: end.x,\n        y2: end.y,\n        rx: rx,\n        ry: ry,\n        largeArc: largeArc,\n        swipe: swipe,\n        rotation: rotation\n      });\n      return new Arc(arcParameters.center, {\n        startAngle: arcParameters.startAngle,\n        endAngle: arcParameters.endAngle,\n        radiusX: arcParameters.radiusX,\n        radiusY: arcParameters.radiusY,\n        xRotation: arcParameters.xRotation,\n        anticlockwise: swipe === 0\n      });\n    }\n  }]);\n\n  return Arc;\n}(withAccessors(HasObservers, accessors));\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n  var cos = round((x - cx) / rx, 3);\n  var sin = round((y - cy) / ry, 3);\n  return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n  var x1 = parameters.x1,\n      y1 = parameters.y1,\n      x2 = parameters.x2,\n      y2 = parameters.y2,\n      rx = parameters.rx,\n      ry = parameters.ry,\n      largeArc = parameters.largeArc,\n      swipe = parameters.swipe,\n      _parameters$rotation = parameters.rotation,\n      rotation = _parameters$rotation === void 0 ? 0 : _parameters$rotation;\n  var radians = rad(rotation);\n  var cosine = Math.cos(radians);\n  var sine = Math.sin(radians);\n  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n  var sign = largeArc !== swipe ? 1 : -1;\n  var xt2 = Math.pow(xT, 2);\n  var yt2 = Math.pow(yT, 2);\n  var rx2 = Math.pow(rx, 2);\n  var ry2 = Math.pow(ry, 2);\n  var delta = xt2 / rx2 + yt2 / ry2;\n\n  if (delta > 1) {\n    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n    rx = delta * rx;\n    rx2 = Math.pow(rx, 2);\n    ry = delta * ry;\n    ry2 = Math.pow(ry, 2);\n  }\n\n  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2)); // due to rounding errors the value could become NaN even after radii correction\n\n  if (isNaN(constT)) {\n    constT = 0;\n  }\n\n  var cxT = constT * (rx * yT) / ry;\n  var cyT = -constT * (ry * xT) / rx;\n  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n  var uX = (xT - cxT) / rx;\n  var uY = (yT - cyT) / ry;\n  var vX = -(xT + cxT) / rx;\n  var vY = -(yT + cyT) / ry;\n  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n  var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n  if (!swipe && angle > 0) {\n    angle -= 360;\n  }\n\n  if (swipe && angle < 0) {\n    angle += 360;\n  }\n\n  var endAngle = startAngle + angle;\n  var signEndAngle = endAngle >= 0 ? 1 : -1;\n  endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n  return {\n    center: new Point(cx, cy),\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    xRotation: rotation\n  };\n}\n\nfunction bboxStartAngle(angle, start) {\n  var startAngle = angle;\n\n  while (startAngle < start) {\n    startAngle += 90;\n  }\n\n  return startAngle;\n}\n\nexport default Arc;","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/geometry/arc.js"],"names":["HasObservers","deg","rad","round","withAccessors","closeOrLess","lineIntersection","ellipseExtremeAngles","PRECISION","Point","Rect","transform","MAX_INTERVAL","pow","Math","accessors","Arc","center","options","setCenter","radiusX","radiusY","startAngle","endAngle","anticlockwise","xRotation","value","_observerField","create","geometryChange","angle","radian","x","cos","y","sin","dir","curvePoints","pointAt","interval","_arcInterval","intervalAngle","subIntervalsCount","ceil","subIntervalAngle","currentAngle","transformation","rotate","i","nextAngle","points","_intervalCurvePoints","push","cp1","cp2","p2","matrix","extremeAngles","extremeX","extremeY","endPoint","transformCopy","currentAngleX","bboxStartAngle","currentAngleY","currentPoint","minPoint","min","maxPoint","max","currentPointX","currentPointY","fromPoints","oldStart","p1","p1Derivative","_derivativeAt","p2Derivative","t","point","distance","distanceTo","angleRad","atan2","pointRadius","sqrt","startPoint","intersection","containsPoint","calculateAngle","inAngleRange","equals","width","start","end","rx","ry","largeArc","swipe","rotation","arcParameters","normalizeArcParameters","x1","y1","x2","y2","cx","cy","parameters","radians","cosine","sine","xT","yT","sign","xt2","yt2","rx2","ry2","delta","constT","isNaN","cxT","cyT","uX","uY","vX","vY","acos","angleCosine","signEndAngle","abs"],"mappings":"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","sourcesContent":["import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\n\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\n\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\n\n\nconst MAX_INTERVAL = 45;\nconst pow = Math.pow;\nconst accessors = [ \"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\" ];\n\nclass Arc extends withAccessors(HasObservers, accessors) {\n    constructor(center = new Point(), options = {}) {\n        super();\n\n        this.setCenter(center);\n\n        this.radiusX = options.radiusX;\n        this.radiusY = options.radiusY || options.radiusX;\n        this.startAngle = options.startAngle;\n        this.endAngle = options.endAngle;\n        this.anticlockwise = options.anticlockwise || false;\n        this.xRotation = options.xRotation;\n    }\n\n    clone() {\n        return new Arc(this.center, {\n            radiusX: this.radiusX,\n            radiusY: this.radiusY,\n            startAngle: this.startAngle,\n            endAngle: this.endAngle,\n            anticlockwise: this.anticlockwise\n        });\n    }\n\n    setCenter(value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getCenter() {\n        return this.center;\n    }\n\n    pointAt(angle) {\n        const center = this.center;\n        const radian = rad(angle);\n\n        return new Point(\n            center.x + this.radiusX * Math.cos(radian),\n            center.y + this.radiusY * Math.sin(radian)\n        );\n    }\n\n    curvePoints() {\n        const startAngle = this.startAngle;\n        const dir = this.anticlockwise ? -1 : 1;\n        const curvePoints = [ this.pointAt(startAngle) ];\n        const interval = this._arcInterval();\n        const intervalAngle = interval.endAngle - interval.startAngle;\n        const subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n        const subIntervalAngle = intervalAngle / subIntervalsCount;\n        let currentAngle = startAngle;\n        let transformation;\n        if (this.xRotation) {\n            transformation = transform().rotate(this.xRotation, this.center);\n        }\n\n        for (let i = 1; i <= subIntervalsCount; i++) {\n            const nextAngle = currentAngle + dir * subIntervalAngle;\n            const points = this._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n            curvePoints.push(points.cp1, points.cp2, points.p2);\n            currentAngle = nextAngle;\n        }\n\n        return curvePoints;\n    }\n\n    bbox(matrix) {\n        const interval = this._arcInterval();\n        const startAngle = interval.startAngle;\n        const endAngle = interval.endAngle;\n        const extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n        const extremeX = deg(extremeAngles.x);\n        const extremeY = deg(extremeAngles.y);\n        const endPoint = this.pointAt(endAngle).transformCopy(matrix);\n        let currentAngleX = bboxStartAngle(extremeX, startAngle);\n        let currentAngleY = bboxStartAngle(extremeY, startAngle);\n        let currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n        let minPoint = Point.min(currentPoint, endPoint);\n        let maxPoint = Point.max(currentPoint, endPoint);\n\n        while (currentAngleX < endAngle || currentAngleY < endAngle) {\n            let currentPointX;\n            if (currentAngleX < endAngle) {\n                currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);\n                currentAngleX += 90;\n            }\n\n            let currentPointY;\n            if (currentAngleY < endAngle) {\n                currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);\n                currentAngleY += 90;\n            }\n\n            currentPoint = new Point(currentPointX.x, currentPointY.y);\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    }\n\n    _arcInterval() {\n        let { startAngle, endAngle, anticlockwise } = this;\n\n        if (anticlockwise) {\n            let oldStart = startAngle;\n            startAngle = endAngle;\n            endAngle = oldStart;\n        }\n\n        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\n            endAngle += 360;\n        }\n\n        return {\n            startAngle: startAngle,\n            endAngle: endAngle\n        };\n    }\n\n    _intervalCurvePoints(startAngle, endAngle, transformation) {\n        const p1 = this.pointAt(startAngle);\n        const p2 = this.pointAt(endAngle);\n        const p1Derivative = this._derivativeAt(startAngle);\n        const p2Derivative = this._derivativeAt(endAngle);\n        const t = (rad(endAngle) - rad(startAngle)) / 3;\n        const cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n        const cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n        if (transformation) {\n            p1.transform(transformation);\n            p2.transform(transformation);\n            cp1.transform(transformation);\n            cp2.transform(transformation);\n        }\n\n        return {\n            p1: p1,\n            cp1: cp1,\n            cp2: cp2,\n            p2: p2\n        };\n    }\n\n    _derivativeAt(angle) {\n        const radian = rad(angle);\n\n        return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n    }\n\n    containsPoint(point) {\n        const interval = this._arcInterval();\n        const intervalAngle = interval.endAngle - interval.startAngle;\n        const { center, radiusX, radiusY } = this;\n        const distance = center.distanceTo(point);\n        const angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n        const pointRadius = (radiusX * radiusY) /\n            Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n        const startPoint = this.pointAt(this.startAngle).round(PRECISION);\n        const endPoint = this.pointAt(this.endAngle).round(PRECISION);\n        const intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n        let containsPoint;\n\n        if (intervalAngle < 180) {\n            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n        } else {\n            let angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n            if (angle !== 360) {\n                angle = (360 + angle) % 360;\n            }\n\n            let inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\n        }\n        return containsPoint;\n    }\n\n    _isOnPath(point, width) {\n        const interval = this._arcInterval();\n        const center = this.center;\n        let angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n        if (angle !== 360) {\n            angle = (360 + angle) % 360;\n        }\n\n        const inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\n        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n    }\n\n    static fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\n        const arcParameters = normalizeArcParameters({\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y,\n            rx: rx,\n            ry: ry,\n            largeArc: largeArc,\n            swipe: swipe,\n            rotation: rotation\n        });\n\n        return new Arc(arcParameters.center, {\n            startAngle: arcParameters.startAngle,\n            endAngle: arcParameters.endAngle,\n            radiusX: arcParameters.radiusX,\n            radiusY: arcParameters.radiusY,\n            xRotation: arcParameters.xRotation,\n            anticlockwise: swipe === 0\n        });\n    }\n}\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n    const cos = round((x - cx) / rx, 3);\n    const sin = round((y - cy) / ry, 3);\n\n    return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n    let { x1, y1, x2, y2, rx, ry, largeArc, swipe, rotation = 0 } = parameters;\n\n    const radians = rad(rotation);\n    const cosine = Math.cos(radians);\n    const sine = Math.sin(radians);\n\n    const xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n    const yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n\n    const sign = largeArc !== swipe ? 1 : -1;\n\n    const xt2 = Math.pow(xT, 2);\n    const yt2 = Math.pow(yT, 2);\n    let rx2 = Math.pow(rx, 2);\n    let ry2 = Math.pow(ry, 2);\n\n    let delta = xt2 / rx2 + yt2 / ry2;\n\n    if (delta > 1) {\n        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n        rx = delta * rx;\n        rx2 = Math.pow(rx, 2);\n\n        ry = delta * ry;\n        ry2 = Math.pow(ry, 2);\n    }\n\n    let constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n    // due to rounding errors the value could become NaN even after radii correction\n    if (isNaN(constT)) {\n        constT = 0;\n    }\n\n    const cxT = constT * (rx * yT) / ry;\n    const cyT = - constT * (ry * xT) / rx;\n\n    const cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n    const cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n\n\n    const uX = (xT - cxT) / rx;\n    const uY = (yT - cyT) / ry;\n    const vX = -(xT + cxT) / rx;\n    const vY = -(yT + cyT) / ry;\n\n    const startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n\n    const angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n    let angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n    if (!swipe && angle > 0) {\n        angle -= 360;\n    }\n\n    if (swipe && angle < 0) {\n        angle += 360;\n    }\n    let endAngle = startAngle + angle;\n    const signEndAngle = endAngle >= 0 ? 1 : -1;\n    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\n\n    return {\n        center: new Point(cx, cy),\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: rx,\n        radiusY: ry,\n        xRotation: rotation\n    };\n}\n\nfunction bboxStartAngle(angle, start) {\n    let startAngle = angle;\n\n    while (startAngle < start) {\n        startAngle += 90;\n    }\n\n    return startAngle;\n}\n\nexport default Arc;\n"]},"metadata":{},"sourceType":"module"}