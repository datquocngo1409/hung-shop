{"ast":null,"code":"import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\n\nvar valueToString = function valueToString(value) {\n  value = isPresent(value) && value.getTime ? value.getTime() : value;\n  return value + \"\";\n};\n/**\n * @hidden\n */\n\n\nexport var groupCombinator = function groupCombinator(field) {\n  var prop = getter(field, true);\n  var position = 0;\n  return function (agg, value) {\n    agg[field] = agg[field] || {};\n    var groupValue = prop(value);\n    var key = valueToString(groupValue);\n    var values = agg[field][key] || {\n      __position: position++,\n      aggregates: {},\n      items: [],\n      value: groupValue\n    };\n    values.items.push(value);\n    agg[field][key] = values;\n    return agg;\n  };\n};\n/**\n * @hidden\n */\n\nexport var expandAggregates = function expandAggregates() {\n  var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  Object.keys(result).forEach(function (field) {\n    var aggregates = result[field];\n    Object.keys(aggregates).forEach(function (aggregate) {\n      aggregates[aggregate] = aggregates[aggregate].result();\n    });\n  });\n  return result;\n};\n\nvar aggregatesFuncs = function aggregatesFuncs(name) {\n  return {\n    average: function average() {\n      var value = 0;\n      var count = 0;\n      return {\n        calc: function calc(curr) {\n          if (isNumeric(curr)) {\n            value += curr;\n            count++;\n          } else {\n            value = curr;\n          }\n        },\n        result: function result() {\n          return isNumeric(value) ? value / count : value;\n        }\n      };\n    },\n    count: function count() {\n      var state = 0;\n      return {\n        calc: function calc() {\n          return state++;\n        },\n        result: function result() {\n          return state;\n        }\n      };\n    },\n    max: function max() {\n      var state = Number.NEGATIVE_INFINITY;\n      return {\n        calc: function calc(value) {\n          state = isNumeric(state) || isDate(state) ? state : value;\n\n          if (state < value && (isNumeric(value) || isDate(value))) {\n            state = value;\n          }\n        },\n        result: function result() {\n          return state;\n        }\n      };\n    },\n    min: function min() {\n      var state = Number.POSITIVE_INFINITY;\n      return {\n        calc: function calc(value) {\n          state = isNumeric(state) || isDate(state) ? state : value;\n\n          if (state > value && (isNumeric(value) || isDate(value))) {\n            state = value;\n          }\n        },\n        result: function result() {\n          return state;\n        }\n      };\n    },\n    sum: function sum() {\n      var state = 0;\n      return {\n        calc: function calc(value) {\n          return state += value;\n        },\n        result: function result() {\n          return state;\n        }\n      };\n    }\n  }[name]();\n};\n/**\n * @hidden\n */\n\n\nexport var aggregatesCombinator = function aggregatesCombinator(descriptors) {\n  var functions = descriptors.map(function (descriptor) {\n    var fieldAccessor = getter(descriptor.field, true);\n    var aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n    var aggregateAccessor = getter(aggregateName, true);\n    return function (state, value) {\n      var fieldAggregates = state[descriptor.field] || {};\n      var aggregateFunction = aggregateAccessor(fieldAggregates) || aggregatesFuncs(aggregateName);\n      aggregateFunction.calc(fieldAccessor(value));\n      fieldAggregates[descriptor.aggregate] = aggregateFunction;\n      state[descriptor.field] = fieldAggregates;\n      return state;\n    };\n  });\n  return function (state, value) {\n    return functions.reduce(function (agg, calc) {\n      return calc(agg, value);\n    }, state);\n  };\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\n\nexport var concat = function concat(arr, value) {\n  arr.push(value);\n  return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\n\nexport var map = function map(transform) {\n  return function (reduce) {\n    return function (acc, curr, index) {\n      return reduce(acc, transform(curr, index));\n    };\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\n\nexport var filter = function filter(predicate) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return predicate(curr) ? reduce(acc, curr) : acc;\n    };\n  };\n};\n/**\n * @hidden\n */\n\nexport var isTransformerResult = function isTransformerResult(source) {\n  return isPresent(source.__value);\n};\n\nvar reduced = function reduced(x) {\n  if (isTransformerResult(x)) {\n    return x;\n  }\n\n  return {\n    __value: x,\n    reduced: true\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\n\n\nexport var take = function take(count) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return count-- > 0 ? reduce(acc, curr) : reduced(acc);\n    };\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\n\nexport var takeWhile = function takeWhile(predicate) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return predicate(curr) ? reduce(acc, curr) : reduced(acc);\n    };\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\n\nexport var skip = function skip(count) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return count-- <= 0 ? reduce(acc, curr) : acc;\n    };\n  };\n};\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\n\nexport var exec = function exec(transform, initialValue, data) {\n  var result = initialValue;\n\n  for (var idx = 0, length = data.length; idx < length; idx++) {\n    result = transform(result, data[idx], idx);\n\n    if (isTransformerResult(result)) {\n      result = result.__value;\n      break;\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-data-query/dist/es2015/transducers.js"],"names":["isPresent","isNumeric","isDate","getter","valueToString","value","getTime","groupCombinator","field","prop","position","agg","groupValue","key","values","__position","aggregates","items","push","expandAggregates","result","Object","keys","forEach","aggregate","aggregatesFuncs","name","average","count","calc","curr","state","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","sum","aggregatesCombinator","descriptors","functions","map","descriptor","fieldAccessor","aggregateName","toLowerCase","aggregateAccessor","fieldAggregates","aggregateFunction","reduce","concat","arr","transform","acc","index","filter","predicate","isTransformerResult","source","__value","reduced","x","take","takeWhile","skip","exec","initialValue","data","idx","length"],"mappings":"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","sourcesContent":["import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\nconst valueToString = (value) => {\n    value = isPresent(value) && value.getTime ? value.getTime() : value;\n    return value + \"\";\n};\n/**\n * @hidden\n */\nexport const groupCombinator = (field) => {\n    const prop = getter(field, true);\n    let position = 0;\n    return (agg, value) => {\n        agg[field] = agg[field] || {};\n        const groupValue = prop(value);\n        const key = valueToString(groupValue);\n        const values = agg[field][key] || { __position: position++, aggregates: {}, items: [], value: groupValue };\n        values.items.push(value);\n        agg[field][key] = values;\n        return agg;\n    };\n};\n/**\n * @hidden\n */\nexport const expandAggregates = (result = {}) => {\n    Object.keys(result).forEach(field => {\n        const aggregates = result[field];\n        Object.keys(aggregates).forEach(aggregate => {\n            aggregates[aggregate] = aggregates[aggregate].result();\n        });\n    });\n    return result;\n};\nconst aggregatesFuncs = (name) => ({\n    average: () => {\n        let value = 0;\n        let count = 0;\n        return {\n            calc: (curr) => {\n                if (isNumeric(curr)) {\n                    value += curr;\n                    count++;\n                }\n                else {\n                    value = curr;\n                }\n            },\n            result: () => isNumeric(value) ? value / count : value\n        };\n    },\n    count: () => {\n        let state = 0;\n        return {\n            calc: () => state++,\n            result: () => state\n        };\n    },\n    max: () => {\n        let state = Number.NEGATIVE_INFINITY;\n        return {\n            calc: (value) => {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state < value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: () => state\n        };\n    },\n    min: () => {\n        let state = Number.POSITIVE_INFINITY;\n        return {\n            calc: (value) => {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state > value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: () => state\n        };\n    },\n    sum: () => {\n        let state = 0;\n        return {\n            calc: (value) => state += value,\n            result: () => state\n        };\n    }\n}[name]());\n/**\n * @hidden\n */\nexport const aggregatesCombinator = (descriptors) => {\n    const functions = descriptors.map(descriptor => {\n        const fieldAccessor = getter(descriptor.field, true);\n        const aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n        const aggregateAccessor = getter(aggregateName, true);\n        return (state, value) => {\n            const fieldAggregates = state[descriptor.field] || {};\n            const aggregateFunction = aggregateAccessor(fieldAggregates)\n                || aggregatesFuncs(aggregateName);\n            aggregateFunction.calc(fieldAccessor(value));\n            fieldAggregates[descriptor.aggregate] = aggregateFunction;\n            state[descriptor.field] = fieldAggregates;\n            return state;\n        };\n    });\n    return (state, value) => functions.reduce((agg, calc) => calc(agg, value), state);\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\nexport const concat = (arr, value) => {\n    arr.push(value);\n    return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\nexport const map = (transform) => ((reduce) => ((acc, curr, index) => reduce(acc, transform(curr, index))));\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\nexport const filter = (predicate) => ((reduce) => ((acc, curr) => predicate(curr) ? reduce(acc, curr) : acc));\n/**\n * @hidden\n */\nexport const isTransformerResult = (source) => {\n    return isPresent(source.__value);\n};\nconst reduced = (x) => {\n    if (isTransformerResult(x)) {\n        return x;\n    }\n    return {\n        __value: x,\n        reduced: true\n    };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const take = (count) => ((reduce) => ((acc, curr) => count-- > 0 ? reduce(acc, curr) : reduced(acc)));\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const takeWhile = (predicate) => ((reduce) => ((acc, curr) => predicate(curr) ? reduce(acc, curr) : reduced(acc)));\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\nexport const skip = (count) => ((reduce) => ((acc, curr) => count-- <= 0 ? reduce(acc, curr) : acc));\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\nexport const exec = (transform, initialValue, data) => {\n    let result = initialValue;\n    for (let idx = 0, length = data.length; idx < length; idx++) {\n        result = transform(result, data[idx], idx);\n        if (isTransformerResult(result)) {\n            result = result.__value;\n            break;\n        }\n    }\n    return result;\n};\n"]},"metadata":{},"sourceType":"module"}