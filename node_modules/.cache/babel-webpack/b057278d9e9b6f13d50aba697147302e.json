{"ast":null,"code":"import { DEFAULT_LOCALE } from '../common/constants';\nimport isNumber from '../common/is-number';\nimport datePattern from './date-pattern';\nimport dateNameType from './date-name-type';\nimport { dateFormatRegExp, DATE_FIELD_MAP } from './constants';\nimport { localeInfo } from '../cldr';\nvar NAME_TYPES = {\n  month: {\n    type: 'months',\n    minLength: 3,\n    standAlone: 'L'\n  },\n  quarter: {\n    type: 'quarters',\n    minLength: 3,\n    standAlone: 'q'\n  },\n  weekday: {\n    type: 'days',\n    minLength: {\n      E: 0,\n      c: 3,\n      e: 3\n    },\n    standAlone: 'c'\n  },\n  dayperiod: {\n    type: 'dayPeriods',\n    minLength: 0\n  },\n  era: {\n    type: 'eras',\n    minLength: 0\n  }\n};\nvar LITERAL = 'literal';\n\nfunction addLiteral(parts, value) {\n  var lastPart = parts[parts.length - 1];\n\n  if (lastPart && lastPart.type === LITERAL) {\n    lastPart.pattern += value;\n  } else {\n    parts.push({\n      type: LITERAL,\n      pattern: value\n    });\n  }\n}\n\nfunction isHour12(pattern) {\n  return pattern === 'h' || pattern === 'K';\n}\n\nexport default function splitDateFormat(format) {\n  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LOCALE;\n  var info = localeInfo(locale);\n  var pattern = datePattern(format, info);\n  var parts = [];\n  var lastIndex = dateFormatRegExp.lastIndex = 0;\n  var match = dateFormatRegExp.exec(pattern);\n\n  while (match) {\n    var value = match[0];\n\n    if (lastIndex < match.index) {\n      addLiteral(parts, pattern.substring(lastIndex, match.index));\n    }\n\n    if (value.startsWith('\"') || value.startsWith(\"'\")) {\n      addLiteral(parts, value);\n    } else {\n      var specifier = value[0];\n      var type = DATE_FIELD_MAP[specifier];\n      var part = {\n        type: type,\n        pattern: value\n      };\n\n      if (type === 'hour') {\n        part.hour12 = isHour12(value);\n      }\n\n      var names = NAME_TYPES[type];\n\n      if (names) {\n        var minLength = isNumber(names.minLength) ? names.minLength : names.minLength[specifier];\n        var patternLength = value.length;\n\n        if (patternLength >= minLength) {\n          part.names = {\n            type: names.type,\n            nameType: dateNameType(patternLength),\n            standAlone: names.standAlone === specifier\n          };\n        }\n      }\n\n      parts.push(part);\n    }\n\n    lastIndex = dateFormatRegExp.lastIndex;\n    match = dateFormatRegExp.exec(pattern);\n  }\n\n  if (lastIndex < pattern.length) {\n    addLiteral(parts, pattern.substring(lastIndex));\n  }\n\n  return parts;\n}","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@telerik/kendo-intl/dist/es2015/dates/split-date-format.js"],"names":["DEFAULT_LOCALE","isNumber","datePattern","dateNameType","dateFormatRegExp","DATE_FIELD_MAP","localeInfo","NAME_TYPES","month","type","minLength","standAlone","quarter","weekday","E","c","e","dayperiod","era","LITERAL","addLiteral","parts","value","lastPart","length","pattern","push","isHour12","splitDateFormat","format","locale","info","lastIndex","match","exec","index","substring","startsWith","specifier","part","hour12","names","patternLength","nameType"],"mappings":"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","sourcesContent":["import { DEFAULT_LOCALE } from '../common/constants';\nimport isNumber from '../common/is-number';\nimport datePattern from './date-pattern';\nimport dateNameType from './date-name-type';\nimport { dateFormatRegExp, DATE_FIELD_MAP } from './constants';\nimport { localeInfo } from '../cldr';\n\nconst NAME_TYPES = {\n    month: {\n        type: 'months',\n        minLength: 3,\n        standAlone: 'L'\n    },\n\n    quarter: {\n        type: 'quarters',\n        minLength: 3,\n        standAlone: 'q'\n    },\n\n    weekday: {\n        type: 'days',\n        minLength: {\n            E: 0,\n            c: 3,\n            e: 3\n        },\n        standAlone: 'c'\n    },\n\n    dayperiod: {\n        type: 'dayPeriods',\n        minLength: 0\n    },\n\n    era: {\n        type: 'eras',\n        minLength: 0\n    }\n};\n\nconst LITERAL = 'literal';\n\nfunction addLiteral(parts, value) {\n    const lastPart = parts[parts.length - 1];\n    if (lastPart && lastPart.type === LITERAL) {\n        lastPart.pattern += value;\n    } else {\n        parts.push({\n            type: LITERAL,\n            pattern: value\n        });\n    }\n}\n\nfunction isHour12(pattern) {\n    return pattern === 'h' || pattern === 'K';\n}\n\nexport default function splitDateFormat(format, locale = DEFAULT_LOCALE) {\n    const info = localeInfo(locale);\n    const pattern = datePattern(format, info);\n    const parts = [];\n    let lastIndex = dateFormatRegExp.lastIndex = 0;\n    let match = dateFormatRegExp.exec(pattern);\n\n    while (match) {\n        let value = match[0];\n\n        if (lastIndex < match.index) {\n            addLiteral(parts, pattern.substring(lastIndex, match.index));\n        }\n\n        if (value.startsWith('\"') || value.startsWith(\"'\")) {\n            addLiteral(parts, value);\n        } else {\n            const specifier = value[0];\n            const type = DATE_FIELD_MAP[specifier];\n            const part = {\n                type: type,\n                pattern: value\n            };\n\n            if (type === 'hour') {\n                part.hour12 = isHour12(value);\n            }\n\n            const names = NAME_TYPES[type];\n\n            if (names) {\n                const minLength = isNumber(names.minLength) ? names.minLength : names.minLength[specifier];\n                const patternLength = value.length;\n\n                if (patternLength >= minLength) {\n                    part.names = {\n                        type: names.type,\n                        nameType: dateNameType(patternLength),\n                        standAlone: names.standAlone === specifier\n                    };\n                }\n            }\n\n            parts.push(part);\n        }\n\n        lastIndex = dateFormatRegExp.lastIndex;\n        match = dateFormatRegExp.exec(pattern);\n    }\n\n    if (lastIndex < pattern.length) {\n        addLiteral(parts, pattern.substring(lastIndex));\n    }\n\n    return parts;\n}\n"]},"metadata":{},"sourceType":"module"}