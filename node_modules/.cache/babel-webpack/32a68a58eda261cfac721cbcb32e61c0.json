{"ast":null,"code":"import _toConsumableArray from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\nimport { sort } from './sorting/sort';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts-no-run\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\n\nexport var orderBy = function orderBy(data, descriptors) {\n  if (descriptors.some(function (x) {\n    return isPresent(x.dir);\n  })) {\n    data = data.slice(0);\n    var comparer = composeSortDescriptors(descriptors);\n    sort(data, 0, data.length, comparer);\n  }\n\n  return data;\n};\n\nvar defaultComparer = function defaultComparer(a, b) {\n  return a === b;\n};\n\nvar normalizeComparer = function normalizeComparer(comparer) {\n  if (isString(comparer)) {\n    var accessor = getter(comparer);\n\n    comparer = function comparer(a, b) {\n      return accessor(a) === accessor(b);\n    };\n  }\n\n  return comparer;\n};\n\nvar _distinct = function _distinct(data, comparer) {\n  return data.filter(function (x, idx, xs) {\n    return xs.findIndex(comparer.bind(null, x)) === idx;\n  });\n};\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts-no-run\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\n\n\nexport var distinct = function distinct(data) {\n  var comparer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultComparer;\n  return _distinct(data, normalizeComparer(comparer));\n};\n/**\n * @hidden\n */\n\nexport var count = function count(data, predicate) {\n  var counter = 0;\n\n  for (var idx = 0, length = data.length; idx < length; idx++) {\n    if (predicate(data[idx])) {\n      counter++;\n    }\n  }\n\n  return counter;\n};\n/**\n * @hidden\n */\n\nexport var limit = function limit(data, predicate) {\n  if (predicate) {\n    return data.filter(predicate);\n  }\n\n  return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts-no-run\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\n\nexport var process = function process(data, state) {\n  var skipCount = state.skip,\n      takeCount = state.take,\n      filterDescriptor = state.filter,\n      sort = state.sort,\n      group = state.group;\n  var sortDescriptors = [].concat(_toConsumableArray(normalizeGroups(group || [])), _toConsumableArray(sort || []));\n\n  if (sortDescriptors.length) {\n    data = orderBy(data, sortDescriptors);\n  }\n\n  var hasFilters = isPresent(filterDescriptor) && filter.length;\n  var hasGroups = isPresent(group) && group.length;\n\n  if (!hasFilters && !hasGroups) {\n    return {\n      data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n      total: data.length\n    };\n  }\n\n  var total;\n  var transformers = [];\n  var predicate;\n\n  if (hasFilters) {\n    predicate = compileFilter(normalizeFilters(filterDescriptor));\n    total = count(data, predicate);\n    transformers.push(filter(predicate));\n  } else {\n    total = data.length;\n  }\n\n  if (isPresent(skipCount) && isPresent(takeCount)) {\n    transformers.push(skip(skipCount));\n    transformers.push(take(takeCount));\n  }\n\n  if (transformers.length) {\n    var transform = compose.apply(void 0, transformers);\n    var result = hasGroups ? groupBy(data, group, transform, limit(data, predicate)) : exec(transform(concat), [], data);\n    return {\n      data: result,\n      total: total\n    };\n  }\n\n  return {\n    data: hasGroups ? groupBy(data, group) : data,\n    total: total\n  };\n};","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@progress/kendo-data-query/dist/es2015/array.operators.js"],"names":["isPresent","isString","composeSortDescriptors","groupBy","normalizeGroups","normalizeFilters","compileFilter","exec","skip","take","filter","concat","getter","compose","sort","orderBy","data","descriptors","some","x","dir","slice","comparer","length","defaultComparer","a","b","normalizeComparer","accessor","_distinct","idx","xs","findIndex","bind","distinct","count","predicate","counter","limit","process","state","skipCount","takeCount","filterDescriptor","group","sortDescriptors","hasFilters","hasGroups","total","transformers","push","transform","result"],"mappings":"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","sourcesContent":["import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\nimport { sort } from './sorting/sort';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts-no-run\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\nexport const orderBy = (data, descriptors) => {\n    if (descriptors.some(x => isPresent(x.dir))) {\n        data = data.slice(0);\n        const comparer = composeSortDescriptors(descriptors);\n        sort(data, 0, data.length, comparer);\n    }\n    return data;\n};\nconst defaultComparer = (a, b) => a === b;\nconst normalizeComparer = (comparer) => {\n    if (isString(comparer)) {\n        const accessor = getter(comparer);\n        comparer = (a, b) => accessor(a) === accessor(b);\n    }\n    return comparer;\n};\nconst _distinct = (data, comparer) => data.filter((x, idx, xs) => xs.findIndex(comparer.bind(null, x)) === idx);\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts-no-run\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\nexport const distinct = (data, comparer = defaultComparer) => _distinct(data, normalizeComparer(comparer));\n/**\n * @hidden\n */\nexport const count = (data, predicate) => {\n    let counter = 0;\n    for (let idx = 0, length = data.length; idx < length; idx++) {\n        if (predicate(data[idx])) {\n            counter++;\n        }\n    }\n    return counter;\n};\n/**\n * @hidden\n */\nexport const limit = (data, predicate) => {\n    if (predicate) {\n        return data.filter(predicate);\n    }\n    return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts-no-run\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\nexport const process = (data, state) => {\n    const { skip: skipCount, take: takeCount, filter: filterDescriptor, sort, group } = state;\n    const sortDescriptors = [...normalizeGroups(group || []), ...sort || []];\n    if (sortDescriptors.length) {\n        data = orderBy(data, sortDescriptors);\n    }\n    const hasFilters = isPresent(filterDescriptor) && filter.length;\n    const hasGroups = isPresent(group) && group.length;\n    if (!hasFilters && !hasGroups) {\n        return {\n            data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n            total: data.length\n        };\n    }\n    let total;\n    const transformers = [];\n    let predicate;\n    if (hasFilters) {\n        predicate = compileFilter(normalizeFilters(filterDescriptor));\n        total = count(data, predicate);\n        transformers.push(filter(predicate));\n    }\n    else {\n        total = data.length;\n    }\n    if (isPresent(skipCount) && isPresent(takeCount)) {\n        transformers.push(skip(skipCount));\n        transformers.push(take(takeCount));\n    }\n    if (transformers.length) {\n        const transform = compose(...transformers);\n        const result = hasGroups ?\n            groupBy(data, group, transform, limit(data, predicate)) :\n            exec(transform(concat), [], data);\n        return { data: result, total: total };\n    }\n    return {\n        data: hasGroups ? groupBy(data, group) : data,\n        total: total\n    };\n};\n"]},"metadata":{},"sourceType":"module"}