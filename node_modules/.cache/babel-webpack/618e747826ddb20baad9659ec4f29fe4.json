{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport withAccessors from '../mixins/with-accessors';\nimport Point from './point';\nimport Rect from './rect';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport HasObservers from '../core/has-observers';\nimport { rad } from '../util';\nvar PI_DIV_2 = Math.PI / 2;\n\nvar Circle = /*#__PURE__*/function (_withAccessors) {\n  _inherits(Circle, _withAccessors);\n\n  var _super = _createSuper(Circle);\n\n  function Circle() {\n    var _this;\n\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Point();\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, Circle);\n\n    _this = _super.call(this);\n\n    _this.setCenter(center);\n\n    _this.setRadius(radius);\n\n    return _this;\n  }\n\n  _createClass(Circle, [{\n    key: \"setCenter\",\n    value: function setCenter(value) {\n      this._observerField(\"center\", Point.create(value));\n\n      this.geometryChange();\n      return this;\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other && other.center.equals(this.center) && other.radius === this.radius;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Circle(this.center.clone(), this.radius);\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(angle) {\n      return this._pointAt(rad(angle));\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox(matrix) {\n      var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n      var minPoint = Point.maxPoint();\n      var maxPoint = Point.minPoint();\n\n      for (var i = 0; i < 4; i++) {\n        var currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n\n        var currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n\n        var currentPoint = new Point(currentPointX.x, currentPointY.y);\n        minPoint = Point.min(minPoint, currentPoint);\n        maxPoint = Point.max(maxPoint, currentPoint);\n      }\n\n      return Rect.fromPoints(minPoint, maxPoint);\n    }\n  }, {\n    key: \"_pointAt\",\n    value: function _pointAt(angle) {\n      var center = this.center,\n          radius = this.radius;\n      return new Point(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var center = this.center,\n          radius = this.radius;\n      var inCircle = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n      return inCircle;\n    }\n  }, {\n    key: \"_isOnPath\",\n    value: function _isOnPath(point, width) {\n      var center = this.center,\n          radius = this.radius;\n      var pointDistance = center.distanceTo(point);\n      return radius - width <= pointDistance && pointDistance <= radius + width;\n    }\n  }]);\n\n  return Circle;\n}(withAccessors(HasObservers, [\"radius\"]));\n\nexport default Circle;","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/geometry/circle.js"],"names":["withAccessors","Point","Rect","ellipseExtremeAngles","HasObservers","rad","PI_DIV_2","Math","PI","Circle","center","radius","setCenter","setRadius","value","_observerField","create","geometryChange","other","equals","clone","angle","_pointAt","matrix","extremeAngles","minPoint","maxPoint","i","currentPointX","x","transformCopy","currentPointY","y","currentPoint","min","max","fromPoints","cos","sin","point","inCircle","pow","width","pointDistance","distanceTo"],"mappings":"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","sourcesContent":["import withAccessors from '../mixins/with-accessors';\nimport Point from './point';\nimport Rect from './rect';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport HasObservers from '../core/has-observers';\nimport { rad } from '../util';\n\n\nconst PI_DIV_2 = Math.PI / 2;\n\nclass Circle extends withAccessors(HasObservers, [ \"radius\" ]) {\n    constructor(center = new Point(), radius = 0) {\n        super();\n\n        this.setCenter(center);\n        this.setRadius(radius);\n    }\n\n    setCenter(value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getCenter() {\n        return this.center;\n    }\n\n    equals(other) {\n        return other &&\n               other.center.equals(this.center) &&\n               other.radius === this.radius;\n    }\n\n    clone() {\n        return new Circle(this.center.clone(), this.radius);\n    }\n\n    pointAt(angle) {\n        return this._pointAt(rad(angle));\n    }\n\n    bbox(matrix) {\n        const extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n        let minPoint = Point.maxPoint();\n        let maxPoint = Point.minPoint();\n\n        for (let i = 0; i < 4; i++) {\n            let currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n            let currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n            let currentPoint = new Point(currentPointX.x, currentPointY.y);\n\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    }\n\n    _pointAt(angle) {\n        const { center, radius } = this;\n\n        return new Point(\n            center.x + radius * Math.cos(angle),\n            center.y + radius * Math.sin(angle)\n        );\n    }\n\n    containsPoint(point) {\n        const { center, radius } = this;\n        const inCircle = Math.pow(point.x - center.x, 2) +\n            Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n        return inCircle;\n    }\n\n    _isOnPath(point, width) {\n        const { center, radius } = this;\n        const pointDistance = center.distanceTo(point);\n\n        return radius - width <= pointDistance && pointDistance <= radius + width;\n    }\n}\n\nexport default Circle;\n"]},"metadata":{},"sourceType":"module"}