{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport Node from './node';\nimport { defined, isTransparent } from '../util';\nimport { DASH_ARRAYS, SOLID, BUTT } from '../core/constants';\nimport { NONE } from './constants';\nimport renderAllAttr from './utils/render-all-attributes';\nimport renderAttr from './utils/render-attribute';\nimport NODE_MAP from './node-map';\nvar ATTRIBUTE_MAP = {\n  \"fill.opacity\": \"fill-opacity\",\n  \"stroke.color\": \"stroke\",\n  \"stroke.width\": \"stroke-width\",\n  \"stroke.opacity\": \"stroke-opacity\"\n};\nvar SPACE = \" \";\n\nvar PathNode = /*#__PURE__*/function (_Node) {\n  _inherits(PathNode, _Node);\n\n  var _super = _createSuper(PathNode);\n\n  function PathNode() {\n    _classCallCheck(this, PathNode);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PathNode, [{\n    key: \"geometryChange\",\n    value: function geometryChange() {\n      this.attr(\"d\", this.renderData());\n      this.invalidate();\n    }\n  }, {\n    key: \"optionsChange\",\n    value: function optionsChange(e) {\n      switch (e.field) {\n        case \"fill\":\n          if (e.value) {\n            this.allAttr(this.mapFill(e.value));\n          } else {\n            this.removeAttr(\"fill\");\n          }\n\n          break;\n\n        case \"fill.color\":\n          this.allAttr(this.mapFill({\n            color: e.value\n          }));\n          break;\n\n        case \"stroke\":\n          if (e.value) {\n            this.allAttr(this.mapStroke(e.value));\n          } else {\n            this.removeAttr(\"stroke\");\n          }\n\n          break;\n\n        case \"transform\":\n          this.transformChange(e.value);\n          break;\n\n        default:\n          var name = ATTRIBUTE_MAP[e.field];\n\n          if (name) {\n            this.attr(name, e.value);\n          }\n\n          break;\n      }\n\n      _get(_getPrototypeOf(PathNode.prototype), \"optionsChange\", this).call(this, e);\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      if (this.element) {\n        this.element.textContent = this.srcElement.content();\n      }\n    }\n  }, {\n    key: \"renderData\",\n    value: function renderData() {\n      return this.printPath(this.srcElement);\n    }\n  }, {\n    key: \"printPath\",\n    value: function printPath(path) {\n      var segments = path.segments;\n      var length = segments.length;\n\n      if (length > 0) {\n        var parts = [];\n        var output, currentType;\n\n        for (var i = 1; i < length; i++) {\n          var segmentType = this.segmentType(segments[i - 1], segments[i]);\n\n          if (segmentType !== currentType) {\n            currentType = segmentType;\n            parts.push(segmentType);\n          }\n\n          if (segmentType === \"L\") {\n            parts.push(this.printPoints(segments[i].anchor()));\n          } else {\n            parts.push(this.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n          }\n        }\n\n        output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n\n        if (path.options.closed) {\n          output += \"Z\";\n        }\n\n        return output;\n      }\n    }\n  }, {\n    key: \"printPoints\",\n    value: function printPoints() {\n      var points = arguments;\n      var length = points.length;\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(points[i].toString(3));\n      }\n\n      return result.join(\" \");\n    }\n  }, {\n    key: \"segmentType\",\n    value: function segmentType(segmentStart, segmentEnd) {\n      return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\n    }\n  }, {\n    key: \"mapStroke\",\n    value: function mapStroke(stroke) {\n      var attrs = [];\n\n      if (stroke && !isTransparent(stroke.color)) {\n        attrs.push([\"stroke\", stroke.color]);\n        attrs.push([\"stroke-width\", stroke.width]);\n        attrs.push([\"stroke-linecap\", this.renderLinecap(stroke)]);\n        attrs.push([\"stroke-linejoin\", stroke.lineJoin]);\n\n        if (defined(stroke.opacity)) {\n          attrs.push([\"stroke-opacity\", stroke.opacity]);\n        }\n\n        if (defined(stroke.dashType)) {\n          attrs.push([\"stroke-dasharray\", this.renderDashType(stroke)]);\n        }\n      } else {\n        attrs.push([\"stroke\", NONE]);\n      }\n\n      return attrs;\n    }\n  }, {\n    key: \"renderStroke\",\n    value: function renderStroke() {\n      return renderAllAttr(this.mapStroke(this.srcElement.options.stroke));\n    }\n  }, {\n    key: \"renderDashType\",\n    value: function renderDashType(stroke) {\n      var dashType = stroke.dashType,\n          _stroke$width = stroke.width,\n          width = _stroke$width === void 0 ? 1 : _stroke$width;\n\n      if (dashType && dashType !== SOLID) {\n        var dashArray = DASH_ARRAYS[dashType.toLowerCase()];\n        var result = [];\n\n        for (var i = 0; i < dashArray.length; i++) {\n          result.push(dashArray[i] * width);\n        }\n\n        return result.join(\" \");\n      }\n    }\n  }, {\n    key: \"renderLinecap\",\n    value: function renderLinecap(stroke) {\n      var dashType = stroke.dashType,\n          lineCap = stroke.lineCap;\n      return dashType && dashType !== \"solid\" ? BUTT : lineCap;\n    }\n  }, {\n    key: \"mapFill\",\n    value: function mapFill(fill) {\n      var attrs = [];\n\n      if (!(fill && fill.nodeType === \"Gradient\")) {\n        if (fill && !isTransparent(fill.color)) {\n          attrs.push([\"fill\", fill.color]);\n\n          if (defined(fill.opacity)) {\n            attrs.push([\"fill-opacity\", fill.opacity]);\n          }\n        } else {\n          attrs.push([\"fill\", NONE]);\n        }\n      }\n\n      return attrs;\n    }\n  }, {\n    key: \"renderFill\",\n    value: function renderFill() {\n      return renderAllAttr(this.mapFill(this.srcElement.options.fill));\n    }\n  }, {\n    key: \"template\",\n    value: function template() {\n      return \"<path \".concat(this.renderId(), \" \").concat(this.renderStyle(), \" \").concat(this.renderOpacity(), \" \").concat(renderAttr('d', this.renderData())) + \"\".concat(this.renderStroke()).concat(this.renderFill()).concat(this.renderDefinitions()).concat(this.renderTransform(), \"></path>\");\n    }\n  }]);\n\n  return PathNode;\n}(Node);\n\nNODE_MAP.Path = PathNode;\nexport default PathNode;","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/svg/path-node.js"],"names":["Node","defined","isTransparent","DASH_ARRAYS","SOLID","BUTT","NONE","renderAllAttr","renderAttr","NODE_MAP","ATTRIBUTE_MAP","SPACE","PathNode","attr","renderData","invalidate","e","field","value","allAttr","mapFill","removeAttr","color","mapStroke","transformChange","name","element","textContent","srcElement","content","printPath","path","segments","length","parts","output","currentType","i","segmentType","push","printPoints","anchor","controlOut","controlIn","join","options","closed","points","arguments","result","toString","segmentStart","segmentEnd","stroke","attrs","width","renderLinecap","lineJoin","opacity","dashType","renderDashType","dashArray","toLowerCase","lineCap","fill","nodeType","renderId","renderStyle","renderOpacity","renderStroke","renderFill","renderDefinitions","renderTransform","Path"],"mappings":";;;;;;AAAA,OAAOA,IAAP,MAAiB,QAAjB;AACA,SAASC,OAAT,EAAkBC,aAAlB,QAAuC,SAAvC;AACA,SAASC,WAAT,EAAsBC,KAAtB,EAA6BC,IAA7B,QAAyC,mBAAzC;AACA,SAASC,IAAT,QAAqB,aAArB;AACA,OAAOC,aAAP,MAA0B,+BAA1B;AACA,OAAOC,UAAP,MAAuB,0BAAvB;AACA,OAAOC,QAAP,MAAqB,YAArB;AAEA,IAAMC,aAAa,GAAG;AAClB,kBAAgB,cADE;AAElB,kBAAgB,QAFE;AAGlB,kBAAgB,cAHE;AAIlB,oBAAkB;AAJA,CAAtB;AAMA,IAAMC,KAAK,GAAG,GAAd;;IAEMC,Q;;;;;;;;;;;;;qCAEe;AACb,WAAKC,IAAL,CAAU,GAAV,EAAe,KAAKC,UAAL,EAAf;AACA,WAAKC,UAAL;AACH;;;kCAEaC,C,EAAG;AACb,cAAQA,CAAC,CAACC,KAAV;AACI,aAAK,MAAL;AACI,cAAID,CAAC,CAACE,KAAN,EAAa;AACT,iBAAKC,OAAL,CAAa,KAAKC,OAAL,CAAaJ,CAAC,CAACE,KAAf,CAAb;AACH,WAFD,MAEO;AACH,iBAAKG,UAAL,CAAgB,MAAhB;AACH;;AACD;;AAEJ,aAAK,YAAL;AACI,eAAKF,OAAL,CAAa,KAAKC,OAAL,CAAa;AAAEE,YAAAA,KAAK,EAAEN,CAAC,CAACE;AAAX,WAAb,CAAb;AACA;;AAEJ,aAAK,QAAL;AACI,cAAIF,CAAC,CAACE,KAAN,EAAa;AACT,iBAAKC,OAAL,CAAa,KAAKI,SAAL,CAAeP,CAAC,CAACE,KAAjB,CAAb;AACH,WAFD,MAEO;AACH,iBAAKG,UAAL,CAAgB,QAAhB;AACH;;AACD;;AAEJ,aAAK,WAAL;AACI,eAAKG,eAAL,CAAqBR,CAAC,CAACE,KAAvB;AACA;;AAEJ;AACI,cAAMO,IAAI,GAAGf,aAAa,CAACM,CAAC,CAACC,KAAH,CAA1B;;AACA,cAAIQ,IAAJ,EAAU;AACN,iBAAKZ,IAAL,CAAUY,IAAV,EAAgBT,CAAC,CAACE,KAAlB;AACH;;AACD;AA9BR;;AAiCA,kFAAoBF,CAApB;AACH;;;8BAES;AACN,UAAI,KAAKU,OAAT,EAAkB;AACd,aAAKA,OAAL,CAAaC,WAAb,GAA2B,KAAKC,UAAL,CAAgBC,OAAhB,EAA3B;AACH;AACJ;;;iCAEY;AACT,aAAO,KAAKC,SAAL,CAAe,KAAKF,UAApB,CAAP;AACH;;;8BAESG,I,EAAM;AACZ,UAAMC,QAAQ,GAAGD,IAAI,CAACC,QAAtB;AACA,UAAMC,MAAM,GAAGD,QAAQ,CAACC,MAAxB;;AACA,UAAIA,MAAM,GAAG,CAAb,EAAgB;AACZ,YAAMC,KAAK,GAAG,EAAd;AACA,YAAIC,MAAJ,EAAYC,WAAZ;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4BI,CAAC,EAA7B,EAAiC;AAC7B,cAAIC,WAAW,GAAG,KAAKA,WAAL,CAAiBN,QAAQ,CAACK,CAAC,GAAG,CAAL,CAAzB,EAAkCL,QAAQ,CAACK,CAAD,CAA1C,CAAlB;;AACA,cAAIC,WAAW,KAAKF,WAApB,EAAiC;AAC7BA,YAAAA,WAAW,GAAGE,WAAd;AACAJ,YAAAA,KAAK,CAACK,IAAN,CAAWD,WAAX;AACH;;AAED,cAAIA,WAAW,KAAK,GAApB,EAAyB;AACrBJ,YAAAA,KAAK,CAACK,IAAN,CAAW,KAAKC,WAAL,CAAiBR,QAAQ,CAACK,CAAD,CAAR,CAAYI,MAAZ,EAAjB,CAAX;AACH,WAFD,MAEO;AACHP,YAAAA,KAAK,CAACK,IAAN,CAAW,KAAKC,WAAL,CAAiBR,QAAQ,CAACK,CAAC,GAAG,CAAL,CAAR,CAAgBK,UAAhB,EAAjB,EAA+CV,QAAQ,CAACK,CAAD,CAAR,CAAYM,SAAZ,EAA/C,EAAwEX,QAAQ,CAACK,CAAD,CAAR,CAAYI,MAAZ,EAAxE,CAAX;AACH;AACJ;;AAEDN,QAAAA,MAAM,GAAG,MAAM,KAAKK,WAAL,CAAiBR,QAAQ,CAAC,CAAD,CAAR,CAAYS,MAAZ,EAAjB,CAAN,GAA+C9B,KAA/C,GAAuDuB,KAAK,CAACU,IAAN,CAAWjC,KAAX,CAAhE;;AACA,YAAIoB,IAAI,CAACc,OAAL,CAAaC,MAAjB,EAAyB;AACrBX,UAAAA,MAAM,IAAI,GAAV;AACH;;AAED,eAAOA,MAAP;AACH;AACJ;;;kCAEa;AACV,UAAMY,MAAM,GAAGC,SAAf;AACA,UAAMf,MAAM,GAAGc,MAAM,CAACd,MAAtB;AACA,UAAMgB,MAAM,GAAG,EAAf;;AAEA,WAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4BI,CAAC,EAA7B,EAAiC;AAC7BY,QAAAA,MAAM,CAACV,IAAP,CAAYQ,MAAM,CAACV,CAAD,CAAN,CAAUa,QAAV,CAAmB,CAAnB,CAAZ;AACH;;AAED,aAAOD,MAAM,CAACL,IAAP,CAAY,GAAZ,CAAP;AACH;;;gCAEWO,Y,EAAcC,U,EAAY;AAClC,aAAOD,YAAY,CAACT,UAAb,MAA6BU,UAAU,CAACT,SAAX,EAA7B,GAAsD,GAAtD,GAA4D,GAAnE;AACH;;;8BAESU,M,EAAQ;AACd,UAAMC,KAAK,GAAG,EAAd;;AAEA,UAAID,MAAM,IAAI,CAACnD,aAAa,CAACmD,MAAM,CAAC/B,KAAR,CAA5B,EAA4C;AACxCgC,QAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,QAAF,EAAYc,MAAM,CAAC/B,KAAnB,CAAX;AACAgC,QAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,cAAF,EAAkBc,MAAM,CAACE,KAAzB,CAAX;AACAD,QAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,gBAAF,EAAoB,KAAKiB,aAAL,CAAmBH,MAAnB,CAApB,CAAX;AACAC,QAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,iBAAF,EAAqBc,MAAM,CAACI,QAA5B,CAAX;;AAEA,YAAIxD,OAAO,CAACoD,MAAM,CAACK,OAAR,CAAX,EAA6B;AACzBJ,UAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,gBAAF,EAAoBc,MAAM,CAACK,OAA3B,CAAX;AACH;;AAED,YAAIzD,OAAO,CAACoD,MAAM,CAACM,QAAR,CAAX,EAA8B;AAC1BL,UAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,kBAAF,EAAsB,KAAKqB,cAAL,CAAoBP,MAApB,CAAtB,CAAX;AACH;AACJ,OAbD,MAaO;AACHC,QAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,QAAF,EAAYjC,IAAZ,CAAX;AACH;;AAED,aAAOgD,KAAP;AACH;;;mCAEc;AACX,aAAO/C,aAAa,CAChB,KAAKgB,SAAL,CAAe,KAAKK,UAAL,CAAgBiB,OAAhB,CAAwBQ,MAAvC,CADgB,CAApB;AAGH;;;mCAEcA,M,EAAQ;AAAA,UACXM,QADW,GACaN,MADb,CACXM,QADW;AAAA,0BACaN,MADb,CACDE,KADC;AAAA,UACDA,KADC,8BACO,CADP;;AAGnB,UAAII,QAAQ,IAAIA,QAAQ,KAAKvD,KAA7B,EAAoC;AAChC,YAAMyD,SAAS,GAAG1D,WAAW,CAACwD,QAAQ,CAACG,WAAT,EAAD,CAA7B;AACA,YAAMb,MAAM,GAAG,EAAf;;AAEA,aAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,SAAS,CAAC5B,MAA9B,EAAsCI,CAAC,EAAvC,EAA2C;AACvCY,UAAAA,MAAM,CAACV,IAAP,CAAYsB,SAAS,CAACxB,CAAD,CAAT,GAAekB,KAA3B;AACH;;AAED,eAAON,MAAM,CAACL,IAAP,CAAY,GAAZ,CAAP;AACH;AACJ;;;kCAEaS,M,EAAQ;AAAA,UACVM,QADU,GACYN,MADZ,CACVM,QADU;AAAA,UACAI,OADA,GACYV,MADZ,CACAU,OADA;AAGlB,aAAQJ,QAAQ,IAAIA,QAAQ,KAAK,OAA1B,GAAqCtD,IAArC,GAA4C0D,OAAnD;AACH;;;4BAEOC,I,EAAM;AACV,UAAMV,KAAK,GAAG,EAAd;;AACA,UAAI,EAAEU,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,UAA5B,CAAJ,EAA6C;AACzC,YAAID,IAAI,IAAI,CAAC9D,aAAa,CAAC8D,IAAI,CAAC1C,KAAN,CAA1B,EAAwC;AACpCgC,UAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,MAAF,EAAUyB,IAAI,CAAC1C,KAAf,CAAX;;AAEA,cAAIrB,OAAO,CAAC+D,IAAI,CAACN,OAAN,CAAX,EAA2B;AACvBJ,YAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,cAAF,EAAkByB,IAAI,CAACN,OAAvB,CAAX;AACH;AACJ,SAND,MAMO;AACHJ,UAAAA,KAAK,CAACf,IAAN,CAAW,CAAE,MAAF,EAAUjC,IAAV,CAAX;AACH;AACJ;;AAED,aAAOgD,KAAP;AACH;;;iCAEY;AACT,aAAO/C,aAAa,CAChB,KAAKa,OAAL,CAAa,KAAKQ,UAAL,CAAgBiB,OAAhB,CAAwBmB,IAArC,CADgB,CAApB;AAGH;;;+BAEU;AACP,aAAO,gBAAU,KAAKE,QAAL,EAAV,cAA+B,KAAKC,WAAL,EAA/B,cAAuD,KAAKC,aAAL,EAAvD,cAAiF5D,UAAU,CAAC,GAAD,EAAM,KAAKM,UAAL,EAAN,CAA3F,cACS,KAAKuD,YAAL,EADT,SACiC,KAAKC,UAAL,EADjC,SACuD,KAAKC,iBAAL,EADvD,SACoF,KAAKC,eAAL,EADpF,aAAP;AAEH;;;;EAhLkBxE,I;;AAmLvBS,QAAQ,CAACgE,IAAT,GAAgB7D,QAAhB;AAEA,eAAeA,QAAf","sourcesContent":["import Node from './node';\nimport { defined, isTransparent } from '../util';\nimport { DASH_ARRAYS, SOLID, BUTT } from '../core/constants';\nimport { NONE } from './constants';\nimport renderAllAttr from './utils/render-all-attributes';\nimport renderAttr from './utils/render-attribute';\nimport NODE_MAP from './node-map';\n\nconst ATTRIBUTE_MAP = {\n    \"fill.opacity\": \"fill-opacity\",\n    \"stroke.color\": \"stroke\",\n    \"stroke.width\": \"stroke-width\",\n    \"stroke.opacity\": \"stroke-opacity\"\n};\nconst SPACE = \" \";\n\nclass PathNode extends Node {\n\n    geometryChange() {\n        this.attr(\"d\", this.renderData());\n        this.invalidate();\n    }\n\n    optionsChange(e) {\n        switch (e.field) {\n            case \"fill\":\n                if (e.value) {\n                    this.allAttr(this.mapFill(e.value));\n                } else {\n                    this.removeAttr(\"fill\");\n                }\n                break;\n\n            case \"fill.color\":\n                this.allAttr(this.mapFill({ color: e.value }));\n                break;\n\n            case \"stroke\":\n                if (e.value) {\n                    this.allAttr(this.mapStroke(e.value));\n                } else {\n                    this.removeAttr(\"stroke\");\n                }\n                break;\n\n            case \"transform\":\n                this.transformChange(e.value);\n                break;\n\n            default:\n                const name = ATTRIBUTE_MAP[e.field];\n                if (name) {\n                    this.attr(name, e.value);\n                }\n                break;\n        }\n\n        super.optionsChange(e);\n    }\n\n    content() {\n        if (this.element) {\n            this.element.textContent = this.srcElement.content();\n        }\n    }\n\n    renderData() {\n        return this.printPath(this.srcElement);\n    }\n\n    printPath(path) {\n        const segments = path.segments;\n        const length = segments.length;\n        if (length > 0) {\n            const parts = [];\n            let output, currentType;\n\n            for (let i = 1; i < length; i++) {\n                let segmentType = this.segmentType(segments[i - 1], segments[i]);\n                if (segmentType !== currentType) {\n                    currentType = segmentType;\n                    parts.push(segmentType);\n                }\n\n                if (segmentType === \"L\") {\n                    parts.push(this.printPoints(segments[i].anchor()));\n                } else {\n                    parts.push(this.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n                }\n            }\n\n            output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n            if (path.options.closed) {\n                output += \"Z\";\n            }\n\n            return output;\n        }\n    }\n\n    printPoints() {\n        const points = arguments;\n        const length = points.length;\n        const result = [];\n\n        for (let i = 0; i < length; i++) {\n            result.push(points[i].toString(3));\n        }\n\n        return result.join(\" \");\n    }\n\n    segmentType(segmentStart, segmentEnd) {\n        return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\n    }\n\n    mapStroke(stroke) {\n        const attrs = [];\n\n        if (stroke && !isTransparent(stroke.color)) {\n            attrs.push([ \"stroke\", stroke.color ]);\n            attrs.push([ \"stroke-width\", stroke.width ]);\n            attrs.push([ \"stroke-linecap\", this.renderLinecap(stroke) ]);\n            attrs.push([ \"stroke-linejoin\", stroke.lineJoin ]);\n\n            if (defined(stroke.opacity)) {\n                attrs.push([ \"stroke-opacity\", stroke.opacity ]);\n            }\n\n            if (defined(stroke.dashType)) {\n                attrs.push([ \"stroke-dasharray\", this.renderDashType(stroke) ]);\n            }\n        } else {\n            attrs.push([ \"stroke\", NONE ]);\n        }\n\n        return attrs;\n    }\n\n    renderStroke() {\n        return renderAllAttr(\n            this.mapStroke(this.srcElement.options.stroke)\n        );\n    }\n\n    renderDashType(stroke) {\n        const { dashType, width = 1 } = stroke;\n\n        if (dashType && dashType !== SOLID) {\n            const dashArray = DASH_ARRAYS[dashType.toLowerCase()];\n            const result = [];\n\n            for (let i = 0; i < dashArray.length; i++) {\n                result.push(dashArray[i] * width);\n            }\n\n            return result.join(\" \");\n        }\n    }\n\n    renderLinecap(stroke) {\n        const { dashType, lineCap } = stroke;\n\n        return (dashType && dashType !== \"solid\") ? BUTT : lineCap;\n    }\n\n    mapFill(fill) {\n        const attrs = [];\n        if (!(fill && fill.nodeType === \"Gradient\")) {\n            if (fill && !isTransparent(fill.color)) {\n                attrs.push([ \"fill\", fill.color ]);\n\n                if (defined(fill.opacity)) {\n                    attrs.push([ \"fill-opacity\", fill.opacity ]);\n                }\n            } else {\n                attrs.push([ \"fill\", NONE ]);\n            }\n        }\n\n        return attrs;\n    }\n\n    renderFill() {\n        return renderAllAttr(\n            this.mapFill(this.srcElement.options.fill)\n        );\n    }\n\n    template() {\n        return `<path ${ this.renderId() } ${ this.renderStyle() } ${ this.renderOpacity() } ${ renderAttr('d', this.renderData()) }` +\n                    `${ this.renderStroke() }${ this.renderFill() }${ this.renderDefinitions() }${ this.renderTransform() }></path>`;\n    }\n}\n\nNODE_MAP.Path = PathNode;\n\nexport default PathNode;"]},"metadata":{},"sourceType":"module"}