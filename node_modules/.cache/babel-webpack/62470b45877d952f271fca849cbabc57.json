{"ast":null,"code":"import { cldr, getLocaleInfo } from './info';\nimport { errors } from '../errors';\nimport localeTerritory from './territory';\nimport parseRangeDate from './parse-range-date';\n/* eslint-disable consistent-return */\n\nvar NoCurrency = errors.NoCurrency,\n    NoCurrencyDisplay = errors.NoCurrencyDisplay,\n    NoSupplementalCurrency = errors.NoSupplementalCurrency,\n    NoCurrencyRegion = errors.NoCurrencyRegion,\n    NoValidCurrency = errors.NoValidCurrency;\nvar DEFAULT_CURRENCY_FRACTIONS = 2;\nvar SYMBOL = \"symbol\";\nvar INVALID_CURRENCY_CODE = 'XXX';\nvar GLOBAL_CURRENCIES = {\n  '001': 'USD',\n  // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error\n  '150': 'EUR' // 150 territory for Europe\n\n};\n\nfunction getCurrencyInfo(locale, currency, throwIfNoValid) {\n  var info = getLocaleInfo(locale);\n  var currencies = info.numbers.currencies;\n\n  if (!currencies) {\n    if (throwIfNoValid) {\n      throw NoCurrency.error();\n    }\n\n    return;\n  }\n\n  var currencyDisplayInfo = currencies[currency];\n\n  if (!currencyDisplayInfo) {\n    if (throwIfNoValid) {\n      throw NoCurrencyDisplay.error();\n    }\n\n    return;\n  }\n\n  return currencyDisplayInfo;\n}\n\nfunction lengthComparer(a, b) {\n  return b.length - a.length;\n}\n\nfunction regionCurrency(regionCurrencies) {\n  var latestValidUntil, latestValidUntilRange;\n  var latestStillValid, latestStillValidDate;\n\n  for (var idx = 0; idx < regionCurrencies.length; idx++) {\n    var currency = regionCurrencies[idx];\n    var code = Object.keys(currency)[0];\n    var info = currency[code];\n\n    if (code !== INVALID_CURRENCY_CODE && info._tender !== 'false' && info._from) {\n      if (!info._to) {\n        var stillValidDate = parseRangeDate(info._from);\n\n        if (!latestStillValidDate || latestStillValidDate < stillValidDate) {\n          latestStillValid = code;\n          latestStillValidDate = stillValidDate;\n        }\n      } else if (!latestStillValid) {\n        var validFrom = parseRangeDate(info._from);\n        var validTo = parseRangeDate(info._to);\n\n        if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {\n          latestValidUntil = code;\n          latestValidUntilRange = {\n            from: validFrom,\n            to: validTo\n          };\n        }\n      }\n    }\n  }\n\n  return latestStillValid || latestValidUntil;\n}\n\nexport function currencyDisplays(locale, currency) {\n  var throwIfNoValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);\n\n  if (!currencyInfo) {\n    return;\n  }\n\n  if (!currencyInfo.displays) {\n    var displays = [currency];\n\n    for (var field in currencyInfo) {\n      displays.push(currencyInfo[field]);\n    }\n\n    displays.sort(lengthComparer);\n    currencyInfo.displays = displays;\n  }\n\n  return currencyInfo.displays;\n}\nexport function currencyDisplay(locale, options) {\n  var value = options.value,\n      currency = options.currency,\n      _options$currencyDisp = options.currencyDisplay,\n      currencyDisplay = _options$currencyDisp === void 0 ? SYMBOL : _options$currencyDisp;\n\n  if (currencyDisplay === \"code\") {\n    return currency;\n  }\n\n  var currencyInfo = getCurrencyInfo(locale, currency, true);\n  var result;\n\n  if (currencyDisplay === SYMBOL) {\n    result = currencyInfo[\"symbol-alt-narrow\"] || currencyInfo[SYMBOL];\n  } else {\n    if (typeof value === undefined || value !== 1) {\n      result = currencyInfo[\"displayName-count-other\"];\n    } else {\n      result = currencyInfo[\"displayName-count-one\"];\n    }\n  }\n\n  return result;\n}\nexport function currencyFractionOptions(code) {\n  var minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n  var maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n  var fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];\n\n  if (fractions && fractions._digits) {\n    maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);\n  }\n\n  return {\n    minimumFractionDigits: minimumFractionDigits,\n    maximumFractionDigits: maximumFractionDigits\n  };\n}\nexport function territoryCurrencyCode(territory) {\n  var throwIfNoValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (GLOBAL_CURRENCIES[territory]) {\n    return GLOBAL_CURRENCIES[territory];\n  }\n\n  var currencyData = cldr.supplemental.currencyData;\n\n  if (!currencyData) {\n    if (throwIfNoValid) {\n      throw NoSupplementalCurrency.error();\n    }\n\n    return;\n  }\n\n  var regionCurrencies = currencyData.region[territory];\n\n  if (!regionCurrencies) {\n    if (throwIfNoValid) {\n      throw NoCurrencyRegion.error(territory);\n    }\n\n    return;\n  }\n\n  var currencyCode = regionCurrency(regionCurrencies);\n  return currencyCode;\n}\nexport function localeCurrency(locale, throwIfNoValid) {\n  var info = getLocaleInfo(locale);\n  var numbers = info.numbers;\n\n  if (!numbers.localeCurrency) {\n    var currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);\n\n    if (!currency && throwIfNoValid) {\n      throw NoValidCurrency.error(info.name);\n    }\n\n    numbers.localeCurrency = currency;\n  }\n\n  return numbers.localeCurrency;\n}","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@telerik/kendo-intl/dist/es2015/cldr/currency.js"],"names":["cldr","getLocaleInfo","errors","localeTerritory","parseRangeDate","NoCurrency","NoCurrencyDisplay","NoSupplementalCurrency","NoCurrencyRegion","NoValidCurrency","DEFAULT_CURRENCY_FRACTIONS","SYMBOL","INVALID_CURRENCY_CODE","GLOBAL_CURRENCIES","getCurrencyInfo","locale","currency","throwIfNoValid","info","currencies","numbers","error","currencyDisplayInfo","lengthComparer","a","b","length","regionCurrency","regionCurrencies","latestValidUntil","latestValidUntilRange","latestStillValid","latestStillValidDate","idx","code","Object","keys","_tender","_from","_to","stillValidDate","validFrom","validTo","to","from","currencyDisplays","currencyInfo","displays","field","push","sort","currencyDisplay","options","value","result","undefined","currencyFractionOptions","minimumFractionDigits","maximumFractionDigits","fractions","supplemental","currencyData","_digits","parseInt","territoryCurrencyCode","territory","region","currencyCode","localeCurrency","name"],"mappings":"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","sourcesContent":["import { cldr, getLocaleInfo } from './info';\nimport { errors } from '../errors';\nimport localeTerritory from './territory';\nimport parseRangeDate from './parse-range-date';\n\n/* eslint-disable consistent-return */\n\nconst {\n    NoCurrency,\n    NoCurrencyDisplay,\n    NoSupplementalCurrency,\n    NoCurrencyRegion,\n    NoValidCurrency\n} = errors;\n\nconst DEFAULT_CURRENCY_FRACTIONS = 2;\nconst SYMBOL = \"symbol\";\nconst INVALID_CURRENCY_CODE = 'XXX';\n\nconst GLOBAL_CURRENCIES = {\n    '001': 'USD', // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error\n    '150': 'EUR' // 150 territory for Europe\n\n};\n\nfunction getCurrencyInfo(locale, currency, throwIfNoValid) {\n    const info = getLocaleInfo(locale);\n    const currencies = info.numbers.currencies;\n    if (!currencies) {\n        if (throwIfNoValid) {\n            throw NoCurrency.error();\n        }\n\n        return;\n    }\n\n    const currencyDisplayInfo = currencies[currency];\n\n    if (!currencyDisplayInfo) {\n        if (throwIfNoValid) {\n            throw NoCurrencyDisplay.error();\n        }\n\n        return;\n    }\n\n    return currencyDisplayInfo;\n}\n\nfunction lengthComparer(a, b) {\n    return b.length - a.length;\n}\n\nfunction regionCurrency(regionCurrencies) {\n    let latestValidUntil, latestValidUntilRange;\n    let latestStillValid, latestStillValidDate;\n\n    for (let idx = 0; idx < regionCurrencies.length; idx++) {\n        const currency = regionCurrencies[idx];\n        const code = Object.keys(currency)[0];\n        const info = currency[code];\n        if (code !== INVALID_CURRENCY_CODE && info._tender !== 'false' && info._from) {\n            if (!info._to) {\n                const stillValidDate = parseRangeDate(info._from);\n                if (!latestStillValidDate || latestStillValidDate < stillValidDate) {\n                    latestStillValid = code;\n                    latestStillValidDate = stillValidDate;\n                }\n            } else if (!latestStillValid) {\n                const validFrom = parseRangeDate(info._from);\n                const validTo = parseRangeDate(info._to);\n                if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {\n                    latestValidUntil = code;\n                    latestValidUntilRange = {\n                        from: validFrom,\n                        to: validTo\n                    };\n                }\n            }\n        }\n    }\n\n    return latestStillValid || latestValidUntil;\n}\n\nexport function currencyDisplays(locale, currency, throwIfNoValid = true) {\n    const currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);\n    if (!currencyInfo) {\n        return;\n    }\n\n    if (!currencyInfo.displays) {\n        const displays = [ currency ];\n        for (let field in currencyInfo) {\n            displays.push(currencyInfo[field]);\n        }\n        displays.sort(lengthComparer);\n        currencyInfo.displays = displays;\n    }\n\n    return currencyInfo.displays;\n}\n\nexport function currencyDisplay(locale, options) {\n    const { value, currency, currencyDisplay = SYMBOL } = options;\n\n    if (currencyDisplay === \"code\") {\n        return currency;\n    }\n\n    const currencyInfo = getCurrencyInfo(locale, currency, true);\n    let result;\n\n    if (currencyDisplay === SYMBOL) {\n        result = currencyInfo[\"symbol-alt-narrow\"] || currencyInfo[SYMBOL];\n    } else {\n        if (typeof value === undefined || value !== 1) {\n            result = currencyInfo[\"displayName-count-other\"];\n        } else {\n            result = currencyInfo[\"displayName-count-one\"];\n        }\n    }\n\n    return result;\n}\n\nexport function currencyFractionOptions(code) {\n    let minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n    let maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n\n    const fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];\n\n    if (fractions && fractions._digits) {\n        maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);\n    }\n\n    return {\n        minimumFractionDigits: minimumFractionDigits,\n        maximumFractionDigits: maximumFractionDigits\n    };\n}\n\nexport function territoryCurrencyCode(territory, throwIfNoValid = true) {\n    if (GLOBAL_CURRENCIES[territory]) {\n        return GLOBAL_CURRENCIES[territory];\n    }\n\n    const currencyData = cldr.supplemental.currencyData;\n    if (!currencyData) {\n        if (throwIfNoValid) {\n            throw NoSupplementalCurrency.error();\n        }\n\n        return;\n    }\n\n    const regionCurrencies = currencyData.region[territory];\n\n    if (!regionCurrencies) {\n        if (throwIfNoValid) {\n            throw NoCurrencyRegion.error(territory);\n        }\n\n        return;\n    }\n\n    const currencyCode = regionCurrency(regionCurrencies);\n\n    return currencyCode;\n}\n\nexport function localeCurrency(locale, throwIfNoValid) {\n    const info = getLocaleInfo(locale);\n    const numbers = info.numbers;\n\n    if (!numbers.localeCurrency) {\n        const currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);\n\n        if (!currency && throwIfNoValid) {\n            throw NoValidCurrency.error(info.name);\n        }\n\n        numbers.localeCurrency = currency;\n    }\n\n    return numbers.localeCurrency;\n}\n"]},"metadata":{},"sourceType":"module"}