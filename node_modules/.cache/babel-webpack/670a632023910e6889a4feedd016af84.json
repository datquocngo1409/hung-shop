{"ast":null,"code":"import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\n\nvar compare = function compare(a, b) {\n  if (isBlank(a)) {\n    return a === b ? 0 : -1;\n  }\n\n  if (isBlank(b)) {\n    return 1;\n  }\n\n  if (a.localeCompare) {\n    return a.localeCompare(b);\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n};\n\nvar compareDesc = function compareDesc(a, b) {\n  return compare(b, a);\n};\n\nvar descriptorAsFunc = function descriptorAsFunc(descriptor) {\n  var prop = getter(descriptor.field, true);\n  return function (a, b) {\n    return (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b));\n  };\n};\n\nvar initial = function initial(_a, _b) {\n  return 0;\n}; // tslint:disable:max-line-length\n\n/**\n * Converts the `SortDescriptors` into a [`Comparer`]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts-no-run\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\n\n\nexport var composeSortDescriptors = function composeSortDescriptors(descriptors) {\n  return descriptors.filter(function (x) {\n    return isPresent(x.dir);\n  }).map(function (descriptor) {\n    return descriptorAsFunc(descriptor);\n  }).reduce(function (acc, curr) {\n    return function (a, b) {\n      return acc(a, b) || curr(a, b);\n    };\n  }, initial);\n};","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-data-query/dist/es2015/sorting/sort-array.operator.js"],"names":["isPresent","isBlank","getter","compare","a","b","localeCompare","compareDesc","descriptorAsFunc","descriptor","prop","field","dir","initial","_a","_b","composeSortDescriptors","descriptors","filter","x","map","reduce","acc","curr"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,OAApB,QAAmC,UAAnC;AACA,SAASC,MAAT,QAAuB,aAAvB;;AACA,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAACC,CAAD,EAAIC,CAAJ,EAAU;AACtB,MAAIJ,OAAO,CAACG,CAAD,CAAX,EAAgB;AACZ,WAAOA,CAAC,KAAKC,CAAN,GAAU,CAAV,GAAc,CAAC,CAAtB;AACH;;AACD,MAAIJ,OAAO,CAACI,CAAD,CAAX,EAAgB;AACZ,WAAO,CAAP;AACH;;AACD,MAAID,CAAC,CAACE,aAAN,EAAqB;AACjB,WAAOF,CAAC,CAACE,aAAF,CAAgBD,CAAhB,CAAP;AACH;;AACD,SAAOD,CAAC,GAAGC,CAAJ,GAAQ,CAAR,GAAaD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAAjC;AACH,CAXD;;AAYA,IAAME,WAAW,GAAG,SAAdA,WAAc,CAACH,CAAD,EAAIC,CAAJ;AAAA,SAAUF,OAAO,CAACE,CAAD,EAAID,CAAJ,CAAjB;AAAA,CAApB;;AACA,IAAMI,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,UAAD,EAAgB;AACrC,MAAMC,IAAI,GAAGR,MAAM,CAACO,UAAU,CAACE,KAAZ,EAAmB,IAAnB,CAAnB;AACA,SAAO,UAACP,CAAD,EAAIC,CAAJ;AAAA,WAAU,CAACI,UAAU,CAACG,GAAX,KAAmB,KAAnB,GAA2BT,OAA3B,GAAqCI,WAAtC,EAAmDG,IAAI,CAACN,CAAD,CAAvD,EAA4DM,IAAI,CAACL,CAAD,CAAhE,CAAV;AAAA,GAAP;AACH,CAHD;;AAIA,IAAMQ,OAAO,GAAG,SAAVA,OAAU,CAACC,EAAD,EAAKC,EAAL;AAAA,SAAY,CAAZ;AAAA,CAAhB,C,CACA;;AACA;;;;;;;;;;;;;;;AAeA;;;AACA,OAAO,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,WAAD;AAAA,SAAkBA,WAAW,CAC9DC,MADmD,CAC5C,UAAAC,CAAC;AAAA,WAAInB,SAAS,CAACmB,CAAC,CAACP,GAAH,CAAb;AAAA,GAD2C,EAEnDQ,GAFmD,CAE/C,UAACX,UAAD;AAAA,WAAgBD,gBAAgB,CAACC,UAAD,CAAhC;AAAA,GAF+C,EAGnDY,MAHmD,CAG5C,UAACC,GAAD,EAAMC,IAAN;AAAA,WAAe,UAACnB,CAAD,EAAIC,CAAJ;AAAA,aAAUiB,GAAG,CAAClB,CAAD,EAAIC,CAAJ,CAAH,IAAakB,IAAI,CAACnB,CAAD,EAAIC,CAAJ,CAA3B;AAAA,KAAf;AAAA,GAH4C,EAGMQ,OAHN,CAAlB;AAAA,CAA/B","sourcesContent":["import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\nconst compare = (a, b) => {\n    if (isBlank(a)) {\n        return a === b ? 0 : -1;\n    }\n    if (isBlank(b)) {\n        return 1;\n    }\n    if (a.localeCompare) {\n        return a.localeCompare(b);\n    }\n    return a > b ? 1 : (a < b ? -1 : 0);\n};\nconst compareDesc = (a, b) => compare(b, a);\nconst descriptorAsFunc = (descriptor) => {\n    const prop = getter(descriptor.field, true);\n    return (a, b) => (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b));\n};\nconst initial = (_a, _b) => 0;\n// tslint:disable:max-line-length\n/**\n * Converts the `SortDescriptors` into a [`Comparer`]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts-no-run\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\nexport const composeSortDescriptors = (descriptors) => (descriptors\n    .filter(x => isPresent(x.dir))\n    .map((descriptor) => descriptorAsFunc(descriptor))\n    .reduce((acc, curr) => (a, b) => acc(a, b) || curr(a, b), initial));\n"]},"metadata":{},"sourceType":"module"}