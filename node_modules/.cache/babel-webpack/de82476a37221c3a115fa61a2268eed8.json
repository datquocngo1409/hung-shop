{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport Node from './node';\nimport { parseColor } from '../common';\nimport { isTransparent, valueOrDefault } from '../util';\nimport LinearGradient from '../gradients/linear-gradient';\nimport RadialGradient from '../gradients/radial-gradient';\nimport { DASH_ARRAYS, SOLID, BUTT } from '../core/constants';\nimport renderPath from './utils/render-path';\nimport NODE_MAP from './node-map';\n\nfunction addGradientStops(gradient, stops) {\n  for (var idx = 0; idx < stops.length; idx++) {\n    var stop = stops[idx];\n    var color = parseColor(stop.color());\n    color.a *= stop.opacity();\n    gradient.addColorStop(stop.offset(), color.toCssRgba());\n  }\n}\n\nvar PathNode = /*#__PURE__*/function (_Node) {\n  _inherits(PathNode, _Node);\n\n  var _super = _createSuper(PathNode);\n\n  function PathNode() {\n    _classCallCheck(this, PathNode);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PathNode, [{\n    key: \"renderTo\",\n    value: function renderTo(ctx) {\n      ctx.save();\n      this.setTransform(ctx);\n      this.setClip(ctx);\n      this.setOpacity(ctx);\n      ctx.beginPath();\n      this.renderPoints(ctx, this.srcElement);\n      this.setLineDash(ctx);\n      this.setLineCap(ctx);\n      this.setLineJoin(ctx);\n      this.setFill(ctx);\n      this.setStroke(ctx);\n      ctx.restore();\n    }\n  }, {\n    key: \"setFill\",\n    value: function setFill(ctx) {\n      var fill = this.srcElement.options.fill;\n      var hasFill = false;\n\n      if (fill) {\n        if (fill.nodeType === \"Gradient\") {\n          this.setGradientFill(ctx, fill);\n          hasFill = true;\n        } else if (!isTransparent(fill.color)) {\n          ctx.fillStyle = fill.color;\n          ctx.save();\n          this.globalAlpha(ctx, fill.opacity);\n          ctx.fill();\n          ctx.restore();\n          hasFill = true;\n        }\n      }\n\n      return hasFill;\n    }\n  }, {\n    key: \"setGradientFill\",\n    value: function setGradientFill(ctx, fill) {\n      var bbox = this.srcElement.rawBBox();\n      var gradient;\n\n      if (fill instanceof LinearGradient) {\n        var start = fill.start();\n        var end = fill.end();\n        gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n      } else if (fill instanceof RadialGradient) {\n        var center = fill.center();\n        gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());\n      }\n\n      addGradientStops(gradient, fill.stops);\n      ctx.save();\n\n      if (!fill.userSpace()) {\n        ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);\n      }\n\n      ctx.fillStyle = gradient;\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: \"setStroke\",\n    value: function setStroke(ctx) {\n      var stroke = this.srcElement.options.stroke;\n\n      if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {\n        ctx.strokeStyle = stroke.color;\n        ctx.lineWidth = valueOrDefault(stroke.width, 1);\n        ctx.save();\n        this.globalAlpha(ctx, stroke.opacity);\n        ctx.stroke();\n        ctx.restore();\n        return true;\n      }\n    }\n  }, {\n    key: \"dashType\",\n    value: function dashType() {\n      var stroke = this.srcElement.options.stroke;\n\n      if (stroke && stroke.dashType) {\n        return stroke.dashType.toLowerCase();\n      }\n    }\n  }, {\n    key: \"setLineDash\",\n    value: function setLineDash(ctx) {\n      var dashType = this.dashType();\n\n      if (dashType && dashType !== SOLID) {\n        var dashArray = DASH_ARRAYS[dashType];\n\n        if (ctx.setLineDash) {\n          ctx.setLineDash(dashArray);\n        } else {\n          ctx.mozDash = dashArray;\n          ctx.webkitLineDash = dashArray;\n        }\n      }\n    }\n  }, {\n    key: \"setLineCap\",\n    value: function setLineCap(ctx) {\n      var dashType = this.dashType();\n      var stroke = this.srcElement.options.stroke;\n\n      if (dashType && dashType !== SOLID) {\n        ctx.lineCap = BUTT;\n      } else if (stroke && stroke.lineCap) {\n        ctx.lineCap = stroke.lineCap;\n      }\n    }\n  }, {\n    key: \"setLineJoin\",\n    value: function setLineJoin(ctx) {\n      var stroke = this.srcElement.options.stroke;\n\n      if (stroke && stroke.lineJoin) {\n        ctx.lineJoin = stroke.lineJoin;\n      }\n    }\n  }, {\n    key: \"renderPoints\",\n    value: function renderPoints(ctx, path) {\n      renderPath(ctx, path);\n    }\n  }]);\n\n  return PathNode;\n}(Node);\n\nNODE_MAP.Path = PathNode;\nexport default PathNode;","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/canvas/path-node.js"],"names":["Node","parseColor","isTransparent","valueOrDefault","LinearGradient","RadialGradient","DASH_ARRAYS","SOLID","BUTT","renderPath","NODE_MAP","addGradientStops","gradient","stops","idx","length","stop","color","a","opacity","addColorStop","offset","toCssRgba","PathNode","ctx","save","setTransform","setClip","setOpacity","beginPath","renderPoints","srcElement","setLineDash","setLineCap","setLineJoin","setFill","setStroke","restore","fill","options","hasFill","nodeType","setGradientFill","fillStyle","globalAlpha","bbox","rawBBox","start","end","createLinearGradient","x","y","center","createRadialGradient","radius","userSpace","transform","width","height","origin","stroke","strokeStyle","lineWidth","dashType","toLowerCase","dashArray","mozDash","webkitLineDash","lineCap","lineJoin","path","Path"],"mappings":"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","sourcesContent":["import Node from './node';\nimport { parseColor } from '../common';\nimport { isTransparent, valueOrDefault } from '../util';\nimport LinearGradient from '../gradients/linear-gradient';\nimport RadialGradient from '../gradients/radial-gradient';\nimport { DASH_ARRAYS, SOLID, BUTT } from '../core/constants';\nimport renderPath from './utils/render-path';\nimport NODE_MAP from './node-map';\n\nfunction addGradientStops(gradient, stops) {\n    for (let idx = 0; idx < stops.length; idx++) {\n        let stop = stops[idx];\n        let color = parseColor(stop.color());\n\n        color.a *= stop.opacity();\n\n        gradient.addColorStop(stop.offset(), color.toCssRgba());\n    }\n}\n\nclass PathNode extends Node {\n\n    renderTo(ctx) {\n        ctx.save();\n\n        this.setTransform(ctx);\n        this.setClip(ctx);\n        this.setOpacity(ctx);\n\n        ctx.beginPath();\n\n        this.renderPoints(ctx, this.srcElement);\n\n        this.setLineDash(ctx);\n        this.setLineCap(ctx);\n        this.setLineJoin(ctx);\n\n        this.setFill(ctx);\n        this.setStroke(ctx);\n\n        ctx.restore();\n    }\n\n    setFill(ctx) {\n        const fill = this.srcElement.options.fill;\n        let hasFill = false;\n\n        if (fill) {\n            if (fill.nodeType === \"Gradient\") {\n                this.setGradientFill(ctx, fill);\n                hasFill = true;\n            } else if (!isTransparent(fill.color)) {\n                ctx.fillStyle = fill.color;\n\n                ctx.save();\n                this.globalAlpha(ctx, fill.opacity);\n                ctx.fill();\n                ctx.restore();\n\n                hasFill = true;\n            }\n        }\n\n        return hasFill;\n    }\n\n    setGradientFill(ctx, fill) {\n        const bbox = this.srcElement.rawBBox();\n        let gradient;\n\n        if (fill instanceof LinearGradient) {\n            let start = fill.start();\n            let end = fill.end();\n            gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n        } else if (fill instanceof RadialGradient) {\n            let center = fill.center();\n            gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());\n        }\n\n        addGradientStops(gradient, fill.stops);\n\n        ctx.save();\n\n        if (!fill.userSpace()) {\n            ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);\n        }\n        ctx.fillStyle = gradient;\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    setStroke(ctx) {\n        const stroke = this.srcElement.options.stroke;\n        if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {\n            ctx.strokeStyle = stroke.color;\n            ctx.lineWidth = valueOrDefault(stroke.width, 1);\n\n            ctx.save();\n            this.globalAlpha(ctx, stroke.opacity);\n            ctx.stroke();\n            ctx.restore();\n\n            return true;\n        }\n    }\n\n    dashType() {\n        const stroke = this.srcElement.options.stroke;\n        if (stroke && stroke.dashType) {\n            return stroke.dashType.toLowerCase();\n        }\n    }\n\n    setLineDash(ctx) {\n        const dashType = this.dashType();\n        if (dashType && dashType !== SOLID) {\n            const dashArray = DASH_ARRAYS[dashType];\n            if (ctx.setLineDash) {\n                ctx.setLineDash(dashArray);\n            } else {\n                ctx.mozDash = dashArray;\n                ctx.webkitLineDash = dashArray;\n            }\n        }\n    }\n\n    setLineCap(ctx) {\n        const dashType = this.dashType();\n        const stroke = this.srcElement.options.stroke;\n        if (dashType && dashType !== SOLID) {\n            ctx.lineCap = BUTT;\n        } else if (stroke && stroke.lineCap) {\n            ctx.lineCap = stroke.lineCap;\n        }\n    }\n\n    setLineJoin(ctx) {\n        const stroke = this.srcElement.options.stroke;\n        if (stroke && stroke.lineJoin) {\n            ctx.lineJoin = stroke.lineJoin;\n        }\n    }\n\n    renderPoints(ctx, path) {\n        renderPath(ctx, path);\n    }\n}\n\nNODE_MAP.Path = PathNode;\n\nexport default PathNode;\n"]},"metadata":{},"sourceType":"module"}