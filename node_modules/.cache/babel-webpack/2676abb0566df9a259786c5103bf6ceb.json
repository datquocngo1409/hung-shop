{"ast":null,"code":"import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nvar logic = {\n  \"or\": {\n    concat: function concat(acc, fn) {\n      return function (a) {\n        return acc(a) || fn(a);\n      };\n    },\n    identity: function identity() {\n      return false;\n    }\n  },\n  \"and\": {\n    concat: function concat(acc, fn) {\n      return function (a) {\n        return acc(a) && fn(a);\n      };\n    },\n    identity: function identity() {\n      return true;\n    }\n  }\n};\nvar operatorsMap = {\n  contains: function contains(a, b) {\n    return (a || \"\").indexOf(b) >= 0;\n  },\n  doesnotcontain: function doesnotcontain(a, b) {\n    return (a || \"\").indexOf(b) === -1;\n  },\n  doesnotendwith: function doesnotendwith(a, b) {\n    return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0;\n  },\n  doesnotstartwith: function doesnotstartwith(a, b) {\n    return (a || \"\").lastIndexOf(b, 0) === -1;\n  },\n  endswith: function endswith(a, b) {\n    return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0;\n  },\n  eq: function eq(a, b) {\n    return a === b;\n  },\n  gt: function gt(a, b) {\n    return a > b;\n  },\n  gte: function gte(a, b) {\n    return a >= b;\n  },\n  isempty: function isempty(a) {\n    return a === '';\n  },\n  isnotempty: function isnotempty(a) {\n    return a !== '';\n  },\n  isnotnull: function isnotnull(a) {\n    return isPresent(a);\n  },\n  isnull: function isnull(a) {\n    return isBlank(a);\n  },\n  lt: function lt(a, b) {\n    return a < b;\n  },\n  lte: function lte(a, b) {\n    return a <= b;\n  },\n  neq: function neq(a, b) {\n    return a != b;\n  },\n  startswith: function startswith(a, b) {\n    return (a || \"\").lastIndexOf(b, 0) === 0;\n  }\n};\nvar dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\n\nvar convertValue = function convertValue(value, ignoreCase) {\n  if (value != null && isString(value)) {\n    var date = dateRegExp.exec(value);\n\n    if (date) {\n      return new Date(+date[1]).getTime();\n    } else if (ignoreCase) {\n      return value.toLowerCase();\n    }\n  } else if (value != null && isDate(value)) {\n    return value.getTime();\n  }\n\n  return value;\n};\n\nvar typedGetter = function typedGetter(prop, value, ignoreCase) {\n  if (!isPresent(value)) {\n    return prop;\n  }\n\n  var acc = prop;\n\n  if (isString(value)) {\n    var date = dateRegExp.exec(value);\n\n    if (date) {\n      value = new Date(+date[1]);\n    } else {\n      acc = function acc(a) {\n        var x = prop(a);\n\n        if (typeof x === 'string' && ignoreCase) {\n          return x.toLowerCase();\n        } else {\n          return isNumeric(x) ? x + \"\" : x;\n        }\n      };\n    }\n  }\n\n  if (isDate(value)) {\n    return function (a) {\n      var x = acc(a);\n      return isDate(x) ? x.getTime() : x;\n    };\n  }\n\n  return acc;\n};\n\nvar transformFilter = function transformFilter(_ref) {\n  var field = _ref.field,\n      ignoreCase = _ref.ignoreCase,\n      value = _ref.value,\n      operator = _ref.operator;\n  field = !isPresent(field) ? function (a) {\n    return a;\n  } : field;\n  ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n  var itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n  value = convertValue(value, ignoreCase);\n  var op = isFunction(operator) ? operator : operatorsMap[operator];\n  return function (a) {\n    return op(itemProp(a), value, ignoreCase);\n  };\n};\n/**\n * @hidden\n */\n\n\nexport var transformCompositeFilter = function transformCompositeFilter(filter) {\n  var combiner = logic[filter.logic];\n  return filter.filters.filter(isPresent).map(function (x) {\n    return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x);\n  }).reduce(combiner.concat, combiner.identity);\n};","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-data-query/dist/es2015/filtering/filter-no-eval.js"],"names":["isCompositeFilterDescriptor","getter","isFunction","isPresent","isDate","isString","isBlank","isNumeric","logic","concat","acc","fn","a","identity","operatorsMap","contains","b","indexOf","doesnotcontain","doesnotendwith","length","doesnotstartwith","lastIndexOf","endswith","eq","gt","gte","isempty","isnotempty","isnotnull","isnull","lt","lte","neq","startswith","dateRegExp","convertValue","value","ignoreCase","date","exec","Date","getTime","toLowerCase","typedGetter","prop","x","transformFilter","field","operator","itemProp","op","transformCompositeFilter","filter","combiner","filters","map","reduce"],"mappings":"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","sourcesContent":["import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nconst logic = {\n    \"or\": {\n        concat: (acc, fn) => a => acc(a) || fn(a),\n        identity: () => false\n    },\n    \"and\": {\n        concat: (acc, fn) => a => acc(a) && fn(a),\n        identity: () => true\n    }\n};\nconst operatorsMap = {\n    contains: (a, b) => (a || \"\").indexOf(b) >= 0,\n    doesnotcontain: (a, b) => (a || \"\").indexOf(b) === -1,\n    doesnotendwith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0,\n    doesnotstartwith: (a, b) => (a || \"\").lastIndexOf(b, 0) === -1,\n    endswith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0,\n    eq: (a, b) => a === b,\n    gt: (a, b) => a > b,\n    gte: (a, b) => a >= b,\n    isempty: (a) => a === '',\n    isnotempty: (a) => a !== '',\n    isnotnull: (a) => isPresent(a),\n    isnull: (a) => isBlank(a),\n    lt: (a, b) => a < b,\n    lte: (a, b) => a <= b,\n    neq: (a, b) => a != b,\n    startswith: (a, b) => (a || \"\").lastIndexOf(b, 0) === 0\n};\nconst dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\nconst convertValue = (value, ignoreCase) => {\n    if (value != null && isString(value)) {\n        const date = dateRegExp.exec(value);\n        if (date) {\n            return new Date(+date[1]).getTime();\n        }\n        else if (ignoreCase) {\n            return value.toLowerCase();\n        }\n    }\n    else if (value != null && isDate(value)) {\n        return value.getTime();\n    }\n    return value;\n};\nconst typedGetter = (prop, value, ignoreCase) => {\n    if (!isPresent(value)) {\n        return prop;\n    }\n    let acc = prop;\n    if (isString(value)) {\n        const date = dateRegExp.exec(value);\n        if (date) {\n            value = new Date(+date[1]);\n        }\n        else {\n            acc = a => {\n                const x = prop(a);\n                if (typeof x === 'string' && ignoreCase) {\n                    return x.toLowerCase();\n                }\n                else {\n                    return isNumeric(x) ? x + \"\" : x;\n                }\n            };\n        }\n    }\n    if (isDate(value)) {\n        return a => {\n            const x = acc(a);\n            return isDate(x) ? x.getTime() : x;\n        };\n    }\n    return acc;\n};\nconst transformFilter = ({ field, ignoreCase, value, operator }) => {\n    field = !isPresent(field) ? a => a : field;\n    ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n    const itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n    value = convertValue(value, ignoreCase);\n    const op = isFunction(operator) ? operator : operatorsMap[operator];\n    return a => op(itemProp(a), value, ignoreCase);\n};\n/**\n * @hidden\n */\nexport const transformCompositeFilter = (filter) => {\n    const combiner = logic[filter.logic];\n    return filter.filters\n        .filter(isPresent)\n        .map(x => isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x))\n        .reduce(combiner.concat, combiner.identity);\n};\n"]},"metadata":{},"sourceType":"module"}