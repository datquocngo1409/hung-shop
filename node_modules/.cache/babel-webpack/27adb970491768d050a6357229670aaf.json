{"ast":null,"code":"import _defineProperty from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _PENALTIES;\n\nimport formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\nvar REMOVAL_PENALTY = 120;\nvar ADDITION_PENALTY = 20;\nvar LENGHT_DELTA = [2, 1, 5, 3, 4];\nvar LONG_LESS_PENALTY_DELTA = -2;\nvar SHORT_LESS_PENALTY_DELTA = -1;\nvar SHORT_MORE_PENALTY_DELTA = 1;\nvar LONG_MORE_PENALTY_DELTA = 2;\nvar PENALTIES = (_PENALTIES = {}, _defineProperty(_PENALTIES, LONG_LESS_PENALTY_DELTA.toString(), 8), _defineProperty(_PENALTIES, SHORT_LESS_PENALTY_DELTA.toString(), 6), _defineProperty(_PENALTIES, LONG_MORE_PENALTY_DELTA.toString(), 6), _defineProperty(_PENALTIES, SHORT_MORE_PENALTY_DELTA.toString(), 3), _PENALTIES);\nvar VALUE_FORMAT_LENGTH = {\n  numeric: 1,\n  \"2-digit\": 2,\n  short: 3,\n  long: 4,\n  narrow: 5\n};\nvar TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\n\nfunction getHourSpecifier(options) {\n  return options.hour12 ? \"h\" : \"H\";\n}\n\nvar DATE_OPTIONS_MAP = [{\n  key: \"era\",\n  specifier: \"G\"\n}, {\n  key: \"year\",\n  specifier: \"y\"\n}, {\n  key: \"month\",\n  specifier: \"M\"\n}, {\n  key: \"day\",\n  specifier: \"d\"\n}, {\n  key: \"weekday\",\n  specifier: \"E\"\n}, {\n  key: \"hour\",\n  getSpecifier: getHourSpecifier\n}, {\n  key: \"minute\",\n  specifier: \"m\"\n}, {\n  key: \"second\",\n  specifier: \"s\"\n}, {\n  key: \"timeZoneName\",\n  specifier: \"z\"\n}];\nvar STAND_ALONE_SPECIFIERS = {\n  e: 'c',\n  E: 'c',\n  M: 'L',\n  Q: 'q'\n};\nvar specifiersRegex = {};\nvar resolvedFormats = {};\n\nfunction getSpecifierRegex(specifier) {\n  if (!specifiersRegex[specifier]) {\n    specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n  }\n\n  return specifiersRegex[specifier];\n}\n\nfunction skeletonSpecifiers(skeleton) {\n  var result = [];\n  var current = skeleton.charAt(0);\n  var specifier = current;\n\n  for (var idx = 1; idx < skeleton.length; idx++) {\n    var character = skeleton.charAt(idx);\n\n    if (character === specifier) {\n      current += character;\n    } else {\n      result.push(current);\n      current = specifier = character;\n    }\n  }\n\n  result.push(current);\n  return result;\n}\n\nfunction findBestMatch(specifiers, availableFormats) {\n  var specifiersLength = specifiers.length;\n  var maxScore = -Number.MAX_VALUE;\n  var bestMatches, result;\n\n  for (var format in availableFormats) {\n    var matches = [];\n    var currentFormat = format.replace(\"v\", \"z\");\n    var score = 0;\n\n    for (var idx = 0; idx < specifiersLength; idx++) {\n      var specifier = specifiers[idx];\n      var specifierRegex = getSpecifierRegex(specifier[0]);\n      var match = (specifierRegex.exec(currentFormat) || [])[0];\n\n      if (!match) {\n        score -= REMOVAL_PENALTY;\n      } else {\n        currentFormat = currentFormat.replace(match, EMPTY);\n\n        if (match.length !== specifier.length) {\n          var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n          score -= PENALTIES[delta];\n        }\n      }\n\n      matches.push(match);\n\n      if (score < maxScore) {\n        break;\n      }\n    }\n\n    if (currentFormat.length) {\n      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n    }\n\n    if (score > maxScore) {\n      maxScore = score;\n      bestMatches = matches;\n      result = availableFormats[format];\n    }\n  }\n\n  result = result.replace(\"v\", \"z\");\n\n  for (var _idx = 0; _idx < specifiersLength; _idx++) {\n    var bestMatch = bestMatches[_idx];\n\n    if (bestMatch && bestMatch !== specifiers[_idx]) {\n      var matchSpecifier = bestMatches[_idx][0];\n      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[_idx]);\n\n      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[_idx]);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction cacheFormat(skeleton, format, locale) {\n  if (!resolvedFormats[locale]) {\n    resolvedFormats[locale] = {};\n  }\n\n  resolvedFormats[locale][skeleton] = format;\n}\n\nfunction skeletonFormat(skeleton, info) {\n  var availableFormats = info.calendar.dateTimeFormats.availableFormats;\n\n  if (availableFormats[skeleton]) {\n    return availableFormats[skeleton];\n  }\n\n  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n    return resolvedFormats[info.name][skeleton];\n  }\n\n  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n  var result;\n\n  if (timeStartIndex > 0) {\n    var dateSkeleton = skeleton.substr(0, timeStartIndex);\n    var timeSkeleton = skeleton.substr(timeStartIndex);\n    result = formatString(info.calendar.dateTimeFormats.short, //should be deterimed based on specifiers\n    availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats), availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n  } else {\n    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n  }\n\n  cacheFormat(skeleton, result, info.name);\n  return result;\n}\n\nfunction skeletonFromOptions(options) {\n  var result = [];\n\n  for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n    var option = DATE_OPTIONS_MAP[idx];\n    var field = option.key;\n    var value = options[field];\n\n    if (value) {\n      var spcifier = option.specifier || option.getSpecifier(options);\n      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n    }\n  }\n\n  return result.join(EMPTY);\n}\n\nexport default function datePattern(format, info) {\n  var calendar = info.calendar;\n  var result;\n\n  if (isString(format)) {\n    if (calendar.patterns[format]) {\n      result = calendar.patterns[format];\n    } else {\n      result = format;\n    }\n  } else if (format) {\n    if (format.pattern) {\n      return format.pattern;\n    }\n\n    var skeleton = format.skeleton;\n\n    if (!skeleton) {\n      if (format.datetime) {\n        result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n      } else if (format.date) {\n        result = calendar.dateFormats[format.date];\n      } else if (format.time) {\n        result = calendar.timeFormats[format.time];\n      } else {\n        skeleton = skeletonFromOptions(format);\n      }\n    }\n\n    if (skeleton) {\n      result = skeletonFormat(skeleton, info);\n    }\n  }\n\n  if (!result) {\n    result = calendar.patterns.d;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@telerik/kendo-intl/dist/es2015/dates/date-pattern.js"],"names":["formatString","isString","EMPTY","REMOVAL_PENALTY","ADDITION_PENALTY","LENGHT_DELTA","LONG_LESS_PENALTY_DELTA","SHORT_LESS_PENALTY_DELTA","SHORT_MORE_PENALTY_DELTA","LONG_MORE_PENALTY_DELTA","PENALTIES","toString","VALUE_FORMAT_LENGTH","numeric","short","long","narrow","TIME_SPECIFIERS_REGEX","getHourSpecifier","options","hour12","DATE_OPTIONS_MAP","key","specifier","getSpecifier","STAND_ALONE_SPECIFIERS","e","E","M","Q","specifiersRegex","resolvedFormats","getSpecifierRegex","RegExp","skeletonSpecifiers","skeleton","result","current","charAt","idx","length","character","push","findBestMatch","specifiers","availableFormats","specifiersLength","maxScore","Number","MAX_VALUE","bestMatches","format","matches","currentFormat","replace","score","specifierRegex","match","exec","delta","Math","max","min","bestMatch","matchSpecifier","cacheFormat","locale","skeletonFormat","info","calendar","dateTimeFormats","name","timeStartIndex","search","dateSkeleton","substr","timeSkeleton","skeletonFromOptions","option","field","value","spcifier","repeat","join","datePattern","patterns","pattern","datetime","timeFormats","dateFormats","date","time","d"],"mappings":"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","sourcesContent":["import formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\n\nconst REMOVAL_PENALTY = 120;\nconst ADDITION_PENALTY = 20;\nconst LENGHT_DELTA = [ 2, 1, 5, 3, 4 ];\nconst LONG_LESS_PENALTY_DELTA = -2;\nconst SHORT_LESS_PENALTY_DELTA = -1;\nconst SHORT_MORE_PENALTY_DELTA = 1;\nconst LONG_MORE_PENALTY_DELTA = 2;\n\nconst PENALTIES = {\n    [LONG_LESS_PENALTY_DELTA.toString()]: 8,\n    [SHORT_LESS_PENALTY_DELTA.toString()]: 6,\n    [LONG_MORE_PENALTY_DELTA.toString()]: 6,\n    [SHORT_MORE_PENALTY_DELTA.toString()]: 3\n};\n\nconst VALUE_FORMAT_LENGTH = {\n    numeric: 1,\n    \"2-digit\": 2,\n    short: 3,\n    long: 4,\n    narrow: 5\n};\n\nconst TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\n\nfunction getHourSpecifier(options) {\n    return options.hour12 ? \"h\" : \"H\";\n}\n\nconst DATE_OPTIONS_MAP = [ {\n    key: \"era\",\n    specifier: \"G\"\n}, {\n    key: \"year\",\n    specifier: \"y\"\n}, {\n    key: \"month\",\n    specifier: \"M\"\n}, {\n    key: \"day\",\n    specifier: \"d\"\n}, {\n    key: \"weekday\",\n    specifier: \"E\"\n}, {\n    key: \"hour\",\n    getSpecifier: getHourSpecifier\n}, {\n    key: \"minute\",\n    specifier: \"m\"\n}, {\n    key: \"second\",\n    specifier: \"s\"\n}, {\n    key: \"timeZoneName\",\n    specifier: \"z\"\n} ];\n\nconst STAND_ALONE_SPECIFIERS = {\n    e: 'c',\n    E: 'c',\n    M: 'L',\n    Q: 'q'\n};\n\nconst specifiersRegex = {};\nconst resolvedFormats = {};\n\nfunction getSpecifierRegex(specifier) {\n    if (!specifiersRegex[specifier]) {\n        specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n    }\n    return specifiersRegex[specifier];\n}\n\nfunction skeletonSpecifiers(skeleton) {\n    const result = [];\n    let current = skeleton.charAt(0);\n    let specifier = current;\n    for (let idx = 1; idx < skeleton.length; idx++) {\n        let character = skeleton.charAt(idx);\n        if (character === specifier) {\n            current += character;\n        } else {\n            result.push(current);\n            current = specifier = character;\n        }\n    }\n\n    result.push(current);\n\n    return result;\n}\n\nfunction findBestMatch(specifiers, availableFormats) {\n    const specifiersLength = specifiers.length;\n    let maxScore = -Number.MAX_VALUE;\n    let bestMatches, result;\n    for (let format in availableFormats) {\n        const matches = [];\n        let currentFormat = format.replace(\"v\", \"z\");\n        let score = 0;\n        for (let idx = 0; idx < specifiersLength; idx++) {\n            const specifier = specifiers[idx];\n            let specifierRegex = getSpecifierRegex(specifier[0]);\n            let match = (specifierRegex.exec(currentFormat) || [])[0];\n\n            if (!match) {\n                score -= REMOVAL_PENALTY;\n            } else {\n                currentFormat = currentFormat.replace(match, EMPTY);\n                if (match.length !== specifier.length) {\n                    let delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n                    score -= PENALTIES[delta];\n                }\n            }\n\n            matches.push(match);\n\n            if (score < maxScore) {\n                break;\n            }\n        }\n\n        if (currentFormat.length) {\n            score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n        }\n\n        if (score > maxScore) {\n            maxScore = score;\n            bestMatches = matches;\n            result = availableFormats[format];\n        }\n    }\n\n    result = result.replace(\"v\", \"z\");\n\n    for (let idx = 0; idx < specifiersLength; idx++) {\n        const bestMatch = bestMatches[idx];\n        if (bestMatch && bestMatch !== specifiers[idx]) {\n            const matchSpecifier = bestMatches[idx][0];\n            result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx]);\n            if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n                result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx]);\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction cacheFormat(skeleton, format, locale) {\n    if (!resolvedFormats[locale]) {\n        resolvedFormats[locale] = {};\n    }\n    resolvedFormats[locale][skeleton] = format;\n}\n\n\nfunction skeletonFormat(skeleton, info) {\n    const availableFormats = info.calendar.dateTimeFormats.availableFormats;\n    if (availableFormats[skeleton]) {\n        return availableFormats[skeleton];\n    }\n    if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n        return resolvedFormats[info.name][skeleton];\n    }\n    const timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n    let result;\n    if (timeStartIndex > 0) {\n        const dateSkeleton = skeleton.substr(0, timeStartIndex);\n        const timeSkeleton = skeleton.substr(timeStartIndex);\n\n        result = formatString(info.calendar.dateTimeFormats.short, //should be deterimed based on specifiers\n            availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),\n            availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n    } else {\n        result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n    }\n\n    cacheFormat(skeleton, result, info.name);\n    return result;\n}\n\nfunction skeletonFromOptions(options) {\n    let result = [];\n    for (let idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n        let option = DATE_OPTIONS_MAP[idx];\n        let field = option.key;\n        let value = options[field];\n        if (value) {\n            let spcifier = option.specifier || option.getSpecifier(options);\n            result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n        }\n    }\n\n    return result.join(EMPTY);\n}\n\nexport default function datePattern(format, info) {\n    const calendar = info.calendar;\n    let result;\n    if (isString(format)) {\n        if (calendar.patterns[format]) {\n            result = calendar.patterns[format];\n        } else {\n            result = format;\n        }\n    } else if (format) {\n        if (format.pattern) {\n            return format.pattern;\n        }\n\n        let skeleton = format.skeleton;\n        if (!skeleton) {\n            if (format.datetime) {\n                result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n            } else if (format.date) {\n                result = calendar.dateFormats[format.date];\n            } else if (format.time) {\n                result = calendar.timeFormats[format.time];\n            } else {\n                skeleton = skeletonFromOptions(format);\n            }\n        }\n\n        if (skeleton) {\n            result = skeletonFormat(skeleton, info);\n        }\n    }\n\n    if (!result) {\n        result = calendar.patterns.d;\n    }\n\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}