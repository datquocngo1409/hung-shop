{"ast":null,"code":"import Point from '../geometry/point';\nimport ShapeMap from './shape-map';\nvar SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\nvar SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\nvar MOVE = \"m\";\nvar CLOSE = \"z\";\n\nfunction parseParameters(str) {\n  var parameters = [];\n  str.replace(SPLIT_REGEX, function (match, number) {\n    parameters.push(parseFloat(number));\n  });\n  return parameters;\n}\n\nfunction parsePath(pathInstance, str) {\n  var position = new Point();\n  var previousCommand;\n  str.replace(SEGMENT_REGEX, function (match, element, params, closePath) {\n    var command = element.toLowerCase();\n    var isRelative = command === element;\n    var parameters = parseParameters(params.trim());\n\n    if (command === MOVE) {\n      if (isRelative) {\n        position.x += parameters[0];\n        position.y += parameters[1];\n      } else {\n        position.x = parameters[0];\n        position.y = parameters[1];\n      }\n\n      pathInstance.moveTo(position.x, position.y);\n\n      if (parameters.length > 2) {\n        command = \"l\";\n        parameters.splice(0, 2);\n      }\n    }\n\n    if (ShapeMap[command]) {\n      ShapeMap[command](pathInstance, {\n        parameters: parameters,\n        position: position,\n        isRelative: isRelative,\n        previousCommand: previousCommand\n      });\n\n      if (closePath && closePath.toLowerCase() === CLOSE) {\n        pathInstance.close();\n      }\n    } else if (command !== MOVE) {\n      throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\n    }\n\n    previousCommand = command;\n  });\n  return pathInstance;\n}\n\nexport default parsePath;","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/parsing/parse-path.js"],"names":["Point","ShapeMap","SEGMENT_REGEX","SPLIT_REGEX","MOVE","CLOSE","parseParameters","str","parameters","replace","match","number","push","parseFloat","parsePath","pathInstance","position","previousCommand","element","params","closePath","command","toLowerCase","isRelative","trim","x","y","moveTo","length","splice","close","Error"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,mBAAlB;AACA,OAAOC,QAAP,MAAqB,aAArB;AAEA,IAAMC,aAAa,GAAG,iCAAtB;AACA,IAAMC,WAAW,GAAG,mDAApB;AACA,IAAMC,IAAI,GAAG,GAAb;AACA,IAAMC,KAAK,GAAG,GAAd;;AAEA,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;AAC1B,MAAMC,UAAU,GAAG,EAAnB;AACAD,EAAAA,GAAG,CAACE,OAAJ,CAAYN,WAAZ,EAAyB,UAASO,KAAT,EAAgBC,MAAhB,EAAwB;AAC7CH,IAAAA,UAAU,CAACI,IAAX,CAAgBC,UAAU,CAACF,MAAD,CAA1B;AACH,GAFD;AAGA,SAAOH,UAAP;AACH;;AAED,SAASM,SAAT,CAAmBC,YAAnB,EAAiCR,GAAjC,EAAsC;AAClC,MAAMS,QAAQ,GAAG,IAAIhB,KAAJ,EAAjB;AACA,MAAIiB,eAAJ;AAEAV,EAAAA,GAAG,CAACE,OAAJ,CAAYP,aAAZ,EAA2B,UAACQ,KAAD,EAAQQ,OAAR,EAAiBC,MAAjB,EAAyBC,SAAzB,EAAuC;AAC9D,QAAIC,OAAO,GAAGH,OAAO,CAACI,WAAR,EAAd;AACA,QAAMC,UAAU,GAAGF,OAAO,KAAKH,OAA/B;AACA,QAAMV,UAAU,GAAGF,eAAe,CAACa,MAAM,CAACK,IAAP,EAAD,CAAlC;;AAEA,QAAIH,OAAO,KAAKjB,IAAhB,EAAsB;AAClB,UAAImB,UAAJ,EAAgB;AACZP,QAAAA,QAAQ,CAACS,CAAT,IAAcjB,UAAU,CAAC,CAAD,CAAxB;AACAQ,QAAAA,QAAQ,CAACU,CAAT,IAAclB,UAAU,CAAC,CAAD,CAAxB;AACH,OAHD,MAGO;AACHQ,QAAAA,QAAQ,CAACS,CAAT,GAAajB,UAAU,CAAC,CAAD,CAAvB;AACAQ,QAAAA,QAAQ,CAACU,CAAT,GAAalB,UAAU,CAAC,CAAD,CAAvB;AACH;;AAEDO,MAAAA,YAAY,CAACY,MAAb,CAAoBX,QAAQ,CAACS,CAA7B,EAAgCT,QAAQ,CAACU,CAAzC;;AAEA,UAAIlB,UAAU,CAACoB,MAAX,GAAoB,CAAxB,EAA2B;AACvBP,QAAAA,OAAO,GAAG,GAAV;AACAb,QAAAA,UAAU,CAACqB,MAAX,CAAkB,CAAlB,EAAqB,CAArB;AACH;AACJ;;AAED,QAAI5B,QAAQ,CAACoB,OAAD,CAAZ,EAAuB;AACnBpB,MAAAA,QAAQ,CAACoB,OAAD,CAAR,CACIN,YADJ,EACkB;AACVP,QAAAA,UAAU,EAAEA,UADF;AAEVQ,QAAAA,QAAQ,EAAEA,QAFA;AAGVO,QAAAA,UAAU,EAAEA,UAHF;AAIVN,QAAAA,eAAe,EAAEA;AAJP,OADlB;;AASA,UAAIG,SAAS,IAAIA,SAAS,CAACE,WAAV,OAA4BjB,KAA7C,EAAoD;AAChDU,QAAAA,YAAY,CAACe,KAAb;AACH;AACJ,KAbD,MAaO,IAAIT,OAAO,KAAKjB,IAAhB,EAAsB;AACzB,YAAM,IAAI2B,KAAJ,CAAU,wDAAwDV,OAAlE,CAAN;AACH;;AAEDJ,IAAAA,eAAe,GAAGI,OAAlB;AACH,GAxCD;AA0CA,SAAON,YAAP;AACH;;AAED,eAAeD,SAAf","sourcesContent":["import Point from '../geometry/point';\nimport ShapeMap from './shape-map';\n\nconst SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\nconst SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\nconst MOVE = \"m\";\nconst CLOSE = \"z\";\n\nfunction parseParameters(str) {\n    const parameters = [];\n    str.replace(SPLIT_REGEX, function(match, number) {\n        parameters.push(parseFloat(number));\n    });\n    return parameters;\n}\n\nfunction parsePath(pathInstance, str) {\n    const position = new Point();\n    let previousCommand;\n\n    str.replace(SEGMENT_REGEX, (match, element, params, closePath) => {\n        let command = element.toLowerCase();\n        const isRelative = command === element;\n        const parameters = parseParameters(params.trim());\n\n        if (command === MOVE) {\n            if (isRelative) {\n                position.x += parameters[0];\n                position.y += parameters[1];\n            } else {\n                position.x = parameters[0];\n                position.y = parameters[1];\n            }\n\n            pathInstance.moveTo(position.x, position.y);\n\n            if (parameters.length > 2) {\n                command = \"l\";\n                parameters.splice(0, 2);\n            }\n        }\n\n        if (ShapeMap[command]) {\n            ShapeMap[command](\n                pathInstance, {\n                    parameters: parameters,\n                    position: position,\n                    isRelative: isRelative,\n                    previousCommand: previousCommand\n                }\n            );\n\n            if (closePath && closePath.toLowerCase() === CLOSE) {\n                pathInstance.close();\n            }\n        } else if (command !== MOVE) {\n            throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\n        }\n\n        previousCommand = command;\n    });\n\n    return pathInstance;\n}\n\nexport default parsePath;\n\n"]},"metadata":{},"sourceType":"module"}