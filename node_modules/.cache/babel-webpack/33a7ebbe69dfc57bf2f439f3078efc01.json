{"ast":null,"code":"import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\n\nexport var normalizeGroups = function normalizeGroups(descriptors) {\n  descriptors = isArray(descriptors) ? descriptors : [descriptors];\n  return descriptors.map(function (x) {\n    return Object.assign({\n      dir: \"asc\"\n    }, x);\n  });\n};\nvar identity = map(function (x) {\n  return x;\n});\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts-no-run\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\n\nexport var groupBy = function groupBy(data) {\n  var descriptors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var transformers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n  var originalData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : data;\n  descriptors = normalizeGroups(descriptors);\n\n  if (!descriptors.length) {\n    return data;\n  }\n\n  var descriptor = descriptors[0];\n  var initialValue = {};\n  var view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n  var result = [];\n  Object.keys(view).forEach(function (field) {\n    Object.keys(view[field]).forEach(function (value) {\n      var group = view[field][value];\n      var aggregateResult = {};\n      var filteredData = originalData;\n\n      if (isPresent(descriptor.aggregates)) {\n        filteredData = filterBy(originalData, {\n          field: descriptor.field,\n          ignoreCase: false,\n          operator: 'eq',\n          value: group.value\n        });\n        aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n      }\n\n      result[group.__position] = {\n        aggregates: aggregateResult,\n        field: field,\n        items: descriptors.length > 1 ? groupBy(group.items, descriptors.slice(1), identity, filteredData) : group.items,\n        value: group.value\n      };\n    });\n  });\n  return result;\n};","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@progress/kendo-data-query/dist/es2015/grouping/group.operators.js"],"names":["exec","map","groupCombinator","isArray","isPresent","aggregateBy","filterBy","normalizeGroups","descriptors","x","Object","assign","dir","identity","groupBy","data","transformers","originalData","length","descriptor","initialValue","view","field","result","keys","forEach","value","group","aggregateResult","filteredData","aggregates","ignoreCase","operator","__position","items","slice"],"mappings":"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","sourcesContent":["import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\nexport const normalizeGroups = (descriptors) => {\n    descriptors = isArray(descriptors) ? descriptors : [descriptors];\n    return descriptors.map(x => Object.assign({ dir: \"asc\" }, x));\n};\nconst identity = map(x => x);\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts-no-run\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\nexport const groupBy = (data, descriptors = [], transformers = identity, originalData = data) => {\n    descriptors = normalizeGroups(descriptors);\n    if (!descriptors.length) {\n        return data;\n    }\n    const descriptor = descriptors[0];\n    const initialValue = {};\n    const view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n    const result = [];\n    Object.keys(view).forEach(field => {\n        Object.keys(view[field]).forEach(value => {\n            const group = view[field][value];\n            let aggregateResult = {};\n            let filteredData = originalData;\n            if (isPresent(descriptor.aggregates)) {\n                filteredData = filterBy(originalData, {\n                    field: descriptor.field,\n                    ignoreCase: false,\n                    operator: 'eq',\n                    value: group.value\n                });\n                aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n            }\n            result[group.__position] = {\n                aggregates: aggregateResult,\n                field: field,\n                items: descriptors.length > 1 ?\n                    groupBy(group.items, descriptors.slice(1), identity, filteredData)\n                    : group.items,\n                value: group.value\n            };\n        });\n    });\n    return result;\n};\n"]},"metadata":{},"sourceType":"module"}