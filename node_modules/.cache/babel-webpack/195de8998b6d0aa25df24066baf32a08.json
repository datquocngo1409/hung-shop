{"ast":null,"code":"import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';\nimport { compose, ifElse } from './funcs';\nimport { normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue, toUTC } from './filter-serialization.common';\nimport { normalizeFilters } from './filtering/filter.operators';\n\nvar formatDate = function formatDate(_ref) {\n  var utcDates = _ref.utcDates;\n  return function (_ref2) {\n    var field = _ref2.field,\n        value = _ref2.value,\n        ignoreCase = _ref2.ignoreCase,\n        operator = _ref2.operator;\n    return {\n      value: JSON.stringify(!utcDates ? toUTC(value) : value).replace(/\"/g, \"\"),\n      field: field,\n      ignoreCase: ignoreCase,\n      operator: operator\n    };\n  };\n};\n\nvar fnFormatter = function fnFormatter(_ref3) {\n  var operator = _ref3.operator;\n  return function (_ref4) {\n    var field = _ref4.field,\n        value = _ref4.value;\n    return \"\".concat(operator, \"(\").concat(field, \",\").concat(value, \")\");\n  };\n};\n\nvar singleOperatorFormatter = function singleOperatorFormatter(_ref5) {\n  var operator = _ref5.operator;\n  return function (_ref6) {\n    var field = _ref6.field,\n        value = _ref6.value;\n    return \"\".concat(field, \" \").concat(operator, \" \").concat(value);\n  };\n};\n\nvar stringFormat = function stringFormat(formatter) {\n  return compose(formatter, encodeValue, quote, toLower, normalizeField);\n};\n\nvar stringFnOperator = function stringFnOperator(settings) {\n  return stringFormat(fnFormatter(settings));\n};\n\nvar stringOperator = function stringOperator(settings) {\n  return stringFormat(singleOperatorFormatter(settings));\n};\n\nvar numericOperator = function numericOperator(settings) {\n  return compose(singleOperatorFormatter(settings), normalizeField);\n};\n\nvar dateOperator = function dateOperator(settings) {\n  return compose(singleOperatorFormatter(settings), normalizeField, formatDate(settings));\n};\n\nvar ifDate = function ifDate(settings) {\n  return ifElse(isDateValue, dateOperator(settings), numericOperator(settings));\n};\n\nvar typedOperator = function typedOperator(settings) {\n  return ifElse(isStringValue, stringOperator(settings), ifDate(settings));\n};\n\nvar appendEqual = function appendEqual(str) {\n  return \"\".concat(str, \" eq -1\");\n};\n\nvar nonValueExpression = function nonValueExpression(formatter) {\n  return compose(formatter, normalizeField);\n};\n\nvar filterOperators = function filterOperators(operator, settings) {\n  return {\n    contains: stringFnOperator(Object.assign({}, settings, {\n      operator: \"contains\"\n    })),\n    doesnotcontain: compose(appendEqual, stringFnOperator(Object.assign({}, settings, {\n      operator: \"indexof\"\n    }))),\n    endswith: stringFnOperator(Object.assign({}, settings, {\n      operator: \"endswith\"\n    })),\n    eq: typedOperator(Object.assign({}, settings, {\n      operator: \"eq\"\n    })),\n    gt: typedOperator(Object.assign({}, settings, {\n      operator: \"gt\"\n    })),\n    gte: typedOperator(Object.assign({}, settings, {\n      operator: \"ge\"\n    })),\n    isempty: nonValueExpression(function (_ref7) {\n      var field = _ref7.field;\n      return \"\".concat(field, \" eq ''\");\n    }),\n    isnotempty: nonValueExpression(function (_ref8) {\n      var field = _ref8.field;\n      return \"\".concat(field, \" ne ''\");\n    }),\n    isnotnull: nonValueExpression(function (_ref9) {\n      var field = _ref9.field;\n      return \"\".concat(field, \" ne null\");\n    }),\n    isnull: nonValueExpression(function (_ref10) {\n      var field = _ref10.field;\n      return \"\".concat(field, \" eq null\");\n    }),\n    lt: typedOperator(Object.assign({}, settings, {\n      operator: \"lt\"\n    })),\n    lte: typedOperator(Object.assign({}, settings, {\n      operator: \"le\"\n    })),\n    neq: typedOperator(Object.assign({}, settings, {\n      operator: \"ne\"\n    })),\n    startswith: stringFnOperator(Object.assign({}, settings, {\n      operator: \"startswith\"\n    }))\n  }[operator];\n};\n\nvar join = function join(x) {\n  return \" \".concat(x.logic, \" \");\n};\n\nvar serialize = function serialize(settings) {\n  return function (x) {\n    return filterOperators(x.operator, settings)(x);\n  };\n};\n\nvar serializeAll = function serializeAll(settings) {\n  return serializeFilters(function (filter) {\n    return ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize(settings))(filter);\n  }, join);\n};\n/**\n * @hidden\n */\n\n\nexport var serializeFilter = function serializeFilter(filter) {\n  var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (filter.filters && filter.filters.length) {\n    return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n  }\n\n  return \"\";\n};","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-data-query/dist/es2015/odata-filtering.operators.js"],"names":["isCompositeFilterDescriptor","compose","ifElse","normalizeField","quote","toLower","isDateValue","isStringValue","serializeFilters","encodeValue","toUTC","normalizeFilters","formatDate","utcDates","field","value","ignoreCase","operator","JSON","stringify","replace","fnFormatter","singleOperatorFormatter","stringFormat","formatter","stringFnOperator","settings","stringOperator","numericOperator","dateOperator","ifDate","typedOperator","appendEqual","str","nonValueExpression","filterOperators","contains","Object","assign","doesnotcontain","endswith","eq","gt","gte","isempty","isnotempty","isnotnull","isnull","lt","lte","neq","startswith","join","x","logic","serialize","serializeAll","filter","serializeFilter","filters","length"],"mappings":"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","sourcesContent":["import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';\nimport { compose, ifElse } from './funcs';\nimport { normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue, toUTC } from './filter-serialization.common';\nimport { normalizeFilters } from './filtering/filter.operators';\nconst formatDate = ({ utcDates }) => ({ field, value, ignoreCase, operator }) => ({\n    value: JSON.stringify(!utcDates ? toUTC(value) : value).replace(/\"/g, \"\"),\n    field,\n    ignoreCase,\n    operator\n});\nconst fnFormatter = ({ operator }) => ({ field, value }) => `${operator}(${field},${value})`;\nconst singleOperatorFormatter = ({ operator }) => ({ field, value }) => `${field} ${operator} ${value}`;\nconst stringFormat = formatter => compose(formatter, encodeValue, quote, toLower, normalizeField);\nconst stringFnOperator = settings => stringFormat(fnFormatter(settings));\nconst stringOperator = settings => stringFormat(singleOperatorFormatter(settings));\nconst numericOperator = settings => compose(singleOperatorFormatter(settings), normalizeField);\nconst dateOperator = settings => compose(singleOperatorFormatter(settings), normalizeField, formatDate(settings));\nconst ifDate = settings => ifElse(isDateValue, dateOperator(settings), numericOperator(settings));\nconst typedOperator = settings => ifElse(isStringValue, stringOperator(settings), ifDate(settings));\nconst appendEqual = str => `${str} eq -1`;\nconst nonValueExpression = formatter => compose(formatter, normalizeField);\nconst filterOperators = (operator, settings) => ({\n    contains: stringFnOperator(Object.assign({}, settings, { operator: \"contains\" })),\n    doesnotcontain: compose(appendEqual, stringFnOperator(Object.assign({}, settings, { operator: \"indexof\" }))),\n    endswith: stringFnOperator(Object.assign({}, settings, { operator: \"endswith\" })),\n    eq: typedOperator(Object.assign({}, settings, { operator: \"eq\" })),\n    gt: typedOperator(Object.assign({}, settings, { operator: \"gt\" })),\n    gte: typedOperator(Object.assign({}, settings, { operator: \"ge\" })),\n    isempty: nonValueExpression(({ field }) => `${field} eq ''`),\n    isnotempty: nonValueExpression(({ field }) => `${field} ne ''`),\n    isnotnull: nonValueExpression(({ field }) => `${field} ne null`),\n    isnull: nonValueExpression(({ field }) => `${field} eq null`),\n    lt: typedOperator(Object.assign({}, settings, { operator: \"lt\" })),\n    lte: typedOperator(Object.assign({}, settings, { operator: \"le\" })),\n    neq: typedOperator(Object.assign({}, settings, { operator: \"ne\" })),\n    startswith: stringFnOperator(Object.assign({}, settings, { operator: \"startswith\" }))\n}[operator]);\nconst join = x => ` ${x.logic} `;\nconst serialize = settings => x => filterOperators(x.operator, settings)(x);\nconst serializeAll = settings => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize(settings))(filter), join);\n/**\n * @hidden\n */\nexport const serializeFilter = (filter, settings = {}) => {\n    if (filter.filters && filter.filters.length) {\n        return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n    }\n    return \"\";\n};\n"]},"metadata":{},"sourceType":"module"}