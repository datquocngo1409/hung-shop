{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\nvar points = [\"anchor\", \"controlIn\", \"controlOut\"];\n\nvar Segment = /*#__PURE__*/function (_withPoints) {\n  _inherits(Segment, _withPoints);\n\n  var _super = _createSuper(Segment);\n\n  function Segment(anchor, controlIn, controlOut) {\n    var _this;\n\n    _classCallCheck(this, Segment);\n\n    _this = _super.call(this);\n\n    _this.anchor(anchor || new Point());\n\n    _this.controlIn(controlIn);\n\n    _this.controlOut(controlOut);\n\n    return _this;\n  }\n\n  _createClass(Segment, [{\n    key: \"bboxTo\",\n    value: function bboxTo(toSegment, matrix) {\n      var segmentAnchor = this.anchor().transformCopy(matrix);\n      var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n      var rect;\n\n      if (this.controlOut() && toSegment.controlIn()) {\n        rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n      } else {\n        rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"_lineBoundingBox\",\n    value: function _lineBoundingBox(p1, p2) {\n      return Rect.fromPoints(p1, p2);\n    }\n  }, {\n    key: \"_curveBoundingBox\",\n    value: function _curveBoundingBox(p1, cp1, cp2, p2) {\n      var points = [p1, cp1, cp2, p2];\n\n      var extremesX = this._curveExtremesFor(points, \"x\");\n\n      var extremesY = this._curveExtremesFor(points, \"y\");\n\n      var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n      var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n      return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n    }\n  }, {\n    key: \"_curveExtremesFor\",\n    value: function _curveExtremesFor(points, field) {\n      var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n\n      return {\n        min: calculateCurveAt(extremes.min, field, points),\n        max: calculateCurveAt(extremes.max, field, points)\n      };\n    }\n  }, {\n    key: \"_curveExtremes\",\n    value: function _curveExtremes(x1, x2, x3, x4) {\n      var a = x1 - 3 * x2 + 3 * x3 - x4;\n      var b = -2 * (x1 - 2 * x2 + x3);\n      var c = x1 - x2;\n      var sqrt = Math.sqrt(b * b - 4 * a * c);\n      var t1 = 0;\n      var t2 = 1;\n\n      if (a === 0) {\n        if (b !== 0) {\n          t1 = t2 = -c / b;\n        }\n      } else if (!isNaN(sqrt)) {\n        t1 = (-b + sqrt) / (2 * a);\n        t2 = (-b - sqrt) / (2 * a);\n      }\n\n      var min = Math.max(Math.min(t1, t2), 0);\n\n      if (min < 0 || min > 1) {\n        min = 0;\n      }\n\n      var max = Math.min(Math.max(t1, t2), 1);\n\n      if (max > 1 || max < 0) {\n        max = 1;\n      }\n\n      return {\n        min: min,\n        max: max\n      };\n    }\n  }, {\n    key: \"_intersectionsTo\",\n    value: function _intersectionsTo(segment, point) {\n      var intersectionsCount;\n\n      if (this.controlOut() && segment.controlIn()) {\n        intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n      } else {\n        intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n      }\n\n      return intersectionsCount;\n    }\n  }, {\n    key: \"_isOnCurveTo\",\n    value: function _isOnCurveTo(segment, point, width, endSegment) {\n      var bbox = this.bboxTo(segment).expand(width, width);\n\n      if (bbox.containsPoint(point)) {\n        var p1 = this.anchor();\n        var p2 = this.controlOut();\n        var p3 = segment.controlIn();\n        var p4 = segment.anchor();\n\n        if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n          return !isOutOfEndPoint(p1, p2, point);\n        } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n          return !isOutOfEndPoint(p4, p3, point);\n        } //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n\n\n        var _points = [p1, p2, p3, p4];\n\n        if (hasRootsInRange(_points, point, \"x\", \"y\", width) || hasRootsInRange(_points, point, \"y\", \"x\", width)) {\n          return true;\n        }\n\n        var rotation = transform().rotate(45, point);\n        var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n        return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n      }\n    }\n  }, {\n    key: \"_isOnLineTo\",\n    value: function _isOnLineTo(segment, point, width) {\n      var p1 = this.anchor();\n      var p2 = segment.anchor();\n      var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n      var rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n      return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n    }\n  }, {\n    key: \"_isOnPathTo\",\n    value: function _isOnPathTo(segment, point, width, endSegment) {\n      var isOnPath;\n\n      if (this.controlOut() && segment.controlIn()) {\n        isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n      } else {\n        isOnPath = this._isOnLineTo(segment, point, width);\n      }\n\n      return isOnPath;\n    }\n  }]);\n\n  return Segment;\n}(withPoints(HasObservers, points));\n\nfunction arrayLimits(arr) {\n  var length = arr.length;\n  var min = MAX_NUM;\n  var max = MIN_NUM;\n\n  for (var i = 0; i < length; i++) {\n    max = Math.max(max, arr[i]);\n    min = Math.min(min, arr[i]);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nexport default Segment;","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/geometry/segment.js"],"names":["HasObservers","Rect","Point","transform","deg","MIN_NUM","MAX_NUM","isOutOfEndPoint","calculateCurveAt","hasRootsInRange","curveIntersectionsCount","lineIntersectionsCount","withPoints","points","Segment","anchor","controlIn","controlOut","toSegment","matrix","segmentAnchor","transformCopy","toSegmentAnchor","rect","_curveBoundingBox","_lineBoundingBox","p1","p2","fromPoints","cp1","cp2","extremesX","_curveExtremesFor","extremesY","xLimits","arrayLimits","min","max","x","yLimits","y","field","extremes","_curveExtremes","x1","x2","x3","x4","a","b","c","sqrt","Math","t1","t2","isNaN","segment","point","intersectionsCount","bboxTo","width","endSegment","bbox","expand","containsPoint","p3","p4","distanceTo","rotation","rotate","rotatedPoints","angle","atan2","isOnPath","_isOnCurveTo","_isOnLineTo","arr","length","i"],"mappings":";;;;AAAA,OAAOA,YAAP,MAAyB,uBAAzB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,SAASC,GAAT,EAAcC,OAAd,EAAuBC,OAAvB,QAAsC,SAAtC;AACA,OAAOC,eAAP,MAA4B,4BAA5B;AACA,OAAOC,gBAAP,MAA6B,2BAA7B;AACA,OAAOC,eAAP,MAA4B,2BAA5B;AACA,OAAOC,uBAAP,MAAoC,kCAApC;AACA,OAAOC,sBAAP,MAAmC,iCAAnC;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AAGA,IAAMC,MAAM,GAAG,CAAE,QAAF,EAAY,WAAZ,EAAyB,YAAzB,CAAf;;IAEMC,O;;;;;AACF,mBAAYC,MAAZ,EAAoBC,SAApB,EAA+BC,UAA/B,EAA2C;AAAA;;AAAA;;AACvC;;AAEA,UAAKF,MAAL,CAAYA,MAAM,IAAI,IAAIb,KAAJ,EAAtB;;AACA,UAAKc,SAAL,CAAeA,SAAf;;AACA,UAAKC,UAAL,CAAgBA,UAAhB;;AALuC;AAM1C;;;;2BAEMC,S,EAAWC,M,EAAQ;AACtB,UAAMC,aAAa,GAAG,KAAKL,MAAL,GAAcM,aAAd,CAA4BF,MAA5B,CAAtB;AACA,UAAMG,eAAe,GAAGJ,SAAS,CAACH,MAAV,GAAmBM,aAAnB,CAAiCF,MAAjC,CAAxB;AACA,UAAII,IAAJ;;AAEA,UAAI,KAAKN,UAAL,MAAqBC,SAAS,CAACF,SAAV,EAAzB,EAAgD;AAC5CO,QAAAA,IAAI,GAAG,KAAKC,iBAAL,CACHJ,aADG,EACY,KAAKH,UAAL,GAAkBI,aAAlB,CAAgCF,MAAhC,CADZ,EAEHD,SAAS,CAACF,SAAV,GAAsBK,aAAtB,CAAoCF,MAApC,CAFG,EAE0CG,eAF1C,CAAP;AAIH,OALD,MAKO;AACHC,QAAAA,IAAI,GAAG,KAAKE,gBAAL,CAAsBL,aAAtB,EAAqCE,eAArC,CAAP;AACH;;AAED,aAAOC,IAAP;AACH;;;qCAEgBG,E,EAAIC,E,EAAI;AACrB,aAAO1B,IAAI,CAAC2B,UAAL,CAAgBF,EAAhB,EAAoBC,EAApB,CAAP;AACH;;;sCAEiBD,E,EAAIG,G,EAAKC,G,EAAKH,E,EAAI;AAChC,UAAMd,MAAM,GAAG,CAAEa,EAAF,EAAMG,GAAN,EAAWC,GAAX,EAAgBH,EAAhB,CAAf;;AACA,UAAMI,SAAS,GAAG,KAAKC,iBAAL,CAAuBnB,MAAvB,EAA+B,GAA/B,CAAlB;;AACA,UAAMoB,SAAS,GAAG,KAAKD,iBAAL,CAAuBnB,MAAvB,EAA+B,GAA/B,CAAlB;;AACA,UAAMqB,OAAO,GAAGC,WAAW,CAAC,CAAEJ,SAAS,CAACK,GAAZ,EAAiBL,SAAS,CAACM,GAA3B,EAAgCX,EAAE,CAACY,CAAnC,EAAsCX,EAAE,CAACW,CAAzC,CAAD,CAA3B;AACA,UAAMC,OAAO,GAAGJ,WAAW,CAAC,CAAEF,SAAS,CAACG,GAAZ,EAAiBH,SAAS,CAACI,GAA3B,EAAgCX,EAAE,CAACc,CAAnC,EAAsCb,EAAE,CAACa,CAAzC,CAAD,CAA3B;AAEA,aAAOvC,IAAI,CAAC2B,UAAL,CAAgB,IAAI1B,KAAJ,CAAUgC,OAAO,CAACE,GAAlB,EAAuBG,OAAO,CAACH,GAA/B,CAAhB,EAAqD,IAAIlC,KAAJ,CAAUgC,OAAO,CAACG,GAAlB,EAAuBE,OAAO,CAACF,GAA/B,CAArD,CAAP;AACH;;;sCAEiBxB,M,EAAQ4B,K,EAAO;AAC7B,UAAMC,QAAQ,GAAG,KAAKC,cAAL,CACb9B,MAAM,CAAC,CAAD,CAAN,CAAU4B,KAAV,CADa,EACK5B,MAAM,CAAC,CAAD,CAAN,CAAU4B,KAAV,CADL,EAEb5B,MAAM,CAAC,CAAD,CAAN,CAAU4B,KAAV,CAFa,EAEK5B,MAAM,CAAC,CAAD,CAAN,CAAU4B,KAAV,CAFL,CAAjB;;AAKA,aAAO;AACHL,QAAAA,GAAG,EAAE5B,gBAAgB,CAACkC,QAAQ,CAACN,GAAV,EAAeK,KAAf,EAAsB5B,MAAtB,CADlB;AAEHwB,QAAAA,GAAG,EAAE7B,gBAAgB,CAACkC,QAAQ,CAACL,GAAV,EAAeI,KAAf,EAAsB5B,MAAtB;AAFlB,OAAP;AAIH;;;mCAEc+B,E,EAAIC,E,EAAIC,E,EAAIC,E,EAAI;AAC3B,UAAMC,CAAC,GAAGJ,EAAE,GAAG,IAAIC,EAAT,GAAc,IAAIC,EAAlB,GAAuBC,EAAjC;AACA,UAAME,CAAC,GAAG,CAAE,CAAF,IAAOL,EAAE,GAAG,IAAIC,EAAT,GAAcC,EAArB,CAAV;AACA,UAAMI,CAAC,GAAGN,EAAE,GAAGC,EAAf;AACA,UAAMM,IAAI,GAAGC,IAAI,CAACD,IAAL,CAAUF,CAAC,GAAGA,CAAJ,GAAQ,IAAID,CAAJ,GAAQE,CAA1B,CAAb;AACA,UAAIG,EAAE,GAAG,CAAT;AACA,UAAIC,EAAE,GAAG,CAAT;;AAEA,UAAIN,CAAC,KAAK,CAAV,EAAa;AACT,YAAIC,CAAC,KAAK,CAAV,EAAa;AACTI,UAAAA,EAAE,GAAGC,EAAE,GAAG,CAACJ,CAAD,GAAKD,CAAf;AACH;AACJ,OAJD,MAIO,IAAI,CAACM,KAAK,CAACJ,IAAD,CAAV,EAAkB;AACrBE,QAAAA,EAAE,GAAG,CAAC,CAAEJ,CAAF,GAAME,IAAP,KAAgB,IAAIH,CAApB,CAAL;AACAM,QAAAA,EAAE,GAAG,CAAC,CAAEL,CAAF,GAAME,IAAP,KAAgB,IAAIH,CAApB,CAAL;AACH;;AAED,UAAIZ,GAAG,GAAGgB,IAAI,CAACf,GAAL,CAASe,IAAI,CAAChB,GAAL,CAASiB,EAAT,EAAaC,EAAb,CAAT,EAA2B,CAA3B,CAAV;;AACA,UAAIlB,GAAG,GAAG,CAAN,IAAWA,GAAG,GAAG,CAArB,EAAwB;AACpBA,QAAAA,GAAG,GAAG,CAAN;AACH;;AAED,UAAIC,GAAG,GAAGe,IAAI,CAAChB,GAAL,CAASgB,IAAI,CAACf,GAAL,CAASgB,EAAT,EAAaC,EAAb,CAAT,EAA2B,CAA3B,CAAV;;AACA,UAAIjB,GAAG,GAAG,CAAN,IAAWA,GAAG,GAAG,CAArB,EAAwB;AACpBA,QAAAA,GAAG,GAAG,CAAN;AACH;;AAED,aAAO;AACHD,QAAAA,GAAG,EAAEA,GADF;AAEHC,QAAAA,GAAG,EAAEA;AAFF,OAAP;AAIH;;;qCAEgBmB,O,EAASC,K,EAAO;AAC7B,UAAIC,kBAAJ;;AACA,UAAI,KAAKzC,UAAL,MAAqBuC,OAAO,CAACxC,SAAR,EAAzB,EAA8C;AAC1C0C,QAAAA,kBAAkB,GAAGhD,uBAAuB,CAAC,CAAE,KAAKK,MAAL,EAAF,EAAiB,KAAKE,UAAL,EAAjB,EAAoCuC,OAAO,CAACxC,SAAR,EAApC,EAAyDwC,OAAO,CAACzC,MAAR,EAAzD,CAAD,EAA8E0C,KAA9E,EAAqF,KAAKE,MAAL,CAAYH,OAAZ,CAArF,CAA5C;AACH,OAFD,MAEO;AACHE,QAAAA,kBAAkB,GAAG/C,sBAAsB,CAAC,KAAKI,MAAL,EAAD,EAAgByC,OAAO,CAACzC,MAAR,EAAhB,EAAkC0C,KAAlC,CAA3C;AACH;;AACD,aAAOC,kBAAP;AACH;;;iCAEYF,O,EAASC,K,EAAOG,K,EAAOC,U,EAAY;AAC5C,UAAMC,IAAI,GAAG,KAAKH,MAAL,CAAYH,OAAZ,EAAqBO,MAArB,CAA4BH,KAA5B,EAAmCA,KAAnC,CAAb;;AACA,UAAIE,IAAI,CAACE,aAAL,CAAmBP,KAAnB,CAAJ,EAA+B;AAC3B,YAAM/B,EAAE,GAAG,KAAKX,MAAL,EAAX;AACA,YAAMY,EAAE,GAAG,KAAKV,UAAL,EAAX;AACA,YAAMgD,EAAE,GAAGT,OAAO,CAACxC,SAAR,EAAX;AACA,YAAMkD,EAAE,GAAGV,OAAO,CAACzC,MAAR,EAAX;;AAEA,YAAI8C,UAAU,KAAK,OAAf,IAA0BnC,EAAE,CAACyC,UAAH,CAAcV,KAAd,KAAwBG,KAAtD,EAA6D;AACzD,iBAAO,CAACrD,eAAe,CAACmB,EAAD,EAAKC,EAAL,EAAS8B,KAAT,CAAvB;AACH,SAFD,MAEO,IAAII,UAAU,KAAK,KAAf,IAAwBK,EAAE,CAACC,UAAH,CAAcV,KAAd,KAAwBG,KAApD,EAA2D;AAC9D,iBAAO,CAACrD,eAAe,CAAC2D,EAAD,EAAKD,EAAL,EAASR,KAAT,CAAvB;AACH,SAV0B,CAY3B;;;AACA,YAAM5C,OAAM,GAAG,CAAEa,EAAF,EAAMC,EAAN,EAAUsC,EAAV,EAAcC,EAAd,CAAf;;AACA,YAAIzD,eAAe,CAACI,OAAD,EAAS4C,KAAT,EAAgB,GAAhB,EAAqB,GAArB,EAA0BG,KAA1B,CAAf,IAAmDnD,eAAe,CAACI,OAAD,EAAS4C,KAAT,EAAgB,GAAhB,EAAqB,GAArB,EAA0BG,KAA1B,CAAtE,EAAwG;AACpG,iBAAO,IAAP;AACH;;AACD,YAAMQ,QAAQ,GAAGjE,SAAS,GAAGkE,MAAZ,CAAmB,EAAnB,EAAuBZ,KAAvB,CAAjB;AACA,YAAMa,aAAa,GAAG,CAAE5C,EAAE,CAACL,aAAH,CAAiB+C,QAAjB,CAAF,EAA8BzC,EAAE,CAACN,aAAH,CAAiB+C,QAAjB,CAA9B,EAA0DH,EAAE,CAAC5C,aAAH,CAAiB+C,QAAjB,CAA1D,EAAsFF,EAAE,CAAC7C,aAAH,CAAiB+C,QAAjB,CAAtF,CAAtB;AACA,eAAO3D,eAAe,CAAC6D,aAAD,EAAgBb,KAAhB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiCG,KAAjC,CAAf,IAA0DnD,eAAe,CAAC6D,aAAD,EAAgBb,KAAhB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiCG,KAAjC,CAAhF;AACH;AACJ;;;gCAEWJ,O,EAASC,K,EAAOG,K,EAAO;AAC/B,UAAMlC,EAAE,GAAG,KAAKX,MAAL,EAAX;AACA,UAAMY,EAAE,GAAG6B,OAAO,CAACzC,MAAR,EAAX;AACA,UAAMwD,KAAK,GAAGnE,GAAG,CAACgD,IAAI,CAACoB,KAAL,CAAW7C,EAAE,CAACa,CAAH,GAAOd,EAAE,CAACc,CAArB,EAAwBb,EAAE,CAACW,CAAH,GAAOZ,EAAE,CAACY,CAAlC,CAAD,CAAjB;AACA,UAAMf,IAAI,GAAG,IAAItB,IAAJ,CAAS,CAAEyB,EAAE,CAACY,CAAL,EAAQZ,EAAE,CAACc,CAAH,GAAOoB,KAAK,GAAG,CAAvB,CAAT,EAAqC,CAAElC,EAAE,CAACyC,UAAH,CAAcxC,EAAd,CAAF,EAAqBiC,KAArB,CAArC,CAAb;AACA,aAAOrC,IAAI,CAACyC,aAAL,CAAmBP,KAAK,CAACpC,aAAN,CAAoBlB,SAAS,GAAGkE,MAAZ,CAAmB,CAACE,KAApB,EAA2B7C,EAA3B,CAApB,CAAnB,CAAP;AACH;;;gCAEW8B,O,EAASC,K,EAAOG,K,EAAOC,U,EAAY;AAC3C,UAAIY,QAAJ;;AACA,UAAI,KAAKxD,UAAL,MAAqBuC,OAAO,CAACxC,SAAR,EAAzB,EAA8C;AAC1CyD,QAAAA,QAAQ,GAAG,KAAKC,YAAL,CAAkBlB,OAAlB,EAA2BC,KAA3B,EAAkCG,KAAK,GAAG,CAA1C,EAA6CC,UAA7C,CAAX;AACH,OAFD,MAEO;AACHY,QAAAA,QAAQ,GAAG,KAAKE,WAAL,CAAiBnB,OAAjB,EAA0BC,KAA1B,EAAiCG,KAAjC,CAAX;AACH;;AACD,aAAOa,QAAP;AACH;;;;EAxIiB7D,UAAU,CAACZ,YAAD,EAAea,MAAf,C;;AA2IhC,SAASsB,WAAT,CAAqByC,GAArB,EAA0B;AACtB,MAAIC,MAAM,GAAGD,GAAG,CAACC,MAAjB;AACA,MAAIzC,GAAG,GAAG9B,OAAV;AACA,MAAI+B,GAAG,GAAGhC,OAAV;;AAEA,OAAK,IAAIyE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAkC;AAC9BzC,IAAAA,GAAG,GAAGe,IAAI,CAACf,GAAL,CAASA,GAAT,EAAcuC,GAAG,CAACE,CAAD,CAAjB,CAAN;AACA1C,IAAAA,GAAG,GAAGgB,IAAI,CAAChB,GAAL,CAASA,GAAT,EAAcwC,GAAG,CAACE,CAAD,CAAjB,CAAN;AACH;;AAED,SAAO;AACH1C,IAAAA,GAAG,EAAEA,GADF;AAEHC,IAAAA,GAAG,EAAEA;AAFF,GAAP;AAIH;;AAED,eAAevB,OAAf","sourcesContent":["import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\n\n\nconst points = [ \"anchor\", \"controlIn\", \"controlOut\" ];\n\nclass Segment extends withPoints(HasObservers, points) {\n    constructor(anchor, controlIn, controlOut) {\n        super();\n\n        this.anchor(anchor || new Point());\n        this.controlIn(controlIn);\n        this.controlOut(controlOut);\n    }\n\n    bboxTo(toSegment, matrix) {\n        const segmentAnchor = this.anchor().transformCopy(matrix);\n        const toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n        let rect;\n\n        if (this.controlOut() && toSegment.controlIn()) {\n            rect = this._curveBoundingBox(\n                segmentAnchor, this.controlOut().transformCopy(matrix),\n                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\n            );\n        } else {\n            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n        }\n\n        return rect;\n    }\n\n    _lineBoundingBox(p1, p2) {\n        return Rect.fromPoints(p1, p2);\n    }\n\n    _curveBoundingBox(p1, cp1, cp2, p2) {\n        const points = [ p1, cp1, cp2, p2 ];\n        const extremesX = this._curveExtremesFor(points, \"x\");\n        const extremesY = this._curveExtremesFor(points, \"y\");\n        const xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\n        const yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\n\n        return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n    }\n\n    _curveExtremesFor(points, field) {\n        const extremes = this._curveExtremes(\n            points[0][field], points[1][field],\n            points[2][field], points[3][field]\n        );\n\n        return {\n            min: calculateCurveAt(extremes.min, field, points),\n            max: calculateCurveAt(extremes.max, field, points)\n        };\n    }\n\n    _curveExtremes(x1, x2, x3, x4) {\n        const a = x1 - 3 * x2 + 3 * x3 - x4;\n        const b = - 2 * (x1 - 2 * x2 + x3);\n        const c = x1 - x2;\n        const sqrt = Math.sqrt(b * b - 4 * a * c);\n        let t1 = 0;\n        let t2 = 1;\n\n        if (a === 0) {\n            if (b !== 0) {\n                t1 = t2 = -c / b;\n            }\n        } else if (!isNaN(sqrt)) {\n            t1 = (- b + sqrt) / (2 * a);\n            t2 = (- b - sqrt) / (2 * a);\n        }\n\n        let min = Math.max(Math.min(t1, t2), 0);\n        if (min < 0 || min > 1) {\n            min = 0;\n        }\n\n        let max = Math.min(Math.max(t1, t2), 1);\n        if (max > 1 || max < 0) {\n            max = 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    _intersectionsTo(segment, point) {\n        let intersectionsCount;\n        if (this.controlOut() && segment.controlIn()) {\n            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\n        } else {\n            intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n        }\n        return intersectionsCount;\n    }\n\n    _isOnCurveTo(segment, point, width, endSegment) {\n        const bbox = this.bboxTo(segment).expand(width, width);\n        if (bbox.containsPoint(point)) {\n            const p1 = this.anchor();\n            const p2 = this.controlOut();\n            const p3 = segment.controlIn();\n            const p4 = segment.anchor();\n\n            if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p1, p2, point);\n            } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p4, p3, point);\n            }\n\n            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n            const points = [ p1, p2, p3, p4 ];\n            if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n                return true;\n            }\n            const rotation = transform().rotate(45, point);\n            const rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\n            return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n        }\n    }\n\n    _isOnLineTo(segment, point, width) {\n        const p1 = this.anchor();\n        const p2 = segment.anchor();\n        const angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n        const rect = new Rect([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\n        return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n    }\n\n    _isOnPathTo(segment, point, width, endSegment) {\n        let isOnPath;\n        if (this.controlOut() && segment.controlIn()) {\n            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n        } else {\n            isOnPath = this._isOnLineTo(segment, point, width);\n        }\n        return isOnPath;\n    }\n}\n\nfunction arrayLimits(arr) {\n    let length = arr.length;\n    let min = MAX_NUM;\n    let max = MIN_NUM;\n\n    for (let i = 0; i < length; i ++) {\n        max = Math.max(max, arr[i]);\n        min = Math.min(min, arr[i]);\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nexport default Segment;\n"]},"metadata":{},"sourceType":"module"}