{"ast":null,"code":"import _defineProperty from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\n\nvar toQueryString = function toQueryString(values) {\n  return values.reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return [].concat(_toConsumableArray(acc), [\"\".concat(key, \"=\").concat(value)]);\n  }, []);\n};\n\nvar toObject = function toObject(values) {\n  return values.reduce(function (acc, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        key = _ref4[0],\n        value = _ref4[1];\n\n    return Object.assign({}, acc, _defineProperty({}, key, value));\n  }, {});\n};\n\nvar pairwise = function pairwise(key) {\n  return function (value) {\n    return [key, value];\n  };\n};\n\nvar empty = function empty() {\n  return null;\n};\n\nvar isNotEmptyArray = function isNotEmptyArray(value) {\n  return isPresent(value) && isArray(value) && value.length > 0;\n};\n\nvar has = function has(accessor) {\n  return function (value) {\n    return isPresent(accessor(value));\n  };\n};\n\nvar isNotEmpty = function isNotEmpty(accessor) {\n  return function (value) {\n    return isNotEmptyArray(accessor(value));\n  };\n};\n\nvar runOrEmpty = function runOrEmpty(predicate, fn) {\n  return ifElse(predicate, fn, empty);\n};\n\nvar calcPage = function calcPage(_ref5) {\n  var skip = _ref5.skip,\n      take = _ref5.take;\n  return Math.floor((skip || 0) / take) + 1;\n};\n\nvar formatDescriptors = function formatDescriptors(accessor, formatter) {\n  return function (state) {\n    return accessor(state).map(formatter).join(\"~\");\n  };\n};\n\nvar removeAfter = function removeAfter(what) {\n  return function (str) {\n    return str.slice(0, str.indexOf(what));\n  };\n};\n\nvar replace = function replace(patterns) {\n  return compose.apply(void 0, _toConsumableArray(patterns.map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        left = _ref7[0],\n        right = _ref7[1];\n\n    return function (s) {\n      return s.replace(new RegExp(left, \"g\"), right);\n    };\n  })));\n};\n\nvar sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nvar removeAfterDot = removeAfter(\".\");\n\nvar directionFormatter = function directionFormatter(_ref8) {\n  var field = _ref8.field,\n      _ref8$dir = _ref8.dir,\n      dir = _ref8$dir === void 0 ? \"asc\" : _ref8$dir;\n  return \"\".concat(field, \"-\").concat(dir);\n};\n\nvar aggregateFormatter = function aggregateFormatter(_ref9) {\n  var field = _ref9.field,\n      aggregate = _ref9.aggregate;\n  return \"\".concat(field, \"-\").concat(aggregate);\n};\n\nvar take = getter(\"take\");\nvar aggregates = getter(\"aggregates\");\nvar skip = getter(\"skip\");\nvar group = getter(\"group\");\nvar sort = getter(\"sort\", true);\nvar formatSort = formatDescriptors(sort, directionFormatter);\nvar formatGroup = formatDescriptors(group, directionFormatter);\nvar formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\n\nvar prefixDateValue = function prefixDateValue(value) {\n  return \"datetime'\".concat(value, \"'\");\n};\n\nvar formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\n\nvar formatDate = function formatDate(_ref10) {\n  var field = _ref10.field,\n      value = _ref10.value,\n      ignoreCase = _ref10.ignoreCase,\n      operator = _ref10.operator;\n  return {\n    value: formatDateValue(value),\n    field: field,\n    ignoreCase: ignoreCase,\n    operator: operator\n  };\n};\n\nvar normalizeSort = function normalizeSort(state) {\n  return Object.assign({}, state, {\n    sort: (sort(state) || []).filter(function (_ref11) {\n      var dir = _ref11.dir;\n      return isNotNullOrEmptyString(dir);\n    })\n  });\n};\n\nvar transformSkip = compose(pairwise('page'), calcPage);\nvar transformTake = compose(pairwise('pageSize'), take);\nvar transformGroup = compose(pairwise('group'), formatGroup);\nvar transformSort = compose(pairwise('sort'), formatSort);\nvar transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nvar serializePage = runOrEmpty(has(skip), transformSkip);\nvar serializePageSize = runOrEmpty(has(take), transformTake);\nvar serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nvar serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nvar serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\n\nvar hasField = function hasField(_ref12) {\n  var field = _ref12.field;\n  return isNotNullOrEmptyString(field);\n};\n\nvar filterFormatter = function filterFormatter(_ref13) {\n  var field = _ref13.field,\n      operator = _ref13.operator,\n      value = _ref13.value;\n  return \"\".concat(field, \"~\").concat(operator, \"~\").concat(value);\n};\n\nvar dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\n\nvar typedFormatter = function typedFormatter(encode) {\n  return runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter));\n};\n\nvar join = function join(_ref14) {\n  var logic = _ref14.logic;\n  return \"~\".concat(logic, \"~\");\n};\n\nvar serialize = function serialize(encode) {\n  return serializeFilters(function (filter) {\n    return ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter);\n  }, join);\n};\n\nvar serializeFilter = function serializeFilter(_ref15, encode) {\n  var filter = _ref15.filter;\n\n  if (filter && filter.filters) {\n    var filters = serialize(encode)(filter);\n\n    if (filters.length) {\n      return ['filter', filters];\n    }\n  }\n\n  return null;\n};\n\nvar rules = function rules(state) {\n  var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return function (key) {\n    return {\n      \"aggregates\": serializeAggregates(state),\n      \"filter\": serializeFilter(state, encode),\n      \"group\": serializeGroup(state),\n      \"skip\": serializePage(state),\n      \"sort\": serializeSort(state),\n      \"take\": serializePageSize(state)\n    }[key];\n  };\n};\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {string} - The serialized state.\n *\n * @example\n * {% platform_content angular %}\n * ```ts-no-run\n *  import {\n *      toDataSourceRequestString,\n *      translateDataSourceResultGroups,\n *      translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class Service {\n *  private BASE_URL: string = '...';\n *\n *  constructor(private http: Http) { }\n *\n *  // Omitted for brevity...\n *\n *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n *   const hasGroups = state.group && state.group.length;\n *\n *   return this.http\n *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n *       .map(response => response.json())\n *       .map(({Data, Total, AggregateResults}) => // process the response\n *           (<GridDataResult>{\n *               //if there are groups convert them to compatible format\n *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *               total: Total,\n *               // convert the aggregates if such exists\n *               aggregateResult: translateAggregateResults(AggregateResults)\n *           })\n *       );\n *  }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx-no-run\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\n\n\nexport var toDataSourceRequestString = function toDataSourceRequestString(state) {\n  return toQueryString(Object.keys(state).map(rules(state)).filter(isPresent)).join('&');\n};\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {any} - The serialized state.\n */\n\nexport var toDataSourceRequest = function toDataSourceRequest(state) {\n  return toObject(Object.keys(state).map(rules(state, false)).filter(isPresent));\n};","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@progress/kendo-data-query/dist/es2015/mvc/operators.js"],"names":["isCompositeFilterDescriptor","isPresent","isNotNullOrEmptyString","isArray","getter","compose","ifElse","identity","isStringValue","isDateValue","quote","serializeFilters","toUTC","encodeValue","toQueryString","values","reduce","acc","key","value","toObject","Object","assign","pairwise","empty","isNotEmptyArray","length","has","accessor","isNotEmpty","runOrEmpty","predicate","fn","calcPage","skip","take","Math","floor","formatDescriptors","formatter","state","map","join","removeAfter","what","str","slice","indexOf","replace","patterns","left","right","s","RegExp","sanitizeDateLiterals","removeAfterDot","directionFormatter","field","dir","aggregateFormatter","aggregate","aggregates","group","sort","formatSort","formatGroup","formatAggregates","prefixDateValue","formatDateValue","JSON","stringify","formatDate","ignoreCase","operator","normalizeSort","filter","transformSkip","transformTake","transformGroup","transformSort","transformAggregates","serializePage","serializePageSize","serializeGroup","serializeAggregates","serializeSort","hasField","filterFormatter","dateFormatter","typedFormatter","encode","logic","serialize","serializeFilter","filters","rules","toDataSourceRequestString","keys","toDataSourceRequest"],"mappings":"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","sourcesContent":["import { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\nconst toQueryString = values => values.reduce((acc, [key, value]) => [...acc, `${key}=${value}`], []);\nconst toObject = values => values.reduce((acc, [key, value]) => (Object.assign({}, acc, { [key]: value })), {});\nconst pairwise = key => value => [key, value];\nconst empty = () => null;\nconst isNotEmptyArray = value => isPresent(value) && isArray(value) && value.length > 0;\nconst has = accessor => value => isPresent(accessor(value));\nconst isNotEmpty = accessor => value => isNotEmptyArray(accessor(value));\nconst runOrEmpty = (predicate, fn) => ifElse(predicate, fn, empty);\nconst calcPage = ({ skip, take }) => Math.floor((skip || 0) / take) + 1;\nconst formatDescriptors = (accessor, formatter) => state => (accessor(state).map(formatter).join(\"~\"));\nconst removeAfter = (what) => (str) => str.slice(0, str.indexOf(what));\nconst replace = (patterns) => compose(...patterns.map(([left, right]) => (s) => s.replace(new RegExp(left, \"g\"), right)));\nconst sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nconst removeAfterDot = removeAfter(\".\");\nconst directionFormatter = ({ field, dir = \"asc\" }) => `${field}-${dir}`;\nconst aggregateFormatter = ({ field, aggregate }) => `${field}-${aggregate}`;\nconst take = getter(\"take\");\nconst aggregates = getter(\"aggregates\");\nconst skip = getter(\"skip\");\nconst group = getter(\"group\");\nconst sort = getter(\"sort\", true);\nconst formatSort = formatDescriptors(sort, directionFormatter);\nconst formatGroup = formatDescriptors(group, directionFormatter);\nconst formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\nconst prefixDateValue = value => `datetime'${value}'`;\nconst formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\nconst formatDate = ({ field, value, ignoreCase, operator }) => ({\n    value: formatDateValue(value),\n    field,\n    ignoreCase,\n    operator\n});\nconst normalizeSort = (state) => Object.assign({}, state, {\n    sort: (sort(state) || []).filter(({ dir }) => isNotNullOrEmptyString(dir))\n});\nconst transformSkip = compose(pairwise('page'), calcPage);\nconst transformTake = compose(pairwise('pageSize'), take);\nconst transformGroup = compose(pairwise('group'), formatGroup);\nconst transformSort = compose(pairwise('sort'), formatSort);\nconst transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nconst serializePage = runOrEmpty(has(skip), transformSkip);\nconst serializePageSize = runOrEmpty(has(take), transformTake);\nconst serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nconst serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nconst serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\nconst hasField = ({ field }) => isNotNullOrEmptyString(field);\nconst filterFormatter = ({ field, operator, value }) => `${field}~${operator}~${value}`;\nconst dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\nconst typedFormatter = encode => runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter));\nconst join = ({ logic }) => `~${logic}~`;\nconst serialize = encode => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter), join);\nconst serializeFilter = ({ filter }, encode) => {\n    if (filter && filter.filters) {\n        const filters = serialize(encode)(filter);\n        if (filters.length) {\n            return ['filter', filters];\n        }\n    }\n    return null;\n};\nconst rules = (state, encode = true) => key => ({\n    \"aggregates\": serializeAggregates(state),\n    \"filter\": serializeFilter(state, encode),\n    \"group\": serializeGroup(state),\n    \"skip\": serializePage(state),\n    \"sort\": serializeSort(state),\n    \"take\": serializePageSize(state)\n}[key]);\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {string} - The serialized state.\n *\n * @example\n * {% platform_content angular %}\n * ```ts-no-run\n *  import {\n *      toDataSourceRequestString,\n *      translateDataSourceResultGroups,\n *      translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class Service {\n *  private BASE_URL: string = '...';\n *\n *  constructor(private http: Http) { }\n *\n *  // Omitted for brevity...\n *\n *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n *   const hasGroups = state.group && state.group.length;\n *\n *   return this.http\n *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n *       .map(response => response.json())\n *       .map(({Data, Total, AggregateResults}) => // process the response\n *           (<GridDataResult>{\n *               //if there are groups convert them to compatible format\n *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *               total: Total,\n *               // convert the aggregates if such exists\n *               aggregateResult: translateAggregateResults(AggregateResults)\n *           })\n *       );\n *  }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx-no-run\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\nexport const toDataSourceRequestString = (state) => (toQueryString(Object.keys(state)\n    .map(rules(state))\n    .filter(isPresent)).join('&'));\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {any} - The serialized state.\n */\nexport const toDataSourceRequest = (state) => (toObject(Object.keys(state)\n    .map(rules(state, false))\n    .filter(isPresent)));\n"]},"metadata":{},"sourceType":"module"}