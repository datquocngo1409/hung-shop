{"ast":null,"code":"import Point from '../geometry/point';\nimport { last } from '../util';\nvar ShapeMap = {\n  l: function l(path, options) {\n    var parameters = options.parameters,\n        position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 2) {\n      var point = new Point(parameters[i], parameters[i + 1]);\n\n      if (options.isRelative) {\n        point.translateWith(position);\n      }\n\n      path.lineTo(point.x, point.y);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  c: function c(path, options) {\n    var parameters = options.parameters,\n        position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 6) {\n      var controlOut = new Point(parameters[i], parameters[i + 1]);\n      var controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n      var point = new Point(parameters[i + 4], parameters[i + 5]);\n\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        controlOut.translateWith(position);\n        point.translateWith(position);\n      }\n\n      path.curveTo(controlOut, controlIn, point);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  v: function v(path, options) {\n    var value = options.isRelative ? 0 : options.position.x;\n    toLineParamaters(options.parameters, true, value);\n    this.l(path, options);\n  },\n  h: function h(path, options) {\n    var value = options.isRelative ? 0 : options.position.y;\n    toLineParamaters(options.parameters, false, value);\n    this.l(path, options);\n  },\n  a: function a(path, options) {\n    var parameters = options.parameters,\n        position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 7) {\n      var radiusX = parameters[i];\n      var radiusY = parameters[i + 1];\n      var rotation = parameters[i + 2];\n      var largeArc = parameters[i + 3];\n      var swipe = parameters[i + 4];\n      var endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n\n      if (position.x !== endPoint.x || position.y !== endPoint.y) {\n        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n        position.x = endPoint.x;\n        position.y = endPoint.y;\n      }\n    }\n  },\n  s: function s(path, options) {\n    var parameters = options.parameters,\n        position = options.position,\n        previousCommand = options.previousCommand;\n    var lastControlIn;\n\n    if (previousCommand === \"s\" || previousCommand === \"c\") {\n      lastControlIn = last(last(path.paths).segments).controlIn();\n    }\n\n    for (var i = 0; i < parameters.length; i += 4) {\n      var controlIn = new Point(parameters[i], parameters[i + 1]);\n      var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n      var controlOut = void 0;\n\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        endPoint.translateWith(position);\n      }\n\n      if (lastControlIn) {\n        controlOut = reflectionPoint(lastControlIn, position);\n      } else {\n        controlOut = position.clone();\n      }\n\n      lastControlIn = controlIn;\n      path.curveTo(controlOut, controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  q: function q(path, options) {\n    var parameters = options.parameters,\n        position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 4) {\n      var controlPoint = new Point(parameters[i], parameters[i + 1]);\n      var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\n      if (options.isRelative) {\n        controlPoint.translateWith(position);\n        endPoint.translateWith(position);\n      }\n\n      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  t: function t(path, options) {\n    var parameters = options.parameters,\n        position = options.position,\n        previousCommand = options.previousCommand;\n    var controlPoint;\n\n    if (previousCommand === \"q\" || previousCommand === \"t\") {\n      var lastSegment = last(last(path.paths).segments);\n      controlPoint = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);\n    }\n\n    for (var i = 0; i < parameters.length; i += 2) {\n      var endPoint = new Point(parameters[i], parameters[i + 1]);\n\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n\n      if (controlPoint) {\n        controlPoint = reflectionPoint(controlPoint, position);\n      } else {\n        controlPoint = position.clone();\n      }\n\n      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  }\n};\n\nfunction toLineParamaters(parameters, isVertical, value) {\n  var insertPosition = isVertical ? 0 : 1;\n\n  for (var i = 0; i < parameters.length; i += 2) {\n    parameters.splice(i + insertPosition, 0, value);\n  }\n}\n\nfunction reflectionPoint(point, center) {\n  if (point && center) {\n    return center.scaleCopy(2).translate(-point.x, -point.y);\n  }\n}\n\nvar third = 1 / 3;\n\nfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n  var scaledPoint = controlPoint.clone().scale(2 / 3);\n  return {\n    controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n  };\n}\n\nexport default ShapeMap;","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/parsing/shape-map.js"],"names":["Point","last","ShapeMap","l","path","options","parameters","position","i","length","point","isRelative","translateWith","lineTo","x","y","c","controlOut","controlIn","curveTo","v","value","toLineParamaters","h","a","radiusX","radiusY","rotation","largeArc","swipe","endPoint","arcTo","s","previousCommand","lastControlIn","paths","segments","reflectionPoint","clone","q","controlPoint","cubicControlPoints","quadraticToCubicControlPoints","t","lastSegment","scaleCopy","scale","isVertical","insertPosition","splice","center","translate","third","scaledPoint"],"mappings":"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","sourcesContent":["import Point from '../geometry/point';\nimport { last } from '../util';\n\nconst ShapeMap = {\n    l: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 2) {\n            let point = new Point(parameters[i], parameters[i + 1]);\n\n            if (options.isRelative) {\n                point.translateWith(position);\n            }\n\n            path.lineTo(point.x, point.y);\n\n            position.x = point.x;\n            position.y = point.y;\n        }\n    },\n\n    c: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 6) {\n            let controlOut = new Point(parameters[i], parameters[i + 1]);\n            let controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n            let point = new Point(parameters[i + 4], parameters[i + 5]);\n            if (options.isRelative) {\n                controlIn.translateWith(position);\n                controlOut.translateWith(position);\n                point.translateWith(position);\n            }\n\n            path.curveTo(controlOut, controlIn, point);\n\n            position.x = point.x;\n            position.y = point.y;\n        }\n    },\n\n    v: function(path, options) {\n        const value = options.isRelative ? 0 : options.position.x;\n\n        toLineParamaters(options.parameters, true, value);\n        this.l(path, options);\n    },\n\n    h: function(path, options) {\n        const value = options.isRelative ? 0 : options.position.y;\n\n        toLineParamaters(options.parameters, false, value);\n        this.l(path, options);\n    },\n\n    a: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 7) {\n            const radiusX = parameters[i];\n            const radiusY = parameters[i + 1];\n            const rotation = parameters[i + 2];\n            const largeArc = parameters[i + 3];\n            const swipe = parameters[i + 4];\n            const endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n\n            if (options.isRelative) {\n                endPoint.translateWith(position);\n            }\n            if (position.x !== endPoint.x || position.y !== endPoint.y) {\n                path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n\n                position.x = endPoint.x;\n                position.y = endPoint.y;\n            }\n        }\n    },\n\n    s: function(path, options) {\n        const { parameters, position, previousCommand } = options;\n        let lastControlIn;\n\n        if (previousCommand === \"s\" || previousCommand === \"c\") {\n            lastControlIn = last(last(path.paths).segments).controlIn();\n        }\n\n        for (let i = 0; i < parameters.length; i += 4) {\n            let controlIn = new Point(parameters[i], parameters[i + 1]);\n            let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n            let controlOut;\n\n            if (options.isRelative) {\n                controlIn.translateWith(position);\n                endPoint.translateWith(position);\n            }\n\n            if (lastControlIn) {\n                controlOut = reflectionPoint(lastControlIn, position);\n            } else {\n                controlOut = position.clone();\n            }\n\n            lastControlIn = controlIn;\n\n            path.curveTo(controlOut, controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    },\n\n    q: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 4) {\n            let controlPoint = new Point(parameters[i], parameters[i + 1]);\n            let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\n            if (options.isRelative) {\n                controlPoint.translateWith(position);\n                endPoint.translateWith(position);\n            }\n\n            let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    },\n\n    t: function(path, options) {\n        const { parameters, position, previousCommand } = options;\n        let controlPoint;\n\n        if (previousCommand === \"q\" || previousCommand === \"t\") {\n            let lastSegment = last(last(path.paths).segments);\n            controlPoint = lastSegment.controlIn().clone()\n                .translateWith(position.scaleCopy(-1 / 3))\n                .scale(3 / 2);\n        }\n\n        for (let i = 0; i < parameters.length; i += 2) {\n            let endPoint = new Point(parameters[i], parameters[i + 1]);\n            if (options.isRelative) {\n                endPoint.translateWith(position);\n            }\n\n            if (controlPoint) {\n                controlPoint = reflectionPoint(controlPoint, position);\n            } else {\n                controlPoint = position.clone();\n            }\n\n            let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    }\n};\n\nfunction toLineParamaters(parameters, isVertical, value) {\n    const insertPosition = isVertical ? 0 : 1;\n\n    for (let i = 0; i < parameters.length; i += 2) {\n        parameters.splice(i + insertPosition, 0, value);\n    }\n}\n\nfunction reflectionPoint(point, center) {\n    if (point && center) {\n        return center.scaleCopy(2).translate(-point.x, -point.y);\n    }\n}\n\nconst third = 1 / 3;\n\nfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n    const scaledPoint = controlPoint.clone().scale(2 / 3);\n    return {\n        controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n        controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n    };\n}\n\nexport default ShapeMap;"]},"metadata":{},"sourceType":"module"}