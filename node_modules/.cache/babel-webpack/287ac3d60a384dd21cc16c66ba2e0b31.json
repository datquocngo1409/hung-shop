{"ast":null,"code":"import { timezones } from './timezones';\nimport { ruleToDate } from './rule-to-date';\nvar CURRENT_UTC_TIME = new Date().getTime();\n/**\n * @hidden\n *\n * A function that finds zone rules which become applicable after a specific time.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n * @param utcTime - The UTC time boundary for a zone rule. Defaults to the current UTC time.\n *\n * @return - Returns a zone rule for the specific zone name.\n *\n * @example\n * ```ts-no-run\n * findZone('Europe/Sofia'); //[-120,\"EU\",\"EE%sT\",null]\n * ```\n */\n\nexport var findRule = function findRule(zoneRule) {\n  var utcTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURRENT_UTC_TIME;\n  var zoneOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var rules = timezones.rules[zoneRule];\n\n  if (!rules) {\n    var time = zoneRule.split(\":\");\n    var offset = 0;\n\n    if (time.length > 1) {\n      offset = time[0] * 60 + Number(time[1]);\n    }\n\n    return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'];\n  }\n\n  var year = new Date(utcTime).getUTCFullYear();\n  rules = rules.filter(function (currentRule) {\n    var from = currentRule[0];\n    var to = currentRule[1];\n    return from <= year && (to >= year || from === year && to === \"only\" || to === \"max\");\n  });\n  rules.push(utcTime);\n  rules.sort(function (a, b) {\n    if (typeof a !== \"number\") {\n      a = Number(ruleToDate(year, a, zoneOffset));\n    }\n\n    if (typeof b !== \"number\") {\n      b = Number(ruleToDate(year, b, zoneOffset));\n    }\n\n    return a - b;\n  });\n  var rule = rules[rules.indexOf(utcTime) - 1] || rules[rules.length - 1];\n  return isNaN(rule) ? rule : null;\n};","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@progress/kendo-date-math/dist/es2015/tz/find-rule.js"],"names":["timezones","ruleToDate","CURRENT_UTC_TIME","Date","getTime","findRule","zoneRule","utcTime","zoneOffset","rules","time","split","offset","length","Number","year","getUTCFullYear","filter","currentRule","from","to","push","sort","a","b","rule","indexOf","isNaN"],"mappings":"AAAA,SAASA,SAAT,QAA0B,aAA1B;AACA,SAASC,UAAT,QAA2B,gBAA3B;AACA,IAAMC,gBAAgB,GAAI,IAAIC,IAAJ,EAAD,CAAaC,OAAb,EAAzB;AACA;;;;;;;;;;;;;;;;AAeA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,QAAD,EAA0D;AAAA,MAA/CC,OAA+C,uEAArCL,gBAAqC;AAAA,MAAnBM,UAAmB,uEAAN,CAAM;AAC9E,MAAIC,KAAK,GAAGT,SAAS,CAACS,KAAV,CAAgBH,QAAhB,CAAZ;;AACA,MAAI,CAACG,KAAL,EAAY;AACR,QAAMC,IAAI,GAAGJ,QAAQ,CAACK,KAAT,CAAe,GAAf,CAAb;AACA,QAAIC,MAAM,GAAG,CAAb;;AACA,QAAIF,IAAI,CAACG,MAAL,GAAc,CAAlB,EAAqB;AACjBD,MAAAA,MAAM,GAAGF,IAAI,CAAC,CAAD,CAAJ,GAAU,EAAV,GAAeI,MAAM,CAACJ,IAAI,CAAC,CAAD,CAAL,CAA9B;AACH;;AACD,WAAO,CAAC,CAAC,OAAF,EAAW,KAAX,EAAkB,GAAlB,EAAuB,KAAvB,EAA8B,CAA9B,EAAiC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAjC,EAA4CE,MAA5C,EAAoD,GAApD,CAAP;AACH;;AACD,MAAMG,IAAI,GAAG,IAAIZ,IAAJ,CAASI,OAAT,EAAkBS,cAAlB,EAAb;AACAP,EAAAA,KAAK,GAAGA,KAAK,CAACQ,MAAN,CAAa,UAACC,WAAD,EAAiB;AAClC,QAAMC,IAAI,GAAGD,WAAW,CAAC,CAAD,CAAxB;AACA,QAAME,EAAE,GAAGF,WAAW,CAAC,CAAD,CAAtB;AACA,WAAOC,IAAI,IAAIJ,IAAR,KAAiBK,EAAE,IAAIL,IAAN,IAAeI,IAAI,KAAKJ,IAAT,IAAiBK,EAAE,KAAK,MAAvC,IAAkDA,EAAE,KAAK,KAA1E,CAAP;AACH,GAJO,CAAR;AAKAX,EAAAA,KAAK,CAACY,IAAN,CAAWd,OAAX;AACAE,EAAAA,KAAK,CAACa,IAAN,CAAW,UAACC,CAAD,EAAIC,CAAJ,EAAU;AACjB,QAAI,OAAOD,CAAP,KAAa,QAAjB,EAA2B;AACvBA,MAAAA,CAAC,GAAGT,MAAM,CAACb,UAAU,CAACc,IAAD,EAAOQ,CAAP,EAAUf,UAAV,CAAX,CAAV;AACH;;AACD,QAAI,OAAOgB,CAAP,KAAa,QAAjB,EAA2B;AACvBA,MAAAA,CAAC,GAAGV,MAAM,CAACb,UAAU,CAACc,IAAD,EAAOS,CAAP,EAAUhB,UAAV,CAAX,CAAV;AACH;;AACD,WAAOe,CAAC,GAAGC,CAAX;AACH,GARD;AASA,MAAMC,IAAI,GAAGhB,KAAK,CAACA,KAAK,CAACiB,OAAN,CAAcnB,OAAd,IAAyB,CAA1B,CAAL,IAAqCE,KAAK,CAACA,KAAK,CAACI,MAAN,GAAe,CAAhB,CAAvD;AACA,SAAOc,KAAK,CAACF,IAAD,CAAL,GAAcA,IAAd,GAAqB,IAA5B;AACH,CA5BM","sourcesContent":["import { timezones } from './timezones';\nimport { ruleToDate } from './rule-to-date';\nconst CURRENT_UTC_TIME = (new Date()).getTime();\n/**\n * @hidden\n *\n * A function that finds zone rules which become applicable after a specific time.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n * @param utcTime - The UTC time boundary for a zone rule. Defaults to the current UTC time.\n *\n * @return - Returns a zone rule for the specific zone name.\n *\n * @example\n * ```ts-no-run\n * findZone('Europe/Sofia'); //[-120,\"EU\",\"EE%sT\",null]\n * ```\n */\nexport const findRule = (zoneRule, utcTime = CURRENT_UTC_TIME, zoneOffset = 0) => {\n    let rules = timezones.rules[zoneRule];\n    if (!rules) {\n        const time = zoneRule.split(\":\");\n        let offset = 0;\n        if (time.length > 1) {\n            offset = time[0] * 60 + Number(time[1]);\n        }\n        return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'];\n    }\n    const year = new Date(utcTime).getUTCFullYear();\n    rules = rules.filter((currentRule) => {\n        const from = currentRule[0];\n        const to = currentRule[1];\n        return from <= year && (to >= year || (from === year && to === \"only\") || to === \"max\");\n    });\n    rules.push(utcTime);\n    rules.sort((a, b) => {\n        if (typeof a !== \"number\") {\n            a = Number(ruleToDate(year, a, zoneOffset));\n        }\n        if (typeof b !== \"number\") {\n            b = Number(ruleToDate(year, b, zoneOffset));\n        }\n        return a - b;\n    });\n    const rule = rules[rules.indexOf(utcTime) - 1] || rules[rules.length - 1];\n    return isNaN(rule) ? rule : null;\n};\n"]},"metadata":{},"sourceType":"module"}