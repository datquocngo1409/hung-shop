{"ast":null,"code":"import _classCallCheck from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/datquocngo/Project/Hung/gts-fe/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport withAccessors from '../mixins/with-accessors';\nimport HasObservers from '../core/has-observers';\nimport { defined, MIN_NUM, MAX_NUM, round as _round } from '../util';\nimport Matrix from './matrix';\nimport toMatrix from './to-matrix';\n\nvar Point = /*#__PURE__*/function (_withAccessors) {\n  _inherits(Point, _withAccessors);\n\n  var _super = _createSuper(Point);\n\n  function Point(x, y) {\n    var _this;\n\n    _classCallCheck(this, Point);\n\n    _this = _super.call(this);\n    _this.x = x || 0;\n    _this.y = y || 0;\n    return _this;\n  }\n\n  _createClass(Point, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return other && other.x === this.x && other.y === this.y;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Point(this.x, this.y);\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      var originPoint = Point.create(origin) || Point.ZERO;\n      return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(x, y) {\n      this.x += x;\n      this.y += y;\n      this.geometryChange();\n      return this;\n    }\n  }, {\n    key: \"translateWith\",\n    value: function translateWith(point) {\n      return this.translate(point.x, point.y);\n    }\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      this.x = this.y = 0;\n      return this.translate(x, y);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(scaleX) {\n      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n      this.x *= scaleX;\n      this.y *= scaleY;\n      this.geometryChange();\n      return this;\n    }\n  }, {\n    key: \"scaleCopy\",\n    value: function scaleCopy(scaleX, scaleY) {\n      return this.clone().scale(scaleX, scaleY);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(transformation) {\n      var matrix = toMatrix(transformation);\n      var x = this.x,\n          y = this.y;\n      this.x = matrix.a * x + matrix.c * y + matrix.e;\n      this.y = matrix.b * x + matrix.d * y + matrix.f;\n      this.geometryChange();\n      return this;\n    }\n  }, {\n    key: \"transformCopy\",\n    value: function transformCopy(transformation) {\n      var point = this.clone();\n\n      if (transformation) {\n        point.transform(transformation);\n      }\n\n      return point;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      var dx = this.x - point.x;\n      var dy = this.y - point.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }, {\n    key: \"round\",\n    value: function round(digits) {\n      this.x = _round(this.x, digits);\n      this.y = _round(this.y, digits);\n      this.geometryChange();\n      return this;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(digits) {\n      var doRound = defined(digits);\n      var x = doRound ? _round(this.x, digits) : this.x;\n      var y = doRound ? _round(this.y, digits) : this.y;\n      return [x, y];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(digits) {\n      var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n      var x = this.x,\n          y = this.y;\n\n      if (defined(digits)) {\n        x = _round(x, digits);\n        y = _round(y, digits);\n      }\n\n      return x + separator + y;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(arg0, arg1) {\n      if (defined(arg0)) {\n        if (arg0 instanceof Point) {\n          return arg0;\n        } else if (arguments.length === 1 && arg0.length === 2) {\n          return new Point(arg0[0], arg0[1]);\n        }\n\n        return new Point(arg0, arg1);\n      }\n    }\n  }, {\n    key: \"min\",\n    value: function min() {\n      var minX = MAX_NUM;\n      var minY = MAX_NUM;\n\n      for (var i = 0; i < arguments.length; i++) {\n        var point = arguments[i];\n        minX = Math.min(point.x, minX);\n        minY = Math.min(point.y, minY);\n      }\n\n      return new Point(minX, minY);\n    }\n  }, {\n    key: \"max\",\n    value: function max() {\n      var maxX = MIN_NUM;\n      var maxY = MIN_NUM;\n\n      for (var i = 0; i < arguments.length; i++) {\n        var point = arguments[i];\n        maxX = Math.max(point.x, maxX);\n        maxY = Math.max(point.y, maxY);\n      }\n\n      return new Point(maxX, maxY);\n    }\n  }, {\n    key: \"minPoint\",\n    value: function minPoint() {\n      return new Point(MIN_NUM, MIN_NUM);\n    }\n  }, {\n    key: \"maxPoint\",\n    value: function maxPoint() {\n      return new Point(MAX_NUM, MAX_NUM);\n    }\n  }, {\n    key: \"ZERO\",\n    get: function get() {\n      return new Point(0, 0);\n    }\n  }]);\n\n  return Point;\n}(withAccessors(HasObservers, [\"x\", \"y\"]));\n\nexport default Point;","map":{"version":3,"sources":["/home/datquocngo/Project/Hung/gts-fe/node_modules/@progress/kendo-drawing/dist/es2015/geometry/point.js"],"names":["withAccessors","HasObservers","defined","MIN_NUM","MAX_NUM","round","Matrix","toMatrix","Point","x","y","other","angle","origin","originPoint","create","ZERO","transform","rotate","geometryChange","point","translate","scaleX","scaleY","clone","scale","transformation","matrix","a","c","e","b","d","f","dx","dy","Math","sqrt","digits","doRound","separator","arg0","arg1","arguments","length","minX","minY","i","min","maxX","maxY","max"],"mappings":"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","sourcesContent":["import withAccessors from '../mixins/with-accessors';\nimport HasObservers from '../core/has-observers';\nimport { defined, MIN_NUM, MAX_NUM, round } from '../util';\nimport Matrix from './matrix';\nimport toMatrix from './to-matrix';\n\n\nclass Point extends withAccessors(HasObservers, [ \"x\", \"y\" ]) {\n    constructor(x, y) {\n        super();\n\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    equals(other) {\n        return other && other.x === this.x && other.y === this.y;\n    }\n\n    clone() {\n        return new Point(this.x, this.y);\n    }\n\n    rotate(angle, origin) {\n        const originPoint = Point.create(origin) || Point.ZERO;\n\n        return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\n    }\n\n    translate(x, y) {\n        this.x += x;\n        this.y += y;\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    translateWith(point) {\n        return this.translate(point.x, point.y);\n    }\n\n    move(x, y) {\n        this.x = this.y = 0;\n        return this.translate(x, y);\n    }\n\n    scale(scaleX, scaleY = scaleX) {\n        this.x *= scaleX;\n        this.y *= scaleY;\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    scaleCopy(scaleX, scaleY) {\n        return this.clone().scale(scaleX, scaleY);\n    }\n\n    transform(transformation) {\n        const matrix = toMatrix(transformation);\n        const { x, y } = this;\n\n        this.x = matrix.a * x + matrix.c * y + matrix.e;\n        this.y = matrix.b * x + matrix.d * y + matrix.f;\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    transformCopy(transformation) {\n        const point = this.clone();\n\n        if (transformation) {\n            point.transform(transformation);\n        }\n\n        return point;\n    }\n\n    distanceTo(point) {\n        const dx = this.x - point.x;\n        const dy = this.y - point.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    round(digits) {\n        this.x = round(this.x, digits);\n        this.y = round(this.y, digits);\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    toArray(digits) {\n        const doRound = defined(digits);\n        const x = doRound ? round(this.x, digits) : this.x;\n        const y = doRound ? round(this.y, digits) : this.y;\n\n        return [ x, y ];\n    }\n\n    toString(digits, separator = \" \") {\n        let { x, y } = this;\n\n        if (defined(digits)) {\n            x = round(x, digits);\n            y = round(y, digits);\n        }\n\n        return x + separator + y;\n    }\n\n    static create(arg0, arg1) {\n        if (defined(arg0)) {\n            if (arg0 instanceof Point) {\n                return arg0;\n            } else if (arguments.length === 1 && arg0.length === 2) {\n                return new Point(arg0[0], arg0[1]);\n            }\n\n            return new Point(arg0, arg1);\n        }\n    }\n\n    static min() {\n        let minX = MAX_NUM;\n        let minY = MAX_NUM;\n\n        for (let i = 0; i < arguments.length; i++) {\n            let point = arguments[i];\n            minX = Math.min(point.x, minX);\n            minY = Math.min(point.y, minY);\n        }\n\n        return new Point(minX, minY);\n    }\n\n    static max() {\n        let maxX = MIN_NUM;\n        let maxY = MIN_NUM;\n\n        for (let i = 0; i < arguments.length; i++) {\n            const point = arguments[i];\n            maxX = Math.max(point.x, maxX);\n            maxY = Math.max(point.y, maxY);\n        }\n\n        return new Point(maxX, maxY);\n    }\n\n    static minPoint() {\n        return new Point(MIN_NUM, MIN_NUM);\n    }\n\n    static maxPoint() {\n        return new Point(MAX_NUM, MAX_NUM);\n    }\n\n    static get ZERO() {\n        return new Point(0, 0);\n    }\n}\n\nexport default Point;\n"]},"metadata":{},"sourceType":"module"}