{"ast":null,"code":"import { PERCENT, SCIENTIFIC, NUMBER_PLACEHOLDER, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, EMPTY, POINT } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport formatCurrencySymbol from './format-currency-symbol';\nimport groupInteger from './group-integer';\nimport isCurrencyStyle from './is-currency-style';\nimport pad from '../common/pad';\nimport round from '../common/round';\nimport { currencyFractionOptions } from '../cldr';\nvar DEFAULT_DECIMAL_ROUNDING = 3;\nvar DEFAULT_PERCENT_ROUNDING = 0;\nvar trailingZeroRegex = /0+$/;\n\nfunction fractionOptions(options) {\n  var minimumFractionDigits = options.minimumFractionDigits,\n      maximumFractionDigits = options.maximumFractionDigits,\n      style = options.style;\n  var isCurrency = isCurrencyStyle(style);\n  var currencyFractions;\n\n  if (isCurrency) {\n    currencyFractions = currencyFractionOptions(options.currency);\n  }\n\n  if (minimumFractionDigits === undefined) {\n    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;\n  }\n\n  if (maximumFractionDigits === undefined) {\n    if (style === PERCENT) {\n      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);\n    } else if (isCurrency) {\n      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);\n    } else {\n      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);\n    }\n  }\n\n  return {\n    minimumFractionDigits: minimumFractionDigits,\n    maximumFractionDigits: maximumFractionDigits\n  };\n}\n\nfunction applyPattern(value, pattern, symbol) {\n  var result = EMPTY;\n\n  for (var idx = 0, length = pattern.length; idx < length; idx++) {\n    var ch = pattern.charAt(idx);\n\n    if (ch === NUMBER_PLACEHOLDER) {\n      result += value;\n    } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {\n      result += symbol;\n    } else {\n      result += ch;\n    }\n  }\n\n  return result;\n}\n\nfunction currencyUnitPattern(info, value) {\n  var currencyInfo = info.numbers.currency;\n  var pattern = value !== 1 ? currencyInfo[\"unitPattern-count-other\"] : currencyInfo[\"unitPattern-count-one\"];\n\n  if (value < 0) {\n    pattern = pattern.replace(NUMBER_PLACEHOLDER, \"-\".concat(NUMBER_PLACEHOLDER));\n  }\n\n  return pattern;\n}\n\nexport default function standardNumberFormat(number, options, info) {\n  var symbols = info.numbers.symbols;\n  var style = options.style;\n  var isCurrency = isCurrencyStyle(style); //return number in exponential format\n\n  if (style === SCIENTIFIC) {\n    var exponential = options.minimumFractionDigits !== undefined ? number.toExponential(options.minimumFractionDigits) : number.toExponential();\n    return exponential.replace(POINT, symbols.decimal);\n  }\n\n  var value = number;\n  var symbol;\n\n  if (isCurrency) {\n    options.value = value;\n    symbol = formatCurrencySymbol(info, options);\n  }\n\n  if (style === PERCENT) {\n    value *= 100;\n    symbol = symbols.percentSign;\n  }\n\n  var _fractionOptions = fractionOptions(options),\n      minimumFractionDigits = _fractionOptions.minimumFractionDigits,\n      maximumFractionDigits = _fractionOptions.maximumFractionDigits;\n\n  value = round(value, maximumFractionDigits);\n  var negative = value < 0;\n  var negativeZero = isNegativeZero(number);\n  var parts = value.split(POINT);\n  var integer = parts[0];\n  var fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true); //exclude \"-\" if number is negative.\n\n  if (negative) {\n    integer = integer.substring(1);\n  }\n\n  if (options.minimumIntegerDigits) {\n    integer = pad(integer, options.minimumIntegerDigits);\n  }\n\n  var formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;\n\n  if (fraction) {\n    formattedValue += symbols.decimal + fraction;\n  }\n\n  var pattern;\n\n  if (isCurrency && options.currencyDisplay === \"name\") {\n    pattern = currencyUnitPattern(info, number);\n  } else {\n    var patterns = options.patterns;\n    pattern = negative || negativeZero ? patterns[1] || \"-\" + patterns[0] : patterns[0];\n  }\n\n  if (pattern === NUMBER_PLACEHOLDER && !negative) {\n    return formattedValue;\n  }\n\n  var result = applyPattern(formattedValue, pattern, symbol);\n  return result;\n}","map":{"version":3,"sources":["/home/datquocngo/Project/UET/gts-fe/node_modules/@telerik/kendo-intl/dist/es2015/numbers/standard-number-format.js"],"names":["PERCENT","SCIENTIFIC","NUMBER_PLACEHOLDER","CURRENCY_PLACEHOLDER","PERCENT_PLACEHOLDER","EMPTY","POINT","isNegativeZero","formatCurrencySymbol","groupInteger","isCurrencyStyle","pad","round","currencyFractionOptions","DEFAULT_DECIMAL_ROUNDING","DEFAULT_PERCENT_ROUNDING","trailingZeroRegex","fractionOptions","options","minimumFractionDigits","maximumFractionDigits","style","isCurrency","currencyFractions","currency","undefined","Math","max","applyPattern","value","pattern","symbol","result","idx","length","ch","charAt","currencyUnitPattern","info","currencyInfo","numbers","replace","standardNumberFormat","number","symbols","exponential","toExponential","decimal","percentSign","negative","negativeZero","parts","split","integer","fraction","substring","minimumIntegerDigits","formattedValue","useGrouping","currencyDisplay","patterns"],"mappings":"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","sourcesContent":["import { PERCENT, SCIENTIFIC, NUMBER_PLACEHOLDER, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, EMPTY, POINT } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport formatCurrencySymbol from './format-currency-symbol';\nimport groupInteger from './group-integer';\nimport isCurrencyStyle from './is-currency-style';\nimport pad from '../common/pad';\nimport round from '../common/round';\nimport { currencyFractionOptions } from '../cldr';\n\nconst DEFAULT_DECIMAL_ROUNDING = 3;\nconst DEFAULT_PERCENT_ROUNDING = 0;\n\nconst trailingZeroRegex = /0+$/;\n\nfunction fractionOptions(options) {\n    let { minimumFractionDigits, maximumFractionDigits, style } = options;\n    const isCurrency = isCurrencyStyle(style);\n    let currencyFractions;\n    if (isCurrency) {\n        currencyFractions = currencyFractionOptions(options.currency);\n    }\n\n    if (minimumFractionDigits === undefined) {\n        minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;\n    }\n\n    if (maximumFractionDigits === undefined) {\n        if (style === PERCENT) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);\n        } else if (isCurrency) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);\n        } else {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);\n        }\n    }\n\n    return {\n        minimumFractionDigits: minimumFractionDigits,\n        maximumFractionDigits: maximumFractionDigits\n    };\n}\n\nfunction applyPattern(value, pattern, symbol) {\n    let result = EMPTY;\n    for (let idx = 0, length = pattern.length; idx < length; idx++) {\n        let ch = pattern.charAt(idx);\n\n        if (ch === NUMBER_PLACEHOLDER) {\n            result += value;\n        } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {\n            result += symbol;\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n\nfunction currencyUnitPattern(info, value) {\n    const currencyInfo = info.numbers.currency;\n    let pattern = value !== 1 ? currencyInfo[\"unitPattern-count-other\"] : currencyInfo[\"unitPattern-count-one\"];\n    if (value < 0) {\n        pattern = pattern.replace(NUMBER_PLACEHOLDER, `-${ NUMBER_PLACEHOLDER }`);\n    }\n\n    return pattern;\n}\n\n\nexport default function standardNumberFormat(number, options, info) {\n    const symbols = info.numbers.symbols;\n    const { style } = options;\n    const isCurrency = isCurrencyStyle(style);\n\n    //return number in exponential format\n    if (style === SCIENTIFIC) {\n        let exponential = options.minimumFractionDigits !== undefined ? number.toExponential(options.minimumFractionDigits) : number.toExponential();\n        return exponential.replace(POINT, symbols.decimal);\n    }\n\n    let value = number;\n    let symbol;\n\n    if (isCurrency) {\n        options.value = value;\n        symbol = formatCurrencySymbol(info, options);\n    }\n\n    if (style === PERCENT) {\n        value *= 100;\n        symbol = symbols.percentSign;\n    }\n\n    const { minimumFractionDigits, maximumFractionDigits } = fractionOptions(options);\n\n    value = round(value, maximumFractionDigits);\n\n    const negative = value < 0;\n    const negativeZero = isNegativeZero(number);\n\n    const parts = value.split(POINT);\n\n    let integer = parts[0];\n    let fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);\n\n    //exclude \"-\" if number is negative.\n    if (negative) {\n        integer = integer.substring(1);\n    }\n\n    if (options.minimumIntegerDigits) {\n        integer = pad(integer, options.minimumIntegerDigits);\n    }\n\n    let formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;\n\n    if (fraction) {\n        formattedValue += symbols.decimal + fraction;\n    }\n\n    let pattern;\n\n    if (isCurrency && options.currencyDisplay === \"name\") {\n        pattern = currencyUnitPattern(info, number);\n    } else {\n        const patterns = options.patterns;\n        pattern = (negative || negativeZero) ? patterns[1] || (\"-\" + patterns[0]) : patterns[0];\n    }\n\n    if (pattern === NUMBER_PLACEHOLDER && !negative) {\n        return formattedValue;\n    }\n\n    const result = applyPattern(formattedValue, pattern, symbol);\n\n    return result;\n}"]},"metadata":{},"sourceType":"module"}