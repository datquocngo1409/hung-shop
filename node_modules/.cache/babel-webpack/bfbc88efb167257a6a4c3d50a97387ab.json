{"ast":null,"code":"import _toConsumableArray from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/datquocngo/Project/UET/gts-fe/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Injectable, InjectionToken, Inject, Optional, NgZone, EventEmitter, isDevMode, Component, ElementRef, Renderer2, Input, Output, ViewChild, TemplateRef, ApplicationRef, ComponentFactoryResolver, Injector, NgModule } from '@angular/core';\nimport { siblingContainer, parents, addScroll as _addScroll, align as _align, boundingOffset as _boundingOffset, offset as _offset, positionWithScroll, removeScroll as _removeScroll, restrictToView as _restrictToView, scrollPosition as _scrollPosition, getWindowViewPort } from '@progress/kendo-popup-common';\nimport { isDocumentAvailable, hasObservers, ResizeSensorComponent, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { fromEvent, merge, from } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\nimport { style, animate, AnimationBuilder } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\n/**\n * @hidden\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@progress/kendo-angular-common';\nvar _c0 = [\"container\"];\n\nfunction PopupComponent_ng_template_3_Template(rf, ctx) {}\n\nvar _c1 = [\"*\"];\n\nvar eitherRect = function eitherRect(rect, offset$$1) {\n  if (!rect) {\n    return {\n      height: 0,\n      left: offset$$1.left,\n      top: offset$$1.top,\n      width: 0\n    };\n  }\n\n  return rect;\n};\n/**\n * @hidden\n */\n\n\nvar removeStackingOffset = function removeStackingOffset(rect, stackingOffset) {\n  if (!stackingOffset) {\n    return rect;\n  }\n\n  var result = {\n    height: rect.height,\n    left: rect.left - stackingOffset.left,\n    top: rect.top - stackingOffset.top,\n    width: rect.width\n  };\n  return result;\n};\n/**\n * @hidden\n */\n\n\nvar isDifferentOffset = function isDifferentOffset(oldOffset, newOffset) {\n  var oldLeft = oldOffset.left,\n      oldTop = oldOffset.top;\n  var newLeft = newOffset.left,\n      newTop = newOffset.top;\n  return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\n\n\nvar isWindowAvailable = function isWindowAvailable() {\n  return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n\nvar OVERFLOW_REGEXP = /auto|scroll/;\n\nvar overflowElementStyle = function overflowElementStyle(element) {\n  return \"\".concat(element.style.overflow).concat(element.style.overflowX).concat(element.style.overflowY);\n};\n\nvar overflowComputedStyle = function overflowComputedStyle(element) {\n  var styles = window.getComputedStyle(element);\n  return \"\".concat(styles.overflow).concat(styles.overflowX).concat(styles.overflowY);\n};\n\nvar overflowStyle = function overflowStyle(element) {\n  return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\n\n\nvar _scrollableParents = function scrollableParents(element) {\n  var parentElements = [];\n\n  if (!isDocumentAvailable() || !isWindowAvailable()) {\n    return parentElements;\n  }\n\n  var parent = element.parentElement;\n\n  while (parent) {\n    if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n      parentElements.push(parent);\n    }\n\n    parent = parent.parentElement;\n  }\n\n  parentElements.push(window);\n  return parentElements;\n};\n/**\n * @hidden\n */\n\n\nvar FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\n\nfunction memoize(fun) {\n  var result;\n  var called = false;\n  return function () {\n    if (called) {\n      return result;\n    }\n\n    result = fun.apply(void 0, arguments);\n    called = true;\n    return result;\n  };\n}\n/**\n * @hidden\n */\n\n\nvar hasRelativeStackingContext = memoize(function () {\n  if (!isDocumentAvailable() && document.body !== null) {\n    return false;\n  }\n\n  var top = 10;\n  var parent = document.createElement(\"div\");\n  parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n  parent.innerHTML = \"<div style=\\\"position: fixed; top: \".concat(top, \"px;\\\">child</div>\");\n  document.body.appendChild(parent);\n  var isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n  document.body.removeChild(parent);\n  return isDifferent;\n});\n/**\n * @hidden\n */\n\nvar _zIndex = function zIndex(anchor, container) {\n  if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n    return null;\n  }\n\n  var sibling = siblingContainer(anchor, container);\n\n  if (!sibling) {\n    return null;\n  }\n\n  var result = [anchor].concat(parents(anchor, sibling)).reduce(function (index, p) {\n    var zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n    var current = parseInt(zIndexStyle, 10);\n    return current > index ? current : index;\n  }, 0);\n  return result ? result + 1 : null;\n};\n/**\n * @hidden\n */\n\n\nvar scaleRect = function scaleRect(rect, scale) {\n  if (!rect || scale === 1) {\n    return rect;\n  }\n\n  return {\n    height: rect.height / scale,\n    left: rect.left / scale,\n    top: rect.top / scale,\n    width: rect.width / scale\n  };\n};\n\nvar STYLES = ['font-size', 'font-family', 'font-stretch', 'font-style', 'font-weight', 'line-height'];\n/**\n * @hidden\n */\n\nvar DOMService = /*#__PURE__*/function () {\n  function DOMService() {\n    _classCallCheck(this, DOMService);\n  }\n\n  _createClass(DOMService, [{\n    key: \"addOffset\",\n    value: function addOffset(current, addition) {\n      return {\n        left: current.left + addition.left,\n        top: current.top + addition.top\n      };\n    }\n  }, {\n    key: \"addScroll\",\n    value: function addScroll(rect, scroll) {\n      return _addScroll(rect, scroll);\n    }\n  }, {\n    key: \"align\",\n    value: function align(settings) {\n      return _align(settings);\n    }\n  }, {\n    key: \"boundingOffset\",\n    value: function boundingOffset(el) {\n      return _boundingOffset(this.nativeElement(el));\n    }\n  }, {\n    key: \"getFontStyles\",\n    value: function getFontStyles(el) {\n      var window = this.getWindow();\n\n      if (!window || !el) {\n        return [];\n      }\n\n      var computedStyles = window.getComputedStyle(this.nativeElement(el));\n      return STYLES.map(function (font) {\n        return {\n          key: font,\n          value: computedStyles[font]\n        };\n      });\n    }\n  }, {\n    key: \"getWindow\",\n    value: function getWindow() {\n      return isWindowAvailable() ? window : null;\n    }\n  }, {\n    key: \"hasOffsetParent\",\n    value: function hasOffsetParent(el) {\n      if (!el) {\n        return false;\n      }\n\n      return !!this.nativeElement(el).offsetParent;\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(el) {\n      if (!el) {\n        return null;\n      }\n\n      return _offset(this.nativeElement(el));\n    }\n  }, {\n    key: \"offsetAtPoint\",\n    value: function offsetAtPoint(el, currentLocation) {\n      if (!el) {\n        return null;\n      }\n\n      var element = this.nativeElement(el);\n      var _element$style = element.style,\n          left = _element$style.left,\n          top = _element$style.top,\n          transition = _element$style.transition;\n      element.style.transition = 'none';\n      element.style.left = \"\".concat(currentLocation.left, \"px\");\n      element.style.top = \"\".concat(currentLocation.top, \"px\");\n\n      var currentOffset = _offset(element);\n\n      element.style.left = left;\n      element.style.top = top; // prevents elements with transition to be animated because of the change\n      // tslint:disable-next-line:no-unused-expression\n\n      element.offsetHeight;\n      element.style.transition = transition;\n      return currentOffset;\n    }\n  }, {\n    key: \"nativeElement\",\n    value: function nativeElement(el) {\n      if (!el) {\n        return null;\n      }\n\n      return el.nativeElement || el;\n    }\n  }, {\n    key: \"position\",\n    value: function position(element, popup) {\n      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      if (!element || !popup) {\n        return null;\n      }\n\n      return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);\n    }\n  }, {\n    key: \"removeScroll\",\n    value: function removeScroll(rect, scroll) {\n      return _removeScroll(rect, scroll);\n    }\n  }, {\n    key: \"restrictToView\",\n    value: function restrictToView(settings) {\n      return _restrictToView(settings);\n    }\n  }, {\n    key: \"scrollPosition\",\n    value: function scrollPosition(el) {\n      return _scrollPosition(this.nativeElement(el));\n    }\n  }, {\n    key: \"scrollableParents\",\n    value: function scrollableParents(el) {\n      return _scrollableParents(this.nativeElement(el));\n    }\n  }, {\n    key: \"stackingElementOffset\",\n    value: function stackingElementOffset(el) {\n      var relativeContextElement = this.getRelativeContextElement(el);\n\n      if (!relativeContextElement) {\n        return null;\n      }\n\n      return _offset(relativeContextElement);\n    }\n  }, {\n    key: \"stackingElementScroll\",\n    value: function stackingElementScroll(el) {\n      var relativeContextElement = this.getRelativeContextElement(el);\n\n      if (!relativeContextElement) {\n        return {\n          x: 0,\n          y: 0\n        };\n      }\n\n      return {\n        x: relativeContextElement.scrollLeft,\n        y: relativeContextElement.scrollTop\n      };\n    }\n  }, {\n    key: \"getRelativeContextElement\",\n    value: function getRelativeContextElement(el) {\n      if (!el || !hasRelativeStackingContext()) {\n        return null;\n      }\n\n      var parent = this.nativeElement(el).parentElement;\n\n      while (parent) {\n        if (window.getComputedStyle(parent).transform !== 'none') {\n          return parent;\n        }\n\n        parent = parent.parentElement;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"useRelativePosition\",\n    value: function useRelativePosition(el) {\n      return !!this.getRelativeContextElement(el);\n    }\n  }, {\n    key: \"windowViewPort\",\n    value: function windowViewPort(el) {\n      return getWindowViewPort(this.nativeElement(el));\n    }\n  }, {\n    key: \"zIndex\",\n    value: function zIndex(anchor, container) {\n      return _zIndex(this.nativeElement(anchor), this.nativeElement(container));\n    }\n  }, {\n    key: \"zoomLevel\",\n    value: function zoomLevel() {\n      if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return 1;\n      }\n\n      return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    }\n  }, {\n    key: \"isZoomed\",\n    value: function isZoomed() {\n      return this.zoomLevel() > 1;\n    }\n  }]);\n\n  return DOMService;\n}();\n\nDOMService.ɵfac = function DOMService_Factory(t) {\n  return new (t || DOMService)();\n};\n\nDOMService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: DOMService,\n  factory: DOMService.ɵfac\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DOMService, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n *\n * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n *\n * > Using this token is not necessary for user-applied browser zoom.\n *\n * {% meta height:300 %}\n * {% embed_file scale/app.component.ts preview %}\n * {% embed_file scale/app.module.ts %}\n * {% embed_file scale/main.ts %}\n * {% endmeta %}\n *\n *\n */\n\n\nvar SCALE = new InjectionToken('Popup Document Scale');\n/**\n * @hidden\n */\n\nvar AlignService = /*#__PURE__*/function () {\n  function AlignService(_dom) {\n    var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, AlignService);\n\n    this._dom = _dom;\n    this.scale = scale;\n  }\n\n  _createClass(AlignService, [{\n    key: \"alignElement\",\n    value: function alignElement(settings) {\n      var anchor = settings.anchor,\n          element = settings.element,\n          anchorAlign = settings.anchorAlign,\n          elementAlign = settings.elementAlign,\n          margin = settings.margin,\n          offset$$1 = settings.offset,\n          positionMode = settings.positionMode;\n      var scale = this.scale || 1;\n      var fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n      var anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);\n      var elementRect = scaleRect(this._dom.offset(element), scale);\n\n      var result = this._dom.align({\n        anchorAlign: anchorAlign,\n        anchorRect: anchorRect,\n        elementAlign: elementAlign,\n        elementRect: elementRect,\n        margin: margin\n      });\n\n      return result;\n    }\n  }, {\n    key: \"absoluteRect\",\n    value: function absoluteRect(anchor, element, offset$$1, scale) {\n      var scrollPos = this.elementScrollPosition(anchor, element);\n      var rect = eitherRect(this._dom.offset(anchor), offset$$1);\n      var stackScale = 2 * scale;\n\n      var stackScroll = this._dom.stackingElementScroll(element);\n\n      if (scale !== 1 && stackScroll) {\n        stackScroll.x /= stackScale;\n        stackScroll.y /= stackScale;\n      }\n\n      var stackOffset = this._dom.stackingElementOffset(element);\n\n      if (scale !== 1 && stackOffset) {\n        stackOffset.left /= stackScale;\n        stackOffset.top /= stackScale;\n      }\n\n      return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n    }\n  }, {\n    key: \"elementScrollPosition\",\n    value: function elementScrollPosition(anchor, element) {\n      return anchor ? {\n        x: 0,\n        y: 0\n      } : this._dom.scrollPosition(element);\n    }\n  }, {\n    key: \"relativeRect\",\n    value: function relativeRect(anchor, element, offset$$1, scale) {\n      var rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);\n      return scaleRect(rect, scale);\n    }\n  }]);\n\n  return AlignService;\n}();\n\nAlignService.ɵfac = function AlignService_Factory(t) {\n  return new (t || AlignService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8));\n};\n\nAlignService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: AlignService,\n  factory: AlignService.ɵfac\n});\n/** @nocollapse */\n\nAlignService.ctorParameters = function () {\n  return [{\n    type: DOMService\n  }, {\n    type: Number,\n    decorators: [{\n      type: Inject,\n      args: [SCALE]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AlignService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DOMService\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [SCALE]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @hidden\n */\n\n\nvar PositionService = /*#__PURE__*/function () {\n  function PositionService(_dom) {\n    var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, PositionService);\n\n    this._dom = _dom;\n    this.scale = scale;\n  }\n\n  _createClass(PositionService, [{\n    key: \"positionElement\",\n    value: function positionElement(settings) {\n      var anchor = settings.anchor,\n          currentLocation = settings.currentLocation,\n          element = settings.element,\n          anchorAlign = settings.anchorAlign,\n          elementAlign = settings.elementAlign,\n          collisions = settings.collisions,\n          margin = settings.margin;\n      var dom = this._dom;\n      var scale = this.scale || 1;\n      var elementOffset = dom.offsetAtPoint(element, currentLocation);\n      var elementRect = scaleRect(elementOffset, scale);\n      var anchorOffset = scaleRect(dom.offset(anchor), scale);\n      var anchorRect = eitherRect(anchorOffset, currentLocation);\n      var viewPort = settings.viewPort || dom.windowViewPort(element);\n      viewPort.width = viewPort.width / scale;\n      viewPort.height = viewPort.height / scale;\n      var result = dom.restrictToView({\n        anchorAlign: anchorAlign,\n        anchorRect: anchorRect,\n        collisions: collisions,\n        elementAlign: elementAlign,\n        elementRect: elementRect,\n        margin: margin,\n        viewPort: viewPort\n      });\n      var offset$$1 = dom.addOffset(currentLocation, result.offset);\n      return {\n        flip: result.flip,\n        flipped: result.flipped,\n        offset: offset$$1\n      };\n    }\n  }]);\n\n  return PositionService;\n}();\n\nPositionService.ɵfac = function PositionService_Factory(t) {\n  return new (t || PositionService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8));\n};\n\nPositionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: PositionService,\n  factory: PositionService.ɵfac\n});\n/** @nocollapse */\n\nPositionService.ctorParameters = function () {\n  return [{\n    type: DOMService\n  }, {\n    type: Number,\n    decorators: [{\n      type: Inject,\n      args: [SCALE]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(PositionService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DOMService\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [SCALE]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @hidden\n */\n\n\nvar ResizeService = /*#__PURE__*/function () {\n  function ResizeService(_dom, _zone) {\n    _classCallCheck(this, ResizeService);\n\n    this._dom = _dom;\n    this._zone = _zone;\n  }\n\n  _createClass(ResizeService, [{\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      var _this = this;\n\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this._zone.runOutsideAngular(function () {\n        _this.subscription = fromEvent(_this._dom.getWindow(), \"resize\").pipe(auditTime(FRAME_DURATION)).subscribe(function () {\n          return callback();\n        });\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (!this.subscription) {\n        return;\n      }\n\n      this.subscription.unsubscribe();\n    }\n  }, {\n    key: \"isUnsubscribed\",\n    value: function isUnsubscribed() {\n      return this.subscription && this.subscription.closed;\n    }\n  }]);\n\n  return ResizeService;\n}();\n\nResizeService.ɵfac = function ResizeService_Factory(t) {\n  return new (t || ResizeService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(NgZone));\n};\n\nResizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: ResizeService,\n  factory: ResizeService.ɵfac\n});\n/** @nocollapse */\n\nResizeService.ctorParameters = function () {\n  return [{\n    type: DOMService\n  }, {\n    type: NgZone\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(ResizeService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DOMService\n    }, {\n      type: NgZone\n    }];\n  }, null);\n})();\n/**\n * @hidden\n */\n\n\nvar THRESHOLD_DIFF = 1;\n/**\n * @hidden\n */\n\nvar ScrollableService = /*#__PURE__*/function () {\n  function ScrollableService(_dom, _zone) {\n    _classCallCheck(this, ScrollableService);\n\n    this._dom = _dom;\n    this._zone = _zone;\n  }\n\n  _createClass(ScrollableService, [{\n    key: \"forElement\",\n    value: function forElement(element) {\n      this.unsubscribe();\n      this.element = element;\n      return this;\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      var _this2 = this;\n\n      if (!callback || !isDocumentAvailable() || !this.element) {\n        return;\n      }\n\n      var nativeElement = this._dom.nativeElement(this.element);\n\n      var parents$$1 = this._dom.scrollableParents(this.element);\n\n      this._zone.runOutsideAngular(function () {\n        var observables = parents$$1.map(function (p) {\n          return fromEvent(p, \"scroll\").pipe(auditTime(FRAME_DURATION));\n        });\n\n        var subscriber = function subscriber(e) {\n          var target = e.target;\n          var isParent = parents$$1.filter(function (p) {\n            return p === target;\n          }).length > 0;\n          var isDocument = target === document;\n          var isWindow = target === window;\n\n          if (isParent || isDocument || isWindow) {\n            callback(_this2.isVisible(nativeElement, target));\n          }\n        };\n\n        _this2.subscription = merge.apply(void 0, _toConsumableArray(observables)).subscribe(subscriber);\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (!this.subscription) {\n        return;\n      }\n\n      this.subscription.unsubscribe();\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible(elem, container) {\n      var elemRect = this._dom.boundingOffset(elem);\n\n      var containerRect = this._dom.boundingOffset(container);\n\n      if (THRESHOLD_DIFF < containerRect.top - elemRect.bottom) {\n        return false;\n      }\n\n      if (THRESHOLD_DIFF < elemRect.top - containerRect.bottom) {\n        return false;\n      }\n\n      if (THRESHOLD_DIFF < elemRect.left - containerRect.right) {\n        return false;\n      }\n\n      if (THRESHOLD_DIFF < containerRect.left - elemRect.right) {\n        return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return ScrollableService;\n}();\n\nScrollableService.ɵfac = function ScrollableService_Factory(t) {\n  return new (t || ScrollableService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(NgZone));\n};\n\nScrollableService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: ScrollableService,\n  factory: ScrollableService.ɵfac\n});\n/** @nocollapse */\n\nScrollableService.ctorParameters = function () {\n  return [{\n    type: DOMService\n  }, {\n    type: NgZone\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(ScrollableService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DOMService\n    }, {\n      type: NgZone\n    }];\n  }, null);\n})();\n\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar DOWN = 'down';\nvar UP = 'up';\nvar DEFAULT_TYPE = 'slide';\nvar DEFAULT_DURATION = 100;\nvar animationTypes = {};\n/* tslint:disable:object-literal-sort-keys */\n\nanimationTypes.expand = function (direction) {\n  var scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n  var startScale = 0;\n  var endScale = 1;\n  var origin;\n\n  if (direction === DOWN) {\n    origin = 'top';\n  } else if (direction === LEFT) {\n    origin = RIGHT;\n  } else if (direction === RIGHT) {\n    origin = LEFT;\n  } else {\n    origin = 'bottom';\n  }\n\n  return {\n    start: {\n      transform: \"\".concat(scale, \"(\").concat(startScale, \")\"),\n      transformOrigin: origin\n    },\n    end: {\n      transform: \"\".concat(scale, \"(\").concat(endScale, \")\")\n    }\n  };\n};\n\nanimationTypes.slide = function (direction) {\n  var translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';\n  var start = direction === RIGHT || direction === DOWN ? -100 : 100;\n  var end = 0;\n  return {\n    start: {\n      transform: \"\".concat(translate, \"(\").concat(start, \"%)\")\n    },\n    end: {\n      transform: \"\".concat(translate, \"(\").concat(end, \"%)\")\n    }\n  };\n};\n\nanimationTypes.fade = function () {\n  return {\n    start: {\n      opacity: 0\n    },\n    end: {\n      opacity: 1\n    }\n  };\n};\n\nanimationTypes.zoom = function () {\n  var start = 0;\n  var end = 1;\n  return {\n    start: {\n      transform: \"scale(\".concat(start, \")\")\n    },\n    end: {\n      transform: \"scale(\".concat(end, \")\")\n    }\n  };\n};\n/**\n * @hidden\n */\n\n\nvar AnimationService = /*#__PURE__*/function () {\n  function AnimationService(animationBuilder) {\n    _classCallCheck(this, AnimationService);\n\n    this.animationBuilder = animationBuilder;\n    this.start = new EventEmitter();\n    this.end = new EventEmitter();\n  }\n\n  _createClass(AnimationService, [{\n    key: \"play\",\n    value: function play(element, options, flip) {\n      if (!this.flip || this.flip.horizontal !== flip.horizontal || this.flip.vertical !== flip.vertical) {\n        this.flip = flip;\n        var type = options.type || DEFAULT_TYPE;\n        var statesFn = animationTypes[type];\n\n        if (statesFn) {\n          var direction = this.getDirection(flip, options);\n          var states = statesFn(direction);\n          this.playStates(element, states, options);\n        } else if (isDevMode()) {\n          throw new Error(\"Unsupported animation type: \\\"\".concat(type, \"\\\". The supported types are slide, expand, fade and zoom.\"));\n        }\n      }\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.stopPlayer();\n    }\n  }, {\n    key: \"playStates\",\n    value: function playStates(element, states, options) {\n      var _this3 = this;\n\n      this.stopPlayer();\n      var duration = options.duration || DEFAULT_DURATION;\n      var factory = this.animationBuilder.build([style(states.start), animate(\"\".concat(duration, \"ms ease-in\"), style(states.end))]);\n      var player = this.player = factory.create(element);\n      player.onDone(function () {\n        _this3.end.emit();\n\n        _this3.stopPlayer();\n      });\n      this.start.emit();\n      player.play();\n    }\n  }, {\n    key: \"getDirection\",\n    value: function getDirection(flip, options) {\n      var direction = options.direction || DOWN;\n\n      if (flip.horizontal) {\n        if (direction === LEFT) {\n          direction = RIGHT;\n        } else if (direction === RIGHT) {\n          direction = LEFT;\n        }\n      }\n\n      if (flip.vertical) {\n        if (direction === DOWN) {\n          direction = UP;\n        } else if (direction === UP) {\n          direction = DOWN;\n        }\n      }\n\n      return direction;\n    }\n  }, {\n    key: \"stopPlayer\",\n    value: function stopPlayer() {\n      if (this.player) {\n        this.player.destroy();\n        this.player = null;\n      }\n    }\n  }]);\n\n  return AnimationService;\n}();\n\nAnimationService.ɵfac = function AnimationService_Factory(t) {\n  return new (t || AnimationService)(ɵngcc0.ɵɵinject(AnimationBuilder));\n};\n\nAnimationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: AnimationService,\n  factory: AnimationService.ɵfac\n});\n/** @nocollapse */\n\nAnimationService.ctorParameters = function () {\n  return [{\n    type: AnimationBuilder\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AnimationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AnimationBuilder\n    }];\n  }, null);\n})();\n\nvar DEFAULT_OFFSET = {\n  left: -10000,\n  top: 0\n};\nvar ANIMATION_CONTAINER = 'k-animation-container';\nvar ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\n/**\n * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"show=!show\">Toggle</button>\n *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n *      <strong>Popup content!</strong>\n *  </kendo-popup>\n * `\n * })\n * class AppComponent {\n *   public show: boolean = false;\n * }\n * ```\n */\n\nvar PopupComponent = /*#__PURE__*/function () {\n  function PopupComponent(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n    _classCallCheck(this, PopupComponent);\n\n    this.container = container;\n    this._alignService = _alignService;\n    this.domService = domService;\n    this._positionService = _positionService;\n    this._resizeService = _resizeService;\n    this._scrollableService = _scrollableService;\n    this.animationService = animationService;\n    this._renderer = _renderer;\n    this._zone = _zone;\n    /**\n     * Controls the Popup animation. By default, the opening and closing animations\n     * are enabled ([see example]({% slug animations_popup %})).\n     */\n\n    this.animate = true;\n    /**\n     * Specifies the anchor pivot point\n     * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n     */\n\n    this.anchorAlign = {\n      horizontal: 'left',\n      vertical: 'bottom'\n    };\n    /**\n     * Configures the collision behavior of the Popup\n     * ([see example]({% slug viewportboundarydetection_popup %})).\n     */\n\n    this.collision = {\n      horizontal: 'fit',\n      vertical: 'flip'\n    };\n    /**\n     * Specifies the pivot point of the Popup\n     * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n     */\n\n    this.popupAlign = {\n      horizontal: 'left',\n      vertical: 'top'\n    };\n    /**\n     * Controls whether the component will copy the `anchor` font styles.\n     */\n\n    this.copyAnchorStyles = false;\n    /**\n     * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n     * To make the Popup acquire absolute positioning, set this option to `absolute`.\n     *\n     * > If you need to support mobile browsers with the zoom option,\n     * use the `absolute` positioning of the Popup.\n     *\n     * @example\n     * ```html\n     * <style>\n     *  .parent-content {\n     *     position: relative;\n     *     width: 200px;\n     *     height: 200px;\n     *     overflow: auto;\n     *     margin: 200px auto;\n     *     border: 1px solid red;\n     *  }\n     *  .content {\n     *     position: relative;\n     *     width: 100px;\n     *     height: 100px;\n     *     overflow: auto;\n     *     margin: 300px;\n     *     border: 1px solid blue;\n     *  }\n     *  .anchor {\n     *     position: absolute;\n     *     top: 200px;\n     *     left: 200px;\n     *  }\n     * </style>\n     * ```\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *   <div class=\"example-config\">\n     *      Position mode:\n     *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n     *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n     *   </div>\n     *   <div class=\"example-config\">\n     *       Append to\n     *       <label>\n     *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n     *           Root component\n     *       </label>\n     *       <label>\n     *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n     *           <span style=\"color: red\">Red Container</span>\n     *       </label>\n     *       <label>\n     *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n     *           <span style=\"color: blue\">Blue Container</span>\n     *       </label>\n     *   </div>\n     *   <div class=\"example\">\n     *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n     *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n     *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n     *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n     *             <ul>\n     *                 <li>Item1</li>\n     *                 <li>Item2</li>\n     *                 <li>Item3</li>\n     *             </ul>\n     *           </kendo-popup>\n     *           <span style=\"position: absolute; top: 400px; left: 400px\">Bottom/Right</span>\n     *         </div>\n     *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n     *           <ul>\n     *               <li>Item1</li>\n     *               <li>Item2</li>\n     *               <li>Item3</li>\n     *           </ul>\n     *         </kendo-popup>\n     *         <span style=\"position: absolute; top: 600px; left: 600px\">Bottom/Right</span>\n     *     </div>\n     *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n     *       <ul>\n     *           <li>Item1</li>\n     *           <li>Item2</li>\n     *           <li>Item3</li>\n     *       </ul>\n     *     </kendo-popup>\n     *   </div>\n     * `\n     * })\n     * class AppComponent {\n     *   public checked: number = 3;\n     *   public mode: string = 'absolute';\n     *   public show: boolean = true;\n     * }\n     * ```\n     */\n\n    this.positionMode = 'fixed';\n    /**\n     * Specifies the absolute position of the element\n     * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n     * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n     * The boundary detection is applied by using the window viewport.\n     */\n\n    this.offset = DEFAULT_OFFSET;\n    /**\n     * Fires when the anchor is scrolled outside the screen boundaries.\n     * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n     */\n\n    this.anchorViewportLeave = new EventEmitter();\n    /**\n     * Fires after the component is closed.\n     */\n\n    this.close = new EventEmitter();\n    /**\n     * Fires after the component is opened and the opening animation ends.\n     */\n\n    this.open = new EventEmitter();\n    /**\n     * Fires after the component is opened and the Popup is positioned.\n     */\n\n    this.positionChange = new EventEmitter();\n    this.resolvedPromise = Promise.resolve(null);\n    this.initialCheck = true;\n\n    this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n\n    this.updateFixedClass();\n  }\n\n  _createClass(PopupComponent, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.reposition = this.reposition.bind(this);\n\n      this._resizeService.subscribe(this.reposition);\n\n      this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n      this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n\n      this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));\n\n      this.currentOffset = DEFAULT_OFFSET;\n      this.setZIndex();\n      this.copyFontStyles();\n      this.updateFixedClass();\n    }\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      if (changes.copyAnchorStyles) {\n        this.copyFontStyles();\n      }\n\n      if (changes.positionMode) {\n        this.updateFixedClass();\n      }\n    }\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      var _this4 = this;\n\n      this.reposition();\n\n      if (!this.animate) {\n        this.resolvedPromise.then(function () {\n          _this4.onAnimationEnd();\n        });\n      }\n    }\n  }, {\n    key: \"ngAfterViewChecked\",\n    value: function ngAfterViewChecked() {\n      var _this5 = this;\n\n      if (this.initialCheck) {\n        this.initialCheck = false;\n        return;\n      }\n\n      this._zone.runOutsideAngular(function () {\n        // workarounds https://github.com/angular/angular/issues/19094\n        // uses promise because it is executed synchronously after the content is updated\n        // does not use onStable in case the current zone is not the angular one.\n        _this5.unsubscribeReposition();\n\n        _this5.repositionSubscription = from(_this5.resolvedPromise).subscribe(_this5.reposition);\n      });\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.anchorViewportLeave.complete();\n      this.positionChange.complete();\n      this.close.emit();\n      this.close.complete();\n\n      this._resizeService.unsubscribe();\n\n      this._scrollableService.unsubscribe();\n\n      this.animationSubscriptions.unsubscribe();\n      this.unsubscribeReposition();\n    }\n    /**\n     * @hidden\n     */\n\n  }, {\n    key: \"onResize\",\n    value: function onResize() {\n      this.reposition();\n    }\n  }, {\n    key: \"onAnimationStart\",\n    value: function onAnimationStart() {\n      this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n    }\n  }, {\n    key: \"onAnimationEnd\",\n    value: function onAnimationEnd() {\n      this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n\n      this.open.emit();\n      this.open.complete();\n    }\n  }, {\n    key: \"setZIndex\",\n    value: function setZIndex() {\n      if (this.anchor) {\n        this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));\n      }\n    }\n  }, {\n    key: \"reposition\",\n    value: function reposition() {\n      var _this6 = this;\n\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      var _this$position = this.position(),\n          flip = _this$position.flip,\n          offset$$1 = _this$position.offset;\n\n      if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {\n        this.currentOffset = offset$$1;\n\n        if (hasObservers(this.positionChange)) {\n          this._zone.run(function () {\n            return _this6.positionChange.emit({\n              offset: offset$$1,\n              flip: flip\n            });\n          });\n        }\n      }\n\n      if (this.animate) {\n        this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n      }\n\n      this.resizeSensor.acceptSize();\n    }\n  }, {\n    key: \"position\",\n    value: function position() {\n      var alignedOffset = this._alignService.alignElement({\n        anchor: this.anchor,\n        anchorAlign: this.anchorAlign,\n        element: this.container,\n        elementAlign: this.popupAlign,\n        margin: this.margin,\n        offset: this.offset,\n        positionMode: this.positionMode\n      });\n\n      return this._positionService.positionElement({\n        anchor: this.anchor,\n        anchorAlign: this.anchorAlign,\n        collisions: this.collision,\n        currentLocation: alignedOffset,\n        element: this.container,\n        elementAlign: this.popupAlign,\n        margin: this.margin\n      });\n    }\n  }, {\n    key: \"onScroll\",\n    value: function onScroll(isInViewPort) {\n      var _this7 = this;\n\n      var hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n\n      if (isInViewPort || !hasLeaveObservers) {\n        this.reposition();\n      } else if (hasLeaveObservers) {\n        this._zone.run(function () {\n          _this7.anchorViewportLeave.emit();\n        });\n      }\n    }\n  }, {\n    key: \"copyFontStyles\",\n    value: function copyFontStyles() {\n      var _this8 = this;\n\n      if (!this.anchor || !this.copyAnchorStyles) {\n        return;\n      }\n\n      this.domService.getFontStyles(this.anchor).forEach(function (s) {\n        return _this8.setContainerStyle(s.key, s.value);\n      });\n    }\n  }, {\n    key: \"updateFixedClass\",\n    value: function updateFixedClass() {\n      var action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n\n      this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n    }\n  }, {\n    key: \"setContainerStyle\",\n    value: function setContainerStyle(name, value) {\n      this._renderer.setStyle(this.container.nativeElement, name, value);\n    }\n  }, {\n    key: \"unsubscribeReposition\",\n    value: function unsubscribeReposition() {\n      if (this.repositionSubscription) {\n        this.repositionSubscription.unsubscribe();\n      }\n    }\n  }, {\n    key: \"currentOffset\",\n    get: function get() {\n      return this._currentOffset;\n    },\n    set: function set(offset$$1) {\n      this.setContainerStyle('left', \"\".concat(offset$$1.left, \"px\"));\n      this.setContainerStyle('top', \"\".concat(offset$$1.top, \"px\"));\n      this._currentOffset = offset$$1;\n    }\n  }]);\n\n  return PopupComponent;\n}();\n\nPopupComponent.ɵfac = function PopupComponent_Factory(t) {\n  return new (t || PopupComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(AlignService), ɵngcc0.ɵɵdirectiveInject(DOMService), ɵngcc0.ɵɵdirectiveInject(PositionService), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(ScrollableService), ɵngcc0.ɵɵdirectiveInject(AnimationService), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgZone));\n};\n\nPopupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: PopupComponent,\n  selectors: [[\"kendo-popup\"]],\n  viewQuery: function PopupComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c0, true);\n      ɵngcc0.ɵɵviewQuery(ResizeSensorComponent, true);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentContainer = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);\n    }\n  },\n  inputs: {\n    animate: \"animate\",\n    anchorAlign: \"anchorAlign\",\n    collision: \"collision\",\n    popupAlign: \"popupAlign\",\n    copyAnchorStyles: \"copyAnchorStyles\",\n    positionMode: \"positionMode\",\n    offset: \"offset\",\n    anchor: \"anchor\",\n    popupClass: \"popupClass\",\n    margin: \"margin\"\n  },\n  outputs: {\n    anchorViewportLeave: \"anchorViewportLeave\",\n    close: \"close\",\n    open: \"open\",\n    positionChange: \"positionChange\"\n  },\n  exportAs: [\"kendo-popup\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService]), ɵngcc0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c1,\n  decls: 5,\n  vars: 4,\n  consts: [[1, \"k-popup\", 3, \"ngClass\"], [\"container\", \"\"], [3, \"ngTemplateOutlet\", \"ngIf\"], [3, \"rateLimit\", \"resize\"]],\n  template: function PopupComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n      ɵngcc0.ɵɵprojection(2);\n      ɵngcc0.ɵɵtemplate(3, PopupComponent_ng_template_3_Template, 0, 0, \"ng-template\", 2);\n      ɵngcc0.ɵɵelementStart(4, \"kendo-resize-sensor\", 3);\n      ɵngcc0.ɵɵlistener(\"resize\", function PopupComponent_Template_kendo_resize_sensor_resize_4_listener() {\n        return ctx.onResize();\n      });\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"ngClass\", ctx.popupClass);\n      ɵngcc0.ɵɵadvance(3);\n      ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.content)(\"ngIf\", ctx.content);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"rateLimit\", 100);\n    }\n  },\n  directives: [ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgIf, ɵngcc2.ResizeSensorComponent],\n  encapsulation: 2\n});\n/** @nocollapse */\n\nPopupComponent.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: AlignService\n  }, {\n    type: DOMService\n  }, {\n    type: PositionService\n  }, {\n    type: ResizeService\n  }, {\n    type: ScrollableService\n  }, {\n    type: AnimationService\n  }, {\n    type: Renderer2\n  }, {\n    type: NgZone\n  }];\n};\n\nPopupComponent.propDecorators = {\n  animate: [{\n    type: Input\n  }],\n  anchor: [{\n    type: Input\n  }],\n  anchorAlign: [{\n    type: Input\n  }],\n  collision: [{\n    type: Input\n  }],\n  popupAlign: [{\n    type: Input\n  }],\n  copyAnchorStyles: [{\n    type: Input\n  }],\n  popupClass: [{\n    type: Input\n  }],\n  positionMode: [{\n    type: Input\n  }],\n  offset: [{\n    type: Input\n  }],\n  margin: [{\n    type: Input\n  }],\n  anchorViewportLeave: [{\n    type: Output\n  }],\n  close: [{\n    type: Output\n  }],\n  open: [{\n    type: Output\n  }],\n  positionChange: [{\n    type: Output\n  }],\n  contentContainer: [{\n    type: ViewChild,\n    args: ['container']\n  }],\n  resizeSensor: [{\n    type: ViewChild,\n    args: [ResizeSensorComponent]\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(PopupComponent, [{\n    type: Component,\n    args: [{\n      exportAs: 'kendo-popup',\n      providers: [AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService],\n      selector: 'kendo-popup',\n      template: \"\\n        <div class=\\\"k-popup\\\" [ngClass]=\\\"popupClass\\\" #container>\\n            <ng-content></ng-content>\\n            <ng-template [ngTemplateOutlet]=\\\"content\\\" [ngIf]=\\\"content\\\"></ng-template>\\n            <kendo-resize-sensor [rateLimit]=\\\"100\\\" (resize)=\\\"onResize()\\\">\\n            </kendo-resize-sensor>\\n        </div>\\n     \"\n    }]\n  }], function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: AlignService\n    }, {\n      type: DOMService\n    }, {\n      type: PositionService\n    }, {\n      type: ResizeService\n    }, {\n      type: ScrollableService\n    }, {\n      type: AnimationService\n    }, {\n      type: Renderer2\n    }, {\n      type: NgZone\n    }];\n  }, {\n    animate: [{\n      type: Input\n    }],\n    anchorAlign: [{\n      type: Input\n    }],\n    collision: [{\n      type: Input\n    }],\n    popupAlign: [{\n      type: Input\n    }],\n    copyAnchorStyles: [{\n      type: Input\n    }],\n    positionMode: [{\n      type: Input\n    }],\n    offset: [{\n      type: Input\n    }],\n    anchorViewportLeave: [{\n      type: Output\n    }],\n    close: [{\n      type: Output\n    }],\n    open: [{\n      type: Output\n    }],\n    positionChange: [{\n      type: Output\n    }],\n    anchor: [{\n      type: Input\n    }],\n    popupClass: [{\n      type: Input\n    }],\n    margin: [{\n      type: Input\n    }],\n    contentContainer: [{\n      type: ViewChild,\n      args: ['container']\n    }],\n    resizeSensor: [{\n      type: ViewChild,\n      args: [ResizeSensorComponent]\n    }]\n  });\n})();\n\nvar removeElement = function removeElement(element) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { ElementRef, NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\n\n\nvar POPUP_CONTAINER = new InjectionToken('Popup Container');\n/**\n * A service for opening Popup components dynamically\n * ([see example]({% slug service_popup %})).\n *\n * @export\n * @class PopupService\n */\n\nvar PopupService = /*#__PURE__*/function () {\n  function PopupService(applicationRef, componentFactoryResolver, injector, container) {\n    _classCallCheck(this, PopupService);\n\n    this.applicationRef = applicationRef;\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.injector = injector;\n    this.container = container;\n  }\n  /**\n   * Gets the root view container into which the component will be injected.\n   *\n   * @returns {ComponentRef<any>}\n   */\n\n\n  _createClass(PopupService, [{\n    key: \"open\",\n\n    /**\n     * Opens a Popup component. Created Popups are mounted\n     * in the DOM directly in the root application component.\n     *\n     * @param {PopupSettings} options - The options which define the Popup.\n     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <ng-template #template>\n     *      Popup content\n     *     </ng-template>\n     *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n     *   `\n     * })\n     * export class AppComponent {\n     *     public popupRef: PopupRef;\n     *\n     *     constructor( private popupService: PopupService ) {}\n     *\n     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n     *         if (this.popupRef) {\n     *              this.popupRef.close();\n     *              this.popupRef = null;\n     *              return;\n     *         }\n     *\n     *         this.popupRef = this.popupService.open({\n     *           anchor: anchor,\n     *           content: template\n     *         });\n     *     }\n     * }\n     * ```\n     */\n    value: function open() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _this$contentFrom = this.contentFrom(options.content),\n          component = _this$contentFrom.component,\n          nodes = _this$contentFrom.nodes;\n\n      var popupComponentRef = this.appendPopup(nodes, options.appendTo);\n      var popupInstance = popupComponentRef.instance;\n      this.projectComponentInputs(popupComponentRef, options);\n      popupComponentRef.changeDetectorRef.detectChanges();\n\n      if (component) {\n        component.changeDetectorRef.detectChanges();\n      }\n\n      var popupElement = this.getComponentRootNode(popupComponentRef);\n      return {\n        close: function close() {\n          if (component) {\n            component.destroy();\n          }\n\n          popupComponentRef.destroy(); // Angular will not remove the element unless the change detection is triggered\n\n          removeElement(popupElement);\n        },\n        content: component,\n        popup: popupComponentRef,\n        popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n        popupClose: popupInstance.close,\n        popupElement: popupElement,\n        popupOpen: popupInstance.open,\n        popupPositionChange: popupInstance.positionChange\n      };\n    }\n  }, {\n    key: \"appendPopup\",\n    value: function appendPopup(nodes, container) {\n      var popupComponentRef = this.createComponent(PopupComponent, nodes, container);\n\n      if (!container) {\n        this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n      }\n\n      return popupComponentRef;\n    }\n    /**\n     * Gets the HTML element for a component reference.\n     *\n     * @param {ComponentRef<any>} componentRef\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"getComponentRootNode\",\n    value: function getComponentRootNode(componentRef) {\n      return componentRef.location.nativeElement;\n    }\n    /**\n     * Gets the `ComponentFactory` instance by its type.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n\n  }, {\n    key: \"getComponentFactory\",\n    value: function getComponentFactory(componentClass) {\n      return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n    }\n    /**\n     * Creates a component reference from a `Component` type class.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(componentClass, nodes, container) {\n      var factory = this.getComponentFactory(componentClass);\n\n      if (container) {\n        return container.createComponent(factory, undefined, this.injector, nodes);\n      } else {\n        var component = factory.create(this.injector, nodes);\n        this.applicationRef.attachView(component.hostView);\n        return component;\n      }\n    }\n    /**\n     * Projects the inputs on the component.\n     *\n     * @param {ComponentRef<any>} component\n     * @param {*} options\n     * @returns {ComponentRef<any>}\n     */\n\n  }, {\n    key: \"projectComponentInputs\",\n    value: function projectComponentInputs(component, options) {\n      Object.getOwnPropertyNames(options).filter(function (prop) {\n        return prop !== 'content' || options.content instanceof TemplateRef;\n      }).map(function (prop) {\n        component.instance[prop] = options[prop];\n      });\n      return component;\n    }\n    /**\n     * Gets the component and the nodes to append from the `content` option.\n     *\n     * @param {*} content\n     * @returns {any}\n     */\n\n  }, {\n    key: \"contentFrom\",\n    value: function contentFrom(content) {\n      if (!content || content instanceof TemplateRef) {\n        return {\n          component: null,\n          nodes: [[]]\n        };\n      }\n\n      var component = this.createComponent(content);\n      var nodes = component ? [component.location.nativeElement] : [];\n      return {\n        component: component,\n        nodes: [nodes // <ng-content>\n        ]\n      };\n    }\n  }, {\n    key: \"rootViewContainer\",\n    get: function get() {\n      // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n      var rootComponents = this.applicationRef.components || [];\n\n      if (rootComponents[0]) {\n        return rootComponents[0];\n      }\n\n      throw new Error(\"\\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\\n        \");\n    }\n    /**\n     * Sets or gets the HTML element of the root component container.\n     *\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"rootViewContainerNode\",\n    get: function get() {\n      return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n    }\n  }]);\n\n  return PopupService;\n}();\n\nPopupService.ɵfac = function PopupService_Factory(t) {\n  return new (t || PopupService)(ɵngcc0.ɵɵinject(ApplicationRef), ɵngcc0.ɵɵinject(ComponentFactoryResolver), ɵngcc0.ɵɵinject(Injector), ɵngcc0.ɵɵinject(POPUP_CONTAINER, 8));\n};\n\nPopupService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: PopupService,\n  factory: PopupService.ɵfac\n});\n/** @nocollapse */\n\nPopupService.ctorParameters = function () {\n  return [{\n    type: ApplicationRef\n  }, {\n    type: ComponentFactoryResolver\n  }, {\n    type: Injector\n  }, {\n    type: ElementRef,\n    decorators: [{\n      type: Inject,\n      args: [POPUP_CONTAINER]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(PopupService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ApplicationRef\n    }, {\n      type: ComponentFactoryResolver\n    }, {\n      type: Injector\n    }, {\n      type: ElementRef,\n      decorators: [{\n        type: Inject,\n        args: [POPUP_CONTAINER]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\nvar POPUP_DIRECTIVES = [PopupComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Popup component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nvar PopupModule = function PopupModule() {\n  _classCallCheck(this, PopupModule);\n};\n\nPopupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: PopupModule\n});\nPopupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function PopupModule_Factory(t) {\n    return new (t || PopupModule)();\n  },\n  providers: [PopupService],\n  imports: [[CommonModule, ResizeSensorModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PopupModule, {\n    declarations: function declarations() {\n      return [PopupComponent];\n    },\n    imports: function imports() {\n      return [CommonModule, ResizeSensorModule];\n    },\n    exports: function exports() {\n      return [PopupComponent];\n    }\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(PopupModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [POPUP_DIRECTIVES],\n      entryComponents: [POPUP_DIRECTIVES],\n      exports: [POPUP_DIRECTIVES],\n      imports: [CommonModule, ResizeSensorModule],\n      providers: [PopupService]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE };","map":{"version":3,"sources":["index.js"],"names":[],"mappings":"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","sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Injectable, InjectionToken, Inject, Optional, NgZone, EventEmitter, isDevMode, Component, ElementRef, Renderer2, Input, Output, ViewChild, TemplateRef, ApplicationRef, ComponentFactoryResolver, Injector, NgModule } from '@angular/core';\nimport { siblingContainer, parents, addScroll, align, boundingOffset, offset, positionWithScroll, removeScroll, restrictToView, scrollPosition, getWindowViewPort } from '@progress/kendo-popup-common';\nimport { isDocumentAvailable, hasObservers, ResizeSensorComponent, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { fromEvent, merge, from } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\nimport { style, animate, AnimationBuilder } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @hidden\n */\nconst eitherRect = (rect, offset$$1) => {\n    if (!rect) {\n        return { height: 0, left: offset$$1.left, top: offset$$1.top, width: 0 };\n    }\n    return rect;\n};\n/**\n * @hidden\n */\nconst removeStackingOffset = (rect, stackingOffset) => {\n    if (!stackingOffset) {\n        return rect;\n    }\n    const result = {\n        height: rect.height,\n        left: rect.left - stackingOffset.left,\n        top: rect.top - stackingOffset.top,\n        width: rect.width\n    };\n    return result;\n};\n/**\n * @hidden\n */\nconst isDifferentOffset = (oldOffset, newOffset) => {\n    const { left: oldLeft, top: oldTop } = oldOffset;\n    const { left: newLeft, top: newTop } = newOffset;\n    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => {\n    return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\nconst OVERFLOW_REGEXP = /auto|scroll/;\nconst overflowElementStyle = (element) => {\n    return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;\n};\nconst overflowComputedStyle = (element) => {\n    const styles = window.getComputedStyle(element);\n    return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;\n};\nconst overflowStyle = (element) => {\n    return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\nconst scrollableParents = (element) => {\n    const parentElements = [];\n    if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return parentElements;\n    }\n    let parent = element.parentElement;\n    while (parent) {\n        if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n            parentElements.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    parentElements.push(window);\n    return parentElements;\n};\n/**\n * @hidden\n */\nconst FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\nfunction memoize(fun) {\n    let result;\n    let called = false;\n    return (...args) => {\n        if (called) {\n            return result;\n        }\n        result = fun(...args);\n        called = true;\n        return result;\n    };\n}\n/**\n * @hidden\n */\nconst hasRelativeStackingContext = memoize(() => {\n    if (!isDocumentAvailable() && document.body !== null) {\n        return false;\n    }\n    const top = 10;\n    const parent = document.createElement(\"div\");\n    parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n    parent.innerHTML = `<div style=\"position: fixed; top: ${top}px;\">child</div>`;\n    document.body.appendChild(parent);\n    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n    document.body.removeChild(parent);\n    return isDifferent;\n});\n/**\n * @hidden\n */\nconst zIndex = (anchor, container) => {\n    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n        return null;\n    }\n    const sibling = siblingContainer(anchor, container);\n    if (!sibling) {\n        return null;\n    }\n    const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {\n        const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n        const current = parseInt(zIndexStyle, 10);\n        return current > index ? current : index;\n    }, 0);\n    return result ? (result + 1) : null;\n};\n/**\n * @hidden\n */\nconst scaleRect = (rect, scale) => {\n    if (!rect || scale === 1) {\n        return rect;\n    }\n    return {\n        height: rect.height / scale,\n        left: rect.left / scale,\n        top: rect.top / scale,\n        width: rect.width / scale\n    };\n};\n\nconst STYLES = [\n    'font-size',\n    'font-family',\n    'font-stretch',\n    'font-style',\n    'font-weight',\n    'line-height'\n];\n/**\n * @hidden\n */\nclass DOMService {\n    addOffset(current, addition) {\n        return {\n            left: current.left + addition.left,\n            top: current.top + addition.top\n        };\n    }\n    addScroll(rect, scroll) {\n        return addScroll(rect, scroll);\n    }\n    align(settings) {\n        return align(settings);\n    }\n    boundingOffset(el) {\n        return boundingOffset(this.nativeElement(el));\n    }\n    getFontStyles(el) {\n        const window = this.getWindow();\n        if (!window || !el) {\n            return [];\n        }\n        const computedStyles = window.getComputedStyle(this.nativeElement(el));\n        return STYLES.map(font => ({ key: font, value: computedStyles[font] }));\n    }\n    getWindow() {\n        return isWindowAvailable() ? window : null;\n    }\n    hasOffsetParent(el) {\n        if (!el) {\n            return false;\n        }\n        return !!this.nativeElement(el).offsetParent;\n    }\n    offset(el) {\n        if (!el) {\n            return null;\n        }\n        return offset(this.nativeElement(el));\n    }\n    offsetAtPoint(el, currentLocation) {\n        if (!el) {\n            return null;\n        }\n        const element = this.nativeElement(el);\n        const { left, top, transition } = element.style;\n        element.style.transition = 'none';\n        element.style.left = `${currentLocation.left}px`;\n        element.style.top = `${currentLocation.top}px`;\n        const currentOffset = offset(element);\n        element.style.left = left;\n        element.style.top = top;\n        // prevents elements with transition to be animated because of the change\n        // tslint:disable-next-line:no-unused-expression\n        element.offsetHeight;\n        element.style.transition = transition;\n        return currentOffset;\n    }\n    nativeElement(el) {\n        if (!el) {\n            return null;\n        }\n        return el.nativeElement || el;\n    }\n    position(element, popup, scale = 1) {\n        if (!element || !popup) {\n            return null;\n        }\n        return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);\n    }\n    removeScroll(rect, scroll) {\n        return removeScroll(rect, scroll);\n    }\n    restrictToView(settings) {\n        return restrictToView(settings);\n    }\n    scrollPosition(el) {\n        return scrollPosition(this.nativeElement(el));\n    }\n    scrollableParents(el) {\n        return scrollableParents(this.nativeElement(el));\n    }\n    stackingElementOffset(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return null;\n        }\n        return offset(relativeContextElement);\n    }\n    stackingElementScroll(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return { x: 0, y: 0 };\n        }\n        return {\n            x: relativeContextElement.scrollLeft,\n            y: relativeContextElement.scrollTop\n        };\n    }\n    getRelativeContextElement(el) {\n        if (!el || !hasRelativeStackingContext()) {\n            return null;\n        }\n        let parent = this.nativeElement(el).parentElement;\n        while (parent) {\n            if (window.getComputedStyle(parent).transform !== 'none') {\n                return parent;\n            }\n            parent = parent.parentElement;\n        }\n        return null;\n    }\n    useRelativePosition(el) {\n        return !!this.getRelativeContextElement(el);\n    }\n    windowViewPort(el) {\n        return getWindowViewPort(this.nativeElement(el));\n    }\n    zIndex(anchor, container) {\n        return zIndex(this.nativeElement(anchor), this.nativeElement(container));\n    }\n    zoomLevel() {\n        if (!isDocumentAvailable() || !isWindowAvailable()) {\n            return 1;\n        }\n        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    }\n    isZoomed() {\n        return this.zoomLevel() > 1;\n    }\n}\nDOMService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n *\n * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n *\n * > Using this token is not necessary for user-applied browser zoom.\n *\n * {% meta height:300 %}\n * {% embed_file scale/app.component.ts preview %}\n * {% embed_file scale/app.module.ts %}\n * {% embed_file scale/main.ts %}\n * {% endmeta %}\n *\n *\n */\nconst SCALE = new InjectionToken('Popup Document Scale');\n\n/**\n * @hidden\n */\nclass AlignService {\n    constructor(_dom, scale = 1) {\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    alignElement(settings) {\n        const { anchor, element, anchorAlign, elementAlign, margin, offset: offset$$1, positionMode } = settings;\n        const scale = this.scale || 1;\n        const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n        const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);\n        const elementRect = scaleRect(this._dom.offset(element), scale);\n        const result = this._dom.align({\n            anchorAlign: anchorAlign,\n            anchorRect: anchorRect,\n            elementAlign: elementAlign,\n            elementRect: elementRect,\n            margin\n        });\n        return result;\n    }\n    absoluteRect(anchor, element, offset$$1, scale) {\n        const scrollPos = this.elementScrollPosition(anchor, element);\n        const rect = eitherRect(this._dom.offset(anchor), offset$$1);\n        const stackScale = 2 * scale;\n        const stackScroll = this._dom.stackingElementScroll(element);\n        if (scale !== 1 && stackScroll) {\n            stackScroll.x /= stackScale;\n            stackScroll.y /= stackScale;\n        }\n        const stackOffset = this._dom.stackingElementOffset(element);\n        if (scale !== 1 && stackOffset) {\n            stackOffset.left /= stackScale;\n            stackOffset.top /= stackScale;\n        }\n        return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n    }\n    elementScrollPosition(anchor, element) {\n        return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);\n    }\n    relativeRect(anchor, element, offset$$1, scale) {\n        const rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);\n        return scaleRect(rect, scale);\n    }\n}\nAlignService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nAlignService.ctorParameters = () => [\n    { type: DOMService },\n    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass PositionService {\n    constructor(_dom, scale = 1) {\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    positionElement(settings) {\n        const { anchor, currentLocation, element, anchorAlign, elementAlign, collisions, margin } = settings;\n        const dom = this._dom;\n        const scale = this.scale || 1;\n        const elementOffset = dom.offsetAtPoint(element, currentLocation);\n        const elementRect = scaleRect(elementOffset, scale);\n        const anchorOffset = scaleRect(dom.offset(anchor), scale);\n        const anchorRect = eitherRect(anchorOffset, currentLocation);\n        const viewPort = settings.viewPort || dom.windowViewPort(element);\n        viewPort.width = viewPort.width / scale;\n        viewPort.height = viewPort.height / scale;\n        const result = dom.restrictToView({\n            anchorAlign,\n            anchorRect,\n            collisions,\n            elementAlign,\n            elementRect,\n            margin,\n            viewPort\n        });\n        const offset$$1 = dom.addOffset(currentLocation, result.offset);\n        return {\n            flip: result.flip,\n            flipped: result.flipped,\n            offset: offset$$1\n        };\n    }\n}\nPositionService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nPositionService.ctorParameters = () => [\n    { type: DOMService },\n    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass ResizeService {\n    constructor(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    subscribe(callback) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this._zone.runOutsideAngular(() => {\n            this.subscription = fromEvent(this._dom.getWindow(), \"resize\")\n                .pipe(auditTime(FRAME_DURATION))\n                .subscribe(() => callback());\n        });\n    }\n    unsubscribe() {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    }\n    isUnsubscribed() {\n        return this.subscription && this.subscription.closed;\n    }\n}\nResizeService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nResizeService.ctorParameters = () => [\n    { type: DOMService },\n    { type: NgZone }\n];\n\n/**\n * @hidden\n */\nconst THRESHOLD_DIFF = 1;\n/**\n * @hidden\n */\nclass ScrollableService {\n    constructor(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    forElement(element) {\n        this.unsubscribe();\n        this.element = element;\n        return this;\n    }\n    subscribe(callback) {\n        if (!callback || !isDocumentAvailable() || !this.element) {\n            return;\n        }\n        const nativeElement = this._dom.nativeElement(this.element);\n        const parents$$1 = this._dom.scrollableParents(this.element);\n        this._zone.runOutsideAngular(() => {\n            const observables = parents$$1.map(p => fromEvent(p, \"scroll\").pipe(auditTime(FRAME_DURATION)));\n            const subscriber = (e) => {\n                const target = e.target;\n                const isParent = parents$$1.filter(p => p === target).length > 0;\n                const isDocument = target === document;\n                const isWindow = target === window;\n                if (isParent || isDocument || isWindow) {\n                    callback(this.isVisible(nativeElement, target));\n                }\n            };\n            this.subscription = merge(...observables).subscribe(subscriber);\n        });\n    }\n    unsubscribe() {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    }\n    isVisible(elem, container) {\n        const elemRect = this._dom.boundingOffset(elem);\n        const containerRect = this._dom.boundingOffset(container);\n        if (THRESHOLD_DIFF < (containerRect.top - elemRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.top - containerRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.left - containerRect.right)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (containerRect.left - elemRect.right)) {\n            return false;\n        }\n        return true;\n    }\n}\nScrollableService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nScrollableService.ctorParameters = () => [\n    { type: DOMService },\n    { type: NgZone }\n];\n\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst DOWN = 'down';\nconst UP = 'up';\nconst DEFAULT_TYPE = 'slide';\nconst DEFAULT_DURATION = 100;\nconst animationTypes = {};\n/* tslint:disable:object-literal-sort-keys */\nanimationTypes.expand = (direction) => {\n    const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n    const startScale = 0;\n    const endScale = 1;\n    let origin;\n    if (direction === DOWN) {\n        origin = 'top';\n    }\n    else if (direction === LEFT) {\n        origin = RIGHT;\n    }\n    else if (direction === RIGHT) {\n        origin = LEFT;\n    }\n    else {\n        origin = 'bottom';\n    }\n    return {\n        start: { transform: `${scale}(${startScale})`, transformOrigin: origin },\n        end: { transform: `${scale}(${endScale})` }\n    };\n};\nanimationTypes.slide = (direction) => {\n    const translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';\n    const start = direction === RIGHT || direction === DOWN ? -100 : 100;\n    const end = 0;\n    return {\n        start: { transform: `${translate}(${start}%)` },\n        end: { transform: `${translate}(${end}%)` }\n    };\n};\nanimationTypes.fade = () => {\n    return {\n        start: { opacity: 0 },\n        end: { opacity: 1 }\n    };\n};\nanimationTypes.zoom = () => {\n    const start = 0;\n    const end = 1;\n    return {\n        start: { transform: `scale(${start})` },\n        end: { transform: `scale(${end})` }\n    };\n};\n/**\n * @hidden\n */\nclass AnimationService {\n    constructor(animationBuilder) {\n        this.animationBuilder = animationBuilder;\n        this.start = new EventEmitter();\n        this.end = new EventEmitter();\n    }\n    play(element, options, flip) {\n        if (!this.flip || this.flip.horizontal !== flip.horizontal ||\n            this.flip.vertical !== flip.vertical) {\n            this.flip = flip;\n            const type = options.type || DEFAULT_TYPE;\n            const statesFn = animationTypes[type];\n            if (statesFn) {\n                const direction = this.getDirection(flip, options);\n                const states = statesFn(direction);\n                this.playStates(element, states, options);\n            }\n            else if (isDevMode()) {\n                throw new Error(`Unsupported animation type: \"${type}\". The supported types are slide, expand, fade and zoom.`);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.stopPlayer();\n    }\n    playStates(element, states, options) {\n        this.stopPlayer();\n        const duration = options.duration || DEFAULT_DURATION;\n        const factory = this.animationBuilder.build([\n            style(states.start),\n            animate(`${duration}ms ease-in`, style(states.end))\n        ]);\n        const player = this.player = factory.create(element);\n        player.onDone(() => {\n            this.end.emit();\n            this.stopPlayer();\n        });\n        this.start.emit();\n        player.play();\n    }\n    getDirection(flip, options) {\n        let direction = options.direction || DOWN;\n        if (flip.horizontal) {\n            if (direction === LEFT) {\n                direction = RIGHT;\n            }\n            else if (direction === RIGHT) {\n                direction = LEFT;\n            }\n        }\n        if (flip.vertical) {\n            if (direction === DOWN) {\n                direction = UP;\n            }\n            else if (direction === UP) {\n                direction = DOWN;\n            }\n        }\n        return direction;\n    }\n    stopPlayer() {\n        if (this.player) {\n            this.player.destroy();\n            this.player = null;\n        }\n    }\n}\nAnimationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nAnimationService.ctorParameters = () => [\n    { type: AnimationBuilder }\n];\n\nconst DEFAULT_OFFSET = { left: -10000, top: 0 };\nconst ANIMATION_CONTAINER = 'k-animation-container';\nconst ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\n/**\n * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"show=!show\">Toggle</button>\n *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n *      <strong>Popup content!</strong>\n *  </kendo-popup>\n * `\n * })\n * class AppComponent {\n *   public show: boolean = false;\n * }\n * ```\n */\nclass PopupComponent {\n    constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n        this.container = container;\n        this._alignService = _alignService;\n        this.domService = domService;\n        this._positionService = _positionService;\n        this._resizeService = _resizeService;\n        this._scrollableService = _scrollableService;\n        this.animationService = animationService;\n        this._renderer = _renderer;\n        this._zone = _zone;\n        /**\n         * Controls the Popup animation. By default, the opening and closing animations\n         * are enabled ([see example]({% slug animations_popup %})).\n         */\n        this.animate = true;\n        /**\n         * Specifies the anchor pivot point\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.anchorAlign = { horizontal: 'left', vertical: 'bottom' };\n        /**\n         * Configures the collision behavior of the Popup\n         * ([see example]({% slug viewportboundarydetection_popup %})).\n         */\n        this.collision = { horizontal: 'fit', vertical: 'flip' };\n        /**\n         * Specifies the pivot point of the Popup\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.popupAlign = { horizontal: 'left', vertical: 'top' };\n        /**\n         * Controls whether the component will copy the `anchor` font styles.\n         */\n        this.copyAnchorStyles = false;\n        /**\n         * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n         * To make the Popup acquire absolute positioning, set this option to `absolute`.\n         *\n         * > If you need to support mobile browsers with the zoom option,\n         * use the `absolute` positioning of the Popup.\n         *\n         * @example\n         * ```html\n         * <style>\n         *  .parent-content {\n         *     position: relative;\n         *     width: 200px;\n         *     height: 200px;\n         *     overflow: auto;\n         *     margin: 200px auto;\n         *     border: 1px solid red;\n         *  }\n         *  .content {\n         *     position: relative;\n         *     width: 100px;\n         *     height: 100px;\n         *     overflow: auto;\n         *     margin: 300px;\n         *     border: 1px solid blue;\n         *  }\n         *  .anchor {\n         *     position: absolute;\n         *     top: 200px;\n         *     left: 200px;\n         *  }\n         * </style>\n         * ```\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *   <div class=\"example-config\">\n         *      Position mode:\n         *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n         *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n         *   </div>\n         *   <div class=\"example-config\">\n         *       Append to\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n         *           Root component\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: red\">Red Container</span>\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: blue\">Blue Container</span>\n         *       </label>\n         *   </div>\n         *   <div class=\"example\">\n         *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n         *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n         *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n         *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n         *             <ul>\n         *                 <li>Item1</li>\n         *                 <li>Item2</li>\n         *                 <li>Item3</li>\n         *             </ul>\n         *           </kendo-popup>\n         *           <span style=\"position: absolute; top: 400px; left: 400px\">Bottom/Right</span>\n         *         </div>\n         *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n         *           <ul>\n         *               <li>Item1</li>\n         *               <li>Item2</li>\n         *               <li>Item3</li>\n         *           </ul>\n         *         </kendo-popup>\n         *         <span style=\"position: absolute; top: 600px; left: 600px\">Bottom/Right</span>\n         *     </div>\n         *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n         *       <ul>\n         *           <li>Item1</li>\n         *           <li>Item2</li>\n         *           <li>Item3</li>\n         *       </ul>\n         *     </kendo-popup>\n         *   </div>\n         * `\n         * })\n         * class AppComponent {\n         *   public checked: number = 3;\n         *   public mode: string = 'absolute';\n         *   public show: boolean = true;\n         * }\n         * ```\n         */\n        this.positionMode = 'fixed';\n        /**\n         * Specifies the absolute position of the element\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n         * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n         * The boundary detection is applied by using the window viewport.\n         */\n        this.offset = DEFAULT_OFFSET;\n        /**\n         * Fires when the anchor is scrolled outside the screen boundaries.\n         * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n         */\n        this.anchorViewportLeave = new EventEmitter();\n        /**\n         * Fires after the component is closed.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires after the component is opened and the opening animation ends.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires after the component is opened and the Popup is positioned.\n         */\n        this.positionChange = new EventEmitter();\n        this.resolvedPromise = Promise.resolve(null);\n        this.initialCheck = true;\n        this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n        this.updateFixedClass();\n    }\n    ngOnInit() {\n        this.reposition = this.reposition.bind(this);\n        this._resizeService.subscribe(this.reposition);\n        this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n        this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n        this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));\n        this.currentOffset = DEFAULT_OFFSET;\n        this.setZIndex();\n        this.copyFontStyles();\n        this.updateFixedClass();\n    }\n    ngOnChanges(changes) {\n        if (changes.copyAnchorStyles) {\n            this.copyFontStyles();\n        }\n        if (changes.positionMode) {\n            this.updateFixedClass();\n        }\n    }\n    ngAfterViewInit() {\n        this.reposition();\n        if (!this.animate) {\n            this.resolvedPromise.then(() => {\n                this.onAnimationEnd();\n            });\n        }\n    }\n    ngAfterViewChecked() {\n        if (this.initialCheck) {\n            this.initialCheck = false;\n            return;\n        }\n        this._zone.runOutsideAngular(() => {\n            // workarounds https://github.com/angular/angular/issues/19094\n            // uses promise because it is executed synchronously after the content is updated\n            // does not use onStable in case the current zone is not the angular one.\n            this.unsubscribeReposition();\n            this.repositionSubscription = from(this.resolvedPromise)\n                .subscribe(this.reposition);\n        });\n    }\n    ngOnDestroy() {\n        this.anchorViewportLeave.complete();\n        this.positionChange.complete();\n        this.close.emit();\n        this.close.complete();\n        this._resizeService.unsubscribe();\n        this._scrollableService.unsubscribe();\n        this.animationSubscriptions.unsubscribe();\n        this.unsubscribeReposition();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n        this.reposition();\n    }\n    onAnimationStart() {\n        this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n    }\n    onAnimationEnd() {\n        this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n        this.open.emit();\n        this.open.complete();\n    }\n    get currentOffset() {\n        return this._currentOffset;\n    }\n    set currentOffset(offset$$1) {\n        this.setContainerStyle('left', `${offset$$1.left}px`);\n        this.setContainerStyle('top', `${offset$$1.top}px`);\n        this._currentOffset = offset$$1;\n    }\n    setZIndex() {\n        if (this.anchor) {\n            this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));\n        }\n    }\n    reposition() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const { flip, offset: offset$$1 } = this.position();\n        if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {\n            this.currentOffset = offset$$1;\n            if (hasObservers(this.positionChange)) {\n                this._zone.run(() => this.positionChange.emit({ offset: offset$$1, flip }));\n            }\n        }\n        if (this.animate) {\n            this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n        }\n        this.resizeSensor.acceptSize();\n    }\n    position() {\n        const alignedOffset = this._alignService.alignElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin,\n            offset: this.offset,\n            positionMode: this.positionMode\n        });\n        return this._positionService.positionElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            collisions: this.collision,\n            currentLocation: alignedOffset,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin\n        });\n    }\n    onScroll(isInViewPort) {\n        const hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n        if (isInViewPort || !hasLeaveObservers) {\n            this.reposition();\n        }\n        else if (hasLeaveObservers) {\n            this._zone.run(() => {\n                this.anchorViewportLeave.emit();\n            });\n        }\n    }\n    copyFontStyles() {\n        if (!this.anchor || !this.copyAnchorStyles) {\n            return;\n        }\n        this.domService.getFontStyles(this.anchor)\n            .forEach(s => this.setContainerStyle(s.key, s.value));\n    }\n    updateFixedClass() {\n        const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n        this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n    }\n    setContainerStyle(name, value) {\n        this._renderer.setStyle(this.container.nativeElement, name, value);\n    }\n    unsubscribeReposition() {\n        if (this.repositionSubscription) {\n            this.repositionSubscription.unsubscribe();\n        }\n    }\n}\nPopupComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendo-popup',\n                providers: [AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService],\n                selector: 'kendo-popup',\n                template: `\n        <div class=\"k-popup\" [ngClass]=\"popupClass\" #container>\n            <ng-content></ng-content>\n            <ng-template [ngTemplateOutlet]=\"content\" [ngIf]=\"content\"></ng-template>\n            <kendo-resize-sensor [rateLimit]=\"100\" (resize)=\"onResize()\">\n            </kendo-resize-sensor>\n        </div>\n     `\n            },] },\n];\n/** @nocollapse */\nPopupComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: AlignService },\n    { type: DOMService },\n    { type: PositionService },\n    { type: ResizeService },\n    { type: ScrollableService },\n    { type: AnimationService },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nPopupComponent.propDecorators = {\n    animate: [{ type: Input }],\n    anchor: [{ type: Input }],\n    anchorAlign: [{ type: Input }],\n    collision: [{ type: Input }],\n    popupAlign: [{ type: Input }],\n    copyAnchorStyles: [{ type: Input }],\n    popupClass: [{ type: Input }],\n    positionMode: [{ type: Input }],\n    offset: [{ type: Input }],\n    margin: [{ type: Input }],\n    anchorViewportLeave: [{ type: Output }],\n    close: [{ type: Output }],\n    open: [{ type: Output }],\n    positionChange: [{ type: Output }],\n    contentContainer: [{ type: ViewChild, args: ['container',] }],\n    resizeSensor: [{ type: ViewChild, args: [ResizeSensorComponent,] }]\n};\n\nconst removeElement = (element) => {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { ElementRef, NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\nconst POPUP_CONTAINER = new InjectionToken('Popup Container');\n/**\n * A service for opening Popup components dynamically\n * ([see example]({% slug service_popup %})).\n *\n * @export\n * @class PopupService\n */\nclass PopupService {\n    constructor(applicationRef, componentFactoryResolver, injector, container) {\n        this.applicationRef = applicationRef;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this.injector = injector;\n        this.container = container;\n    }\n    /**\n     * Gets the root view container into which the component will be injected.\n     *\n     * @returns {ComponentRef<any>}\n     */\n    get rootViewContainer() {\n        // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n        const rootComponents = this.applicationRef.components || [];\n        if (rootComponents[0]) {\n            return rootComponents[0];\n        }\n        throw new Error(`\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\n        `);\n    }\n    /**\n     * Sets or gets the HTML element of the root component container.\n     *\n     * @returns {HTMLElement}\n     */\n    get rootViewContainerNode() {\n        return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n    }\n    /**\n     * Opens a Popup component. Created Popups are mounted\n     * in the DOM directly in the root application component.\n     *\n     * @param {PopupSettings} options - The options which define the Popup.\n     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <ng-template #template>\n     *      Popup content\n     *     </ng-template>\n     *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n     *   `\n     * })\n     * export class AppComponent {\n     *     public popupRef: PopupRef;\n     *\n     *     constructor( private popupService: PopupService ) {}\n     *\n     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n     *         if (this.popupRef) {\n     *              this.popupRef.close();\n     *              this.popupRef = null;\n     *              return;\n     *         }\n     *\n     *         this.popupRef = this.popupService.open({\n     *           anchor: anchor,\n     *           content: template\n     *         });\n     *     }\n     * }\n     * ```\n     */\n    open(options = {}) {\n        const { component, nodes } = this.contentFrom(options.content);\n        const popupComponentRef = this.appendPopup(nodes, options.appendTo);\n        const popupInstance = popupComponentRef.instance;\n        this.projectComponentInputs(popupComponentRef, options);\n        popupComponentRef.changeDetectorRef.detectChanges();\n        if (component) {\n            component.changeDetectorRef.detectChanges();\n        }\n        const popupElement = this.getComponentRootNode(popupComponentRef);\n        return {\n            close: () => {\n                if (component) {\n                    component.destroy();\n                }\n                popupComponentRef.destroy();\n                // Angular will not remove the element unless the change detection is triggered\n                removeElement(popupElement);\n            },\n            content: component,\n            popup: popupComponentRef,\n            popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n            popupClose: popupInstance.close,\n            popupElement: popupElement,\n            popupOpen: popupInstance.open,\n            popupPositionChange: popupInstance.positionChange\n        };\n    }\n    appendPopup(nodes, container) {\n        const popupComponentRef = this.createComponent(PopupComponent, nodes, container);\n        if (!container) {\n            this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n        }\n        return popupComponentRef;\n    }\n    /**\n     * Gets the HTML element for a component reference.\n     *\n     * @param {ComponentRef<any>} componentRef\n     * @returns {HTMLElement}\n     */\n    getComponentRootNode(componentRef) {\n        return componentRef.location.nativeElement;\n    }\n    /**\n     * Gets the `ComponentFactory` instance by its type.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    getComponentFactory(componentClass) {\n        return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n    }\n    /**\n     * Creates a component reference from a `Component` type class.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    createComponent(componentClass, nodes, container) {\n        const factory = this.getComponentFactory(componentClass);\n        if (container) {\n            return container.createComponent(factory, undefined, this.injector, nodes);\n        }\n        else {\n            const component = factory.create(this.injector, nodes);\n            this.applicationRef.attachView(component.hostView);\n            return component;\n        }\n    }\n    /**\n     * Projects the inputs on the component.\n     *\n     * @param {ComponentRef<any>} component\n     * @param {*} options\n     * @returns {ComponentRef<any>}\n     */\n    projectComponentInputs(component, options) {\n        Object.getOwnPropertyNames(options)\n            .filter(prop => prop !== 'content' || options.content instanceof TemplateRef)\n            .map((prop) => {\n            component.instance[prop] = options[prop];\n        });\n        return component;\n    }\n    /**\n     * Gets the component and the nodes to append from the `content` option.\n     *\n     * @param {*} content\n     * @returns {any}\n     */\n    contentFrom(content) {\n        if (!content || content instanceof TemplateRef) {\n            return { component: null, nodes: [[]] };\n        }\n        const component = this.createComponent(content);\n        const nodes = component ? [component.location.nativeElement] : [];\n        return {\n            component: component,\n            nodes: [\n                nodes // <ng-content>\n            ]\n        };\n    }\n}\nPopupService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nPopupService.ctorParameters = () => [\n    { type: ApplicationRef },\n    { type: ComponentFactoryResolver },\n    { type: Injector },\n    { type: ElementRef, decorators: [{ type: Inject, args: [POPUP_CONTAINER,] }, { type: Optional }] }\n];\n\nconst POPUP_DIRECTIVES = [PopupComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Popup component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass PopupModule {\n}\nPopupModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [POPUP_DIRECTIVES],\n                entryComponents: [POPUP_DIRECTIVES],\n                exports: [POPUP_DIRECTIVES],\n                imports: [CommonModule, ResizeSensorModule],\n                providers: [PopupService]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE };\n"]},"metadata":{},"sourceType":"module"}