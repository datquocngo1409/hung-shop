/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Injectable, InjectionToken, Inject, Optional, NgZone, EventEmitter, isDevMode, Component, ElementRef, Renderer2, Input, Output, ViewChild, TemplateRef, ApplicationRef, ComponentFactoryResolver, Injector, NgModule } from '@angular/core';
import { siblingContainer, parents, addScroll, align, boundingOffset, offset, positionWithScroll, removeScroll, restrictToView, scrollPosition, getWindowViewPort } from '@progress/kendo-popup-common';
import { isDocumentAvailable, hasObservers, ResizeSensorComponent, ResizeSensorModule } from '@progress/kendo-angular-common';
import { fromEvent, merge, from } from 'rxjs';
import { auditTime } from 'rxjs/operators';
import { style, animate, AnimationBuilder } from '@angular/animations';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@progress/kendo-angular-common';

const _c0 = ["container"];
function PopupComponent_ng_template_3_Template(rf, ctx) { }
const _c1 = ["*"];
const eitherRect = (rect, offset$$1) => {
    if (!rect) {
        return { height: 0, left: offset$$1.left, top: offset$$1.top, width: 0 };
    }
    return rect;
};
/**
 * @hidden
 */
const removeStackingOffset = (rect, stackingOffset) => {
    if (!stackingOffset) {
        return rect;
    }
    const result = {
        height: rect.height,
        left: rect.left - stackingOffset.left,
        top: rect.top - stackingOffset.top,
        width: rect.width
    };
    return result;
};
/**
 * @hidden
 */
const isDifferentOffset = (oldOffset, newOffset) => {
    const { left: oldLeft, top: oldTop } = oldOffset;
    const { left: newLeft, top: newTop } = newOffset;
    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;
};
/**
 * @hidden
 */
const isWindowAvailable = () => {
    return typeof window !== 'undefined';
};
/**
 * @hidden
 */
const OVERFLOW_REGEXP = /auto|scroll/;
const overflowElementStyle = (element) => {
    return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;
};
const overflowComputedStyle = (element) => {
    const styles = window.getComputedStyle(element);
    return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;
};
const overflowStyle = (element) => {
    return overflowElementStyle(element) || overflowComputedStyle(element);
};
/**
 * @hidden
 */
const scrollableParents = (element) => {
    const parentElements = [];
    if (!isDocumentAvailable() || !isWindowAvailable()) {
        return parentElements;
    }
    let parent = element.parentElement;
    while (parent) {
        if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {
            parentElements.push(parent);
        }
        parent = parent.parentElement;
    }
    parentElements.push(window);
    return parentElements;
};
/**
 * @hidden
 */
const FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps
function memoize(fun) {
    let result;
    let called = false;
    return (...args) => {
        if (called) {
            return result;
        }
        result = fun(...args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 */
const hasRelativeStackingContext = memoize(() => {
    if (!isDocumentAvailable() && document.body !== null) {
        return false;
    }
    const top = 10;
    const parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = `<div style="position: fixed; top: ${top}px;">child</div>`;
    document.body.appendChild(parent);
    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
});
/**
 * @hidden
 */
const zIndex = (anchor, container) => {
    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {
        return null;
    }
    const sibling = siblingContainer(anchor, container);
    if (!sibling) {
        return null;
    }
    const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {
        const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;
        const current = parseInt(zIndexStyle, 10);
        return current > index ? current : index;
    }, 0);
    return result ? (result + 1) : null;
};
/**
 * @hidden
 */
const scaleRect = (rect, scale) => {
    if (!rect || scale === 1) {
        return rect;
    }
    return {
        height: rect.height / scale,
        left: rect.left / scale,
        top: rect.top / scale,
        width: rect.width / scale
    };
};

const STYLES = [
    'font-size',
    'font-family',
    'font-stretch',
    'font-style',
    'font-weight',
    'line-height'
];
/**
 * @hidden
 */
class DOMService {
    addOffset(current, addition) {
        return {
            left: current.left + addition.left,
            top: current.top + addition.top
        };
    }
    addScroll(rect, scroll) {
        return addScroll(rect, scroll);
    }
    align(settings) {
        return align(settings);
    }
    boundingOffset(el) {
        return boundingOffset(this.nativeElement(el));
    }
    getFontStyles(el) {
        const window = this.getWindow();
        if (!window || !el) {
            return [];
        }
        const computedStyles = window.getComputedStyle(this.nativeElement(el));
        return STYLES.map(font => ({ key: font, value: computedStyles[font] }));
    }
    getWindow() {
        return isWindowAvailable() ? window : null;
    }
    hasOffsetParent(el) {
        if (!el) {
            return false;
        }
        return !!this.nativeElement(el).offsetParent;
    }
    offset(el) {
        if (!el) {
            return null;
        }
        return offset(this.nativeElement(el));
    }
    offsetAtPoint(el, currentLocation) {
        if (!el) {
            return null;
        }
        const element = this.nativeElement(el);
        const { left, top, transition } = element.style;
        element.style.transition = 'none';
        element.style.left = `${currentLocation.left}px`;
        element.style.top = `${currentLocation.top}px`;
        const currentOffset = offset(element);
        element.style.left = left;
        element.style.top = top;
        // prevents elements with transition to be animated because of the change
        // tslint:disable-next-line:no-unused-expression
        element.offsetHeight;
        element.style.transition = transition;
        return currentOffset;
    }
    nativeElement(el) {
        if (!el) {
            return null;
        }
        return el.nativeElement || el;
    }
    position(element, popup, scale = 1) {
        if (!element || !popup) {
            return null;
        }
        return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);
    }
    removeScroll(rect, scroll) {
        return removeScroll(rect, scroll);
    }
    restrictToView(settings) {
        return restrictToView(settings);
    }
    scrollPosition(el) {
        return scrollPosition(this.nativeElement(el));
    }
    scrollableParents(el) {
        return scrollableParents(this.nativeElement(el));
    }
    stackingElementOffset(el) {
        const relativeContextElement = this.getRelativeContextElement(el);
        if (!relativeContextElement) {
            return null;
        }
        return offset(relativeContextElement);
    }
    stackingElementScroll(el) {
        const relativeContextElement = this.getRelativeContextElement(el);
        if (!relativeContextElement) {
            return { x: 0, y: 0 };
        }
        return {
            x: relativeContextElement.scrollLeft,
            y: relativeContextElement.scrollTop
        };
    }
    getRelativeContextElement(el) {
        if (!el || !hasRelativeStackingContext()) {
            return null;
        }
        let parent = this.nativeElement(el).parentElement;
        while (parent) {
            if (window.getComputedStyle(parent).transform !== 'none') {
                return parent;
            }
            parent = parent.parentElement;
        }
        return null;
    }
    useRelativePosition(el) {
        return !!this.getRelativeContextElement(el);
    }
    windowViewPort(el) {
        return getWindowViewPort(this.nativeElement(el));
    }
    zIndex(anchor, container) {
        return zIndex(this.nativeElement(anchor), this.nativeElement(container));
    }
    zoomLevel() {
        if (!isDocumentAvailable() || !isWindowAvailable()) {
            return 1;
        }
        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;
    }
    isZoomed() {
        return this.zoomLevel() > 1;
    }
}
DOMService.ɵfac = function DOMService_Factory(t) { return new (t || DOMService)(); };
DOMService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DOMService, factory: DOMService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DOMService, [{
        type: Injectable
    }], null, null); })();

/**
 * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).
 *
 * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).
 *
 * > Using this token is not necessary for user-applied browser zoom.
 *
 * {% meta height:300 %}
 * {% embed_file scale/app.component.ts preview %}
 * {% embed_file scale/app.module.ts %}
 * {% embed_file scale/main.ts %}
 * {% endmeta %}
 *
 *
 */
const SCALE = new InjectionToken('Popup Document Scale');

/**
 * @hidden
 */
class AlignService {
    constructor(_dom, scale = 1) {
        this._dom = _dom;
        this.scale = scale;
    }
    alignElement(settings) {
        const { anchor, element, anchorAlign, elementAlign, margin, offset: offset$$1, positionMode } = settings;
        const scale = this.scale || 1;
        const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);
        const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);
        const elementRect = scaleRect(this._dom.offset(element), scale);
        const result = this._dom.align({
            anchorAlign: anchorAlign,
            anchorRect: anchorRect,
            elementAlign: elementAlign,
            elementRect: elementRect,
            margin
        });
        return result;
    }
    absoluteRect(anchor, element, offset$$1, scale) {
        const scrollPos = this.elementScrollPosition(anchor, element);
        const rect = eitherRect(this._dom.offset(anchor), offset$$1);
        const stackScale = 2 * scale;
        const stackScroll = this._dom.stackingElementScroll(element);
        if (scale !== 1 && stackScroll) {
            stackScroll.x /= stackScale;
            stackScroll.y /= stackScale;
        }
        const stackOffset = this._dom.stackingElementOffset(element);
        if (scale !== 1 && stackOffset) {
            stackOffset.left /= stackScale;
            stackOffset.top /= stackScale;
        }
        return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);
    }
    elementScrollPosition(anchor, element) {
        return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);
    }
    relativeRect(anchor, element, offset$$1, scale) {
        const rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);
        return scaleRect(rect, scale);
    }
}
AlignService.ɵfac = function AlignService_Factory(t) { return new (t || AlignService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8)); };
AlignService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AlignService, factory: AlignService.ɵfac });
/** @nocollapse */
AlignService.ctorParameters = () => [
    { type: DOMService },
    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AlignService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: Number, decorators: [{
                type: Inject,
                args: [SCALE]
            }, {
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class PositionService {
    constructor(_dom, scale = 1) {
        this._dom = _dom;
        this.scale = scale;
    }
    positionElement(settings) {
        const { anchor, currentLocation, element, anchorAlign, elementAlign, collisions, margin } = settings;
        const dom = this._dom;
        const scale = this.scale || 1;
        const elementOffset = dom.offsetAtPoint(element, currentLocation);
        const elementRect = scaleRect(elementOffset, scale);
        const anchorOffset = scaleRect(dom.offset(anchor), scale);
        const anchorRect = eitherRect(anchorOffset, currentLocation);
        const viewPort = settings.viewPort || dom.windowViewPort(element);
        viewPort.width = viewPort.width / scale;
        viewPort.height = viewPort.height / scale;
        const result = dom.restrictToView({
            anchorAlign,
            anchorRect,
            collisions,
            elementAlign,
            elementRect,
            margin,
            viewPort
        });
        const offset$$1 = dom.addOffset(currentLocation, result.offset);
        return {
            flip: result.flip,
            flipped: result.flipped,
            offset: offset$$1
        };
    }
}
PositionService.ɵfac = function PositionService_Factory(t) { return new (t || PositionService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8)); };
PositionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PositionService, factory: PositionService.ɵfac });
/** @nocollapse */
PositionService.ctorParameters = () => [
    { type: DOMService },
    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PositionService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: Number, decorators: [{
                type: Inject,
                args: [SCALE]
            }, {
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class ResizeService {
    constructor(_dom, _zone) {
        this._dom = _dom;
        this._zone = _zone;
    }
    subscribe(callback) {
        if (!isDocumentAvailable()) {
            return;
        }
        this._zone.runOutsideAngular(() => {
            this.subscription = fromEvent(this._dom.getWindow(), "resize")
                .pipe(auditTime(FRAME_DURATION))
                .subscribe(() => callback());
        });
    }
    unsubscribe() {
        if (!this.subscription) {
            return;
        }
        this.subscription.unsubscribe();
    }
    isUnsubscribed() {
        return this.subscription && this.subscription.closed;
    }
}
ResizeService.ɵfac = function ResizeService_Factory(t) { return new (t || ResizeService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(NgZone)); };
ResizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ResizeService, factory: ResizeService.ɵfac });
/** @nocollapse */
ResizeService.ctorParameters = () => [
    { type: DOMService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: NgZone }]; }, null); })();

/**
 * @hidden
 */
const THRESHOLD_DIFF = 1;
/**
 * @hidden
 */
class ScrollableService {
    constructor(_dom, _zone) {
        this._dom = _dom;
        this._zone = _zone;
    }
    forElement(element) {
        this.unsubscribe();
        this.element = element;
        return this;
    }
    subscribe(callback) {
        if (!callback || !isDocumentAvailable() || !this.element) {
            return;
        }
        const nativeElement = this._dom.nativeElement(this.element);
        const parents$$1 = this._dom.scrollableParents(this.element);
        this._zone.runOutsideAngular(() => {
            const observables = parents$$1.map(p => fromEvent(p, "scroll").pipe(auditTime(FRAME_DURATION)));
            const subscriber = (e) => {
                const target = e.target;
                const isParent = parents$$1.filter(p => p === target).length > 0;
                const isDocument = target === document;
                const isWindow = target === window;
                if (isParent || isDocument || isWindow) {
                    callback(this.isVisible(nativeElement, target));
                }
            };
            this.subscription = merge(...observables).subscribe(subscriber);
        });
    }
    unsubscribe() {
        if (!this.subscription) {
            return;
        }
        this.subscription.unsubscribe();
    }
    isVisible(elem, container) {
        const elemRect = this._dom.boundingOffset(elem);
        const containerRect = this._dom.boundingOffset(container);
        if (THRESHOLD_DIFF < (containerRect.top - elemRect.bottom)) {
            return false;
        }
        if (THRESHOLD_DIFF < (elemRect.top - containerRect.bottom)) {
            return false;
        }
        if (THRESHOLD_DIFF < (elemRect.left - containerRect.right)) {
            return false;
        }
        if (THRESHOLD_DIFF < (containerRect.left - elemRect.right)) {
            return false;
        }
        return true;
    }
}
ScrollableService.ɵfac = function ScrollableService_Factory(t) { return new (t || ScrollableService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(NgZone)); };
ScrollableService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScrollableService, factory: ScrollableService.ɵfac });
/** @nocollapse */
ScrollableService.ctorParameters = () => [
    { type: DOMService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScrollableService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: NgZone }]; }, null); })();

const LEFT = 'left';
const RIGHT = 'right';
const DOWN = 'down';
const UP = 'up';
const DEFAULT_TYPE = 'slide';
const DEFAULT_DURATION = 100;
const animationTypes = {};
/* tslint:disable:object-literal-sort-keys */
animationTypes.expand = (direction) => {
    const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';
    const startScale = 0;
    const endScale = 1;
    let origin;
    if (direction === DOWN) {
        origin = 'top';
    }
    else if (direction === LEFT) {
        origin = RIGHT;
    }
    else if (direction === RIGHT) {
        origin = LEFT;
    }
    else {
        origin = 'bottom';
    }
    return {
        start: { transform: `${scale}(${startScale})`, transformOrigin: origin },
        end: { transform: `${scale}(${endScale})` }
    };
};
animationTypes.slide = (direction) => {
    const translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';
    const start = direction === RIGHT || direction === DOWN ? -100 : 100;
    const end = 0;
    return {
        start: { transform: `${translate}(${start}%)` },
        end: { transform: `${translate}(${end}%)` }
    };
};
animationTypes.fade = () => {
    return {
        start: { opacity: 0 },
        end: { opacity: 1 }
    };
};
animationTypes.zoom = () => {
    const start = 0;
    const end = 1;
    return {
        start: { transform: `scale(${start})` },
        end: { transform: `scale(${end})` }
    };
};
/**
 * @hidden
 */
class AnimationService {
    constructor(animationBuilder) {
        this.animationBuilder = animationBuilder;
        this.start = new EventEmitter();
        this.end = new EventEmitter();
    }
    play(element, options, flip) {
        if (!this.flip || this.flip.horizontal !== flip.horizontal ||
            this.flip.vertical !== flip.vertical) {
            this.flip = flip;
            const type = options.type || DEFAULT_TYPE;
            const statesFn = animationTypes[type];
            if (statesFn) {
                const direction = this.getDirection(flip, options);
                const states = statesFn(direction);
                this.playStates(element, states, options);
            }
            else if (isDevMode()) {
                throw new Error(`Unsupported animation type: "${type}". The supported types are slide, expand, fade and zoom.`);
            }
        }
    }
    ngOnDestroy() {
        this.stopPlayer();
    }
    playStates(element, states, options) {
        this.stopPlayer();
        const duration = options.duration || DEFAULT_DURATION;
        const factory = this.animationBuilder.build([
            style(states.start),
            animate(`${duration}ms ease-in`, style(states.end))
        ]);
        const player = this.player = factory.create(element);
        player.onDone(() => {
            this.end.emit();
            this.stopPlayer();
        });
        this.start.emit();
        player.play();
    }
    getDirection(flip, options) {
        let direction = options.direction || DOWN;
        if (flip.horizontal) {
            if (direction === LEFT) {
                direction = RIGHT;
            }
            else if (direction === RIGHT) {
                direction = LEFT;
            }
        }
        if (flip.vertical) {
            if (direction === DOWN) {
                direction = UP;
            }
            else if (direction === UP) {
                direction = DOWN;
            }
        }
        return direction;
    }
    stopPlayer() {
        if (this.player) {
            this.player.destroy();
            this.player = null;
        }
    }
}
AnimationService.ɵfac = function AnimationService_Factory(t) { return new (t || AnimationService)(ɵngcc0.ɵɵinject(AnimationBuilder)); };
AnimationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AnimationService, factory: AnimationService.ɵfac });
/** @nocollapse */
AnimationService.ctorParameters = () => [
    { type: AnimationBuilder }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AnimationService, [{
        type: Injectable
    }], function () { return [{ type: AnimationBuilder }]; }, null); })();

const DEFAULT_OFFSET = { left: -10000, top: 0 };
const ANIMATION_CONTAINER = 'k-animation-container';
const ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';
/**
 * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <button #anchor (click)="show=!show">Toggle</button>
 *  <kendo-popup *ngIf="show" [anchor]="anchor">
 *      <strong>Popup content!</strong>
 *  </kendo-popup>
 * `
 * })
 * class AppComponent {
 *   public show: boolean = false;
 * }
 * ```
 */
class PopupComponent {
    constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {
        this.container = container;
        this._alignService = _alignService;
        this.domService = domService;
        this._positionService = _positionService;
        this._resizeService = _resizeService;
        this._scrollableService = _scrollableService;
        this.animationService = animationService;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Controls the Popup animation. By default, the opening and closing animations
         * are enabled ([see example]({% slug animations_popup %})).
         */
        this.animate = true;
        /**
         * Specifies the anchor pivot point
         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).
         */
        this.anchorAlign = { horizontal: 'left', vertical: 'bottom' };
        /**
         * Configures the collision behavior of the Popup
         * ([see example]({% slug viewportboundarydetection_popup %})).
         */
        this.collision = { horizontal: 'fit', vertical: 'flip' };
        /**
         * Specifies the pivot point of the Popup
         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).
         */
        this.popupAlign = { horizontal: 'left', vertical: 'top' };
        /**
         * Controls whether the component will copy the `anchor` font styles.
         */
        this.copyAnchorStyles = false;
        /**
         * Specifies the position mode of the component. By default, the Popup uses fixed positioning.
         * To make the Popup acquire absolute positioning, set this option to `absolute`.
         *
         * > If you need to support mobile browsers with the zoom option,
         * use the `absolute` positioning of the Popup.
         *
         * @example
         * ```html
         * <style>
         *  .parent-content {
         *     position: relative;
         *     width: 200px;
         *     height: 200px;
         *     overflow: auto;
         *     margin: 200px auto;
         *     border: 1px solid red;
         *  }
         *  .content {
         *     position: relative;
         *     width: 100px;
         *     height: 100px;
         *     overflow: auto;
         *     margin: 300px;
         *     border: 1px solid blue;
         *  }
         *  .anchor {
         *     position: absolute;
         *     top: 200px;
         *     left: 200px;
         *  }
         * </style>
         * ```
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *   <div class="example-config">
         *      Position mode:
         *      <label><input type="radio" value="fixed" [(ngModel)]="mode" /> Fixed</label>
         *      <label><input type="radio" value="absolute" [(ngModel)]="mode" /> Absolute</label>
         *   </div>
         *   <div class="example-config">
         *       Append to
         *       <label>
         *           <input type="radio" name="place" [value]="1" [(ngModel)]="checked" />
         *           Root component
         *       </label>
         *       <label>
         *           <input type="radio" name="place" [value]="2" [(ngModel)]="checked" />
         *           <span style="color: red">Red Container</span>
         *       </label>
         *       <label>
         *           <input type="radio" name="place" [value]="3" [(ngModel)]="checked" />
         *           <span style="color: blue">Blue Container</span>
         *       </label>
         *   </div>
         *   <div class="example">
         *     <div class="parent-content" [scrollLeft]="250" [scrollTop]="230">
         *         <div class="content" [scrollLeft]="170" [scrollTop]="165">
         *           <button #anchor class="anchor" (click)="show = !show">Toggle</button>
         *           <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 3">
         *             <ul>
         *                 <li>Item1</li>
         *                 <li>Item2</li>
         *                 <li>Item3</li>
         *             </ul>
         *           </kendo-popup>
         *           <span style="position: absolute; top: 400px; left: 400px">Bottom/Right</span>
         *         </div>
         *         <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 2">
         *           <ul>
         *               <li>Item1</li>
         *               <li>Item2</li>
         *               <li>Item3</li>
         *           </ul>
         *         </kendo-popup>
         *         <span style="position: absolute; top: 600px; left: 600px">Bottom/Right</span>
         *     </div>
         *     <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 1">
         *       <ul>
         *           <li>Item1</li>
         *           <li>Item2</li>
         *           <li>Item3</li>
         *       </ul>
         *     </kendo-popup>
         *   </div>
         * `
         * })
         * class AppComponent {
         *   public checked: number = 3;
         *   public mode: string = 'absolute';
         *   public show: boolean = true;
         * }
         * ```
         */
        this.positionMode = 'fixed';
        /**
         * Specifies the absolute position of the element
         * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).
         * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.
         * The boundary detection is applied by using the window viewport.
         */
        this.offset = DEFAULT_OFFSET;
        /**
         * Fires when the anchor is scrolled outside the screen boundaries.
         * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).
         */
        this.anchorViewportLeave = new EventEmitter();
        /**
         * Fires after the component is closed.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the component is opened and the opening animation ends.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the component is opened and the Popup is positioned.
         */
        this.positionChange = new EventEmitter();
        this.resolvedPromise = Promise.resolve(null);
        this.initialCheck = true;
        this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);
        this.updateFixedClass();
    }
    ngOnInit() {
        this.reposition = this.reposition.bind(this);
        this._resizeService.subscribe(this.reposition);
        this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));
        this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));
        this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));
        this.currentOffset = DEFAULT_OFFSET;
        this.setZIndex();
        this.copyFontStyles();
        this.updateFixedClass();
    }
    ngOnChanges(changes) {
        if (changes.copyAnchorStyles) {
            this.copyFontStyles();
        }
        if (changes.positionMode) {
            this.updateFixedClass();
        }
    }
    ngAfterViewInit() {
        this.reposition();
        if (!this.animate) {
            this.resolvedPromise.then(() => {
                this.onAnimationEnd();
            });
        }
    }
    ngAfterViewChecked() {
        if (this.initialCheck) {
            this.initialCheck = false;
            return;
        }
        this._zone.runOutsideAngular(() => {
            // workarounds https://github.com/angular/angular/issues/19094
            // uses promise because it is executed synchronously after the content is updated
            // does not use onStable in case the current zone is not the angular one.
            this.unsubscribeReposition();
            this.repositionSubscription = from(this.resolvedPromise)
                .subscribe(this.reposition);
        });
    }
    ngOnDestroy() {
        this.anchorViewportLeave.complete();
        this.positionChange.complete();
        this.close.emit();
        this.close.complete();
        this._resizeService.unsubscribe();
        this._scrollableService.unsubscribe();
        this.animationSubscriptions.unsubscribe();
        this.unsubscribeReposition();
    }
    /**
     * @hidden
     */
    onResize() {
        this.reposition();
    }
    onAnimationStart() {
        this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');
    }
    onAnimationEnd() {
        this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');
        this.open.emit();
        this.open.complete();
    }
    get currentOffset() {
        return this._currentOffset;
    }
    set currentOffset(offset$$1) {
        this.setContainerStyle('left', `${offset$$1.left}px`);
        this.setContainerStyle('top', `${offset$$1.top}px`);
        this._currentOffset = offset$$1;
    }
    setZIndex() {
        if (this.anchor) {
            this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));
        }
    }
    reposition() {
        if (!isDocumentAvailable()) {
            return;
        }
        const { flip, offset: offset$$1 } = this.position();
        if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {
            this.currentOffset = offset$$1;
            if (hasObservers(this.positionChange)) {
                this._zone.run(() => this.positionChange.emit({ offset: offset$$1, flip }));
            }
        }
        if (this.animate) {
            this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);
        }
        this.resizeSensor.acceptSize();
    }
    position() {
        const alignedOffset = this._alignService.alignElement({
            anchor: this.anchor,
            anchorAlign: this.anchorAlign,
            element: this.container,
            elementAlign: this.popupAlign,
            margin: this.margin,
            offset: this.offset,
            positionMode: this.positionMode
        });
        return this._positionService.positionElement({
            anchor: this.anchor,
            anchorAlign: this.anchorAlign,
            collisions: this.collision,
            currentLocation: alignedOffset,
            element: this.container,
            elementAlign: this.popupAlign,
            margin: this.margin
        });
    }
    onScroll(isInViewPort) {
        const hasLeaveObservers = hasObservers(this.anchorViewportLeave);
        if (isInViewPort || !hasLeaveObservers) {
            this.reposition();
        }
        else if (hasLeaveObservers) {
            this._zone.run(() => {
                this.anchorViewportLeave.emit();
            });
        }
    }
    copyFontStyles() {
        if (!this.anchor || !this.copyAnchorStyles) {
            return;
        }
        this.domService.getFontStyles(this.anchor)
            .forEach(s => this.setContainerStyle(s.key, s.value));
    }
    updateFixedClass() {
        const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';
        this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);
    }
    setContainerStyle(name, value) {
        this._renderer.setStyle(this.container.nativeElement, name, value);
    }
    unsubscribeReposition() {
        if (this.repositionSubscription) {
            this.repositionSubscription.unsubscribe();
        }
    }
}
PopupComponent.ɵfac = function PopupComponent_Factory(t) { return new (t || PopupComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(AlignService), ɵngcc0.ɵɵdirectiveInject(DOMService), ɵngcc0.ɵɵdirectiveInject(PositionService), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(ScrollableService), ɵngcc0.ɵɵdirectiveInject(AnimationService), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(NgZone)); };
PopupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PopupComponent, selectors: [["kendo-popup"]], viewQuery: function PopupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(ResizeSensorComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);
    } }, inputs: { animate: "animate", anchorAlign: "anchorAlign", collision: "collision", popupAlign: "popupAlign", copyAnchorStyles: "copyAnchorStyles", positionMode: "positionMode", offset: "offset", anchor: "anchor", popupClass: "popupClass", margin: "margin" }, outputs: { anchorViewportLeave: "anchorViewportLeave", close: "close", open: "open", positionChange: "positionChange" }, exportAs: ["kendo-popup"], features: [ɵngcc0.ɵɵProvidersFeature([AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 5, vars: 4, consts: [[1, "k-popup", 3, "ngClass"], ["container", ""], [3, "ngTemplateOutlet", "ngIf"], [3, "rateLimit", "resize"]], template: function PopupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵtemplate(3, PopupComponent_ng_template_3_Template, 0, 0, "ng-template", 2);
        ɵngcc0.ɵɵelementStart(4, "kendo-resize-sensor", 3);
        ɵngcc0.ɵɵlistener("resize", function PopupComponent_Template_kendo_resize_sensor_resize_4_listener() { return ctx.onResize(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.popupClass);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.content)("ngIf", ctx.content);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("rateLimit", 100);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgIf, ɵngcc2.ResizeSensorComponent], encapsulation: 2 });
/** @nocollapse */
PopupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AlignService },
    { type: DOMService },
    { type: PositionService },
    { type: ResizeService },
    { type: ScrollableService },
    { type: AnimationService },
    { type: Renderer2 },
    { type: NgZone }
];
PopupComponent.propDecorators = {
    animate: [{ type: Input }],
    anchor: [{ type: Input }],
    anchorAlign: [{ type: Input }],
    collision: [{ type: Input }],
    popupAlign: [{ type: Input }],
    copyAnchorStyles: [{ type: Input }],
    popupClass: [{ type: Input }],
    positionMode: [{ type: Input }],
    offset: [{ type: Input }],
    margin: [{ type: Input }],
    anchorViewportLeave: [{ type: Output }],
    close: [{ type: Output }],
    open: [{ type: Output }],
    positionChange: [{ type: Output }],
    contentContainer: [{ type: ViewChild, args: ['container',] }],
    resizeSensor: [{ type: ViewChild, args: [ResizeSensorComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopupComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendo-popup',
                providers: [AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService],
                selector: 'kendo-popup',
                template: `
        <div class="k-popup" [ngClass]="popupClass" #container>
            <ng-content></ng-content>
            <ng-template [ngTemplateOutlet]="content" [ngIf]="content"></ng-template>
            <kendo-resize-sensor [rateLimit]="100" (resize)="onResize()">
            </kendo-resize-sensor>
        </div>
     `
            }]
    }], function () { return [{ type: ElementRef }, { type: AlignService }, { type: DOMService }, { type: PositionService }, { type: ResizeService }, { type: ScrollableService }, { type: AnimationService }, { type: Renderer2 }, { type: NgZone }]; }, { animate: [{
            type: Input
        }], anchorAlign: [{
            type: Input
        }], collision: [{
            type: Input
        }], popupAlign: [{
            type: Input
        }], copyAnchorStyles: [{
            type: Input
        }], positionMode: [{
            type: Input
        }], offset: [{
            type: Input
        }], anchorViewportLeave: [{
            type: Output
        }], close: [{
            type: Output
        }], open: [{
            type: Output
        }], positionChange: [{
            type: Output
        }], anchor: [{
            type: Input
        }], popupClass: [{
            type: Input
        }], margin: [{
            type: Input
        }], contentContainer: [{
            type: ViewChild,
            args: ['container']
        }], resizeSensor: [{
            type: ViewChild,
            args: [ResizeSensorComponent]
        }] }); })();

const removeElement = (element) => {
    if (element && element.parentNode) {
        element.parentNode.removeChild(element);
    }
};
/**
 * Used to inject the Popup container. If not provided, the first root component of
 * the application is used.
 *
 * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Popup module
 * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { ElementRef, NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, PopupModule], // import Popup module
 *     bootstrap:    [AppComponent],
 *     providers: [{
 *       provide: POPUP_CONTAINER,
 *       useFactory: () => {
 *          //return the container ElementRef, where the popup will be injected
 *          return { nativeElement: document.body } as ElementRef;
 *       }
 *     }]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 * ```
 */
const POPUP_CONTAINER = new InjectionToken('Popup Container');
/**
 * A service for opening Popup components dynamically
 * ([see example]({% slug service_popup %})).
 *
 * @export
 * @class PopupService
 */
class PopupService {
    constructor(applicationRef, componentFactoryResolver, injector, container) {
        this.applicationRef = applicationRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.container = container;
    }
    /**
     * Gets the root view container into which the component will be injected.
     *
     * @returns {ComponentRef<any>}
     */
    get rootViewContainer() {
        // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571
        const rootComponents = this.applicationRef.components || [];
        if (rootComponents[0]) {
            return rootComponents[0];
        }
        throw new Error(`
            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.
            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.
        `);
    }
    /**
     * Sets or gets the HTML element of the root component container.
     *
     * @returns {HTMLElement}
     */
    get rootViewContainerNode() {
        return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);
    }
    /**
     * Opens a Popup component. Created Popups are mounted
     * in the DOM directly in the root application component.
     *
     * @param {PopupSettings} options - The options which define the Popup.
     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.
     *
     * @example
     *
     * ```ts-no-run
     * _@Component({
     *   selector: 'my-app',
     *   template: `
     *     <ng-template #template>
     *      Popup content
     *     </ng-template>
     *     <button #anchor kendoButton (click)="open(anchor, template)">Open</button>
     *   `
     * })
     * export class AppComponent {
     *     public popupRef: PopupRef;
     *
     *     constructor( private popupService: PopupService ) {}
     *
     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {
     *         if (this.popupRef) {
     *              this.popupRef.close();
     *              this.popupRef = null;
     *              return;
     *         }
     *
     *         this.popupRef = this.popupService.open({
     *           anchor: anchor,
     *           content: template
     *         });
     *     }
     * }
     * ```
     */
    open(options = {}) {
        const { component, nodes } = this.contentFrom(options.content);
        const popupComponentRef = this.appendPopup(nodes, options.appendTo);
        const popupInstance = popupComponentRef.instance;
        this.projectComponentInputs(popupComponentRef, options);
        popupComponentRef.changeDetectorRef.detectChanges();
        if (component) {
            component.changeDetectorRef.detectChanges();
        }
        const popupElement = this.getComponentRootNode(popupComponentRef);
        return {
            close: () => {
                if (component) {
                    component.destroy();
                }
                popupComponentRef.destroy();
                // Angular will not remove the element unless the change detection is triggered
                removeElement(popupElement);
            },
            content: component,
            popup: popupComponentRef,
            popupAnchorViewportLeave: popupInstance.anchorViewportLeave,
            popupClose: popupInstance.close,
            popupElement: popupElement,
            popupOpen: popupInstance.open,
            popupPositionChange: popupInstance.positionChange
        };
    }
    appendPopup(nodes, container) {
        const popupComponentRef = this.createComponent(PopupComponent, nodes, container);
        if (!container) {
            this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));
        }
        return popupComponentRef;
    }
    /**
     * Gets the HTML element for a component reference.
     *
     * @param {ComponentRef<any>} componentRef
     * @returns {HTMLElement}
     */
    getComponentRootNode(componentRef) {
        return componentRef.location.nativeElement;
    }
    /**
     * Gets the `ComponentFactory` instance by its type.
     *
     * @param {*} componentClass
     * @param {*} nodes
     * @returns {ComponentRef<any>}
     */
    getComponentFactory(componentClass) {
        return this.componentFactoryResolver.resolveComponentFactory(componentClass);
    }
    /**
     * Creates a component reference from a `Component` type class.
     *
     * @param {*} componentClass
     * @param {*} nodes
     * @returns {ComponentRef<any>}
     */
    createComponent(componentClass, nodes, container) {
        const factory = this.getComponentFactory(componentClass);
        if (container) {
            return container.createComponent(factory, undefined, this.injector, nodes);
        }
        else {
            const component = factory.create(this.injector, nodes);
            this.applicationRef.attachView(component.hostView);
            return component;
        }
    }
    /**
     * Projects the inputs on the component.
     *
     * @param {ComponentRef<any>} component
     * @param {*} options
     * @returns {ComponentRef<any>}
     */
    projectComponentInputs(component, options) {
        Object.getOwnPropertyNames(options)
            .filter(prop => prop !== 'content' || options.content instanceof TemplateRef)
            .map((prop) => {
            component.instance[prop] = options[prop];
        });
        return component;
    }
    /**
     * Gets the component and the nodes to append from the `content` option.
     *
     * @param {*} content
     * @returns {any}
     */
    contentFrom(content) {
        if (!content || content instanceof TemplateRef) {
            return { component: null, nodes: [[]] };
        }
        const component = this.createComponent(content);
        const nodes = component ? [component.location.nativeElement] : [];
        return {
            component: component,
            nodes: [
                nodes // <ng-content>
            ]
        };
    }
}
PopupService.ɵfac = function PopupService_Factory(t) { return new (t || PopupService)(ɵngcc0.ɵɵinject(ApplicationRef), ɵngcc0.ɵɵinject(ComponentFactoryResolver), ɵngcc0.ɵɵinject(Injector), ɵngcc0.ɵɵinject(POPUP_CONTAINER, 8)); };
PopupService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PopupService, factory: PopupService.ɵfac });
/** @nocollapse */
PopupService.ctorParameters = () => [
    { type: ApplicationRef },
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: ElementRef, decorators: [{ type: Inject, args: [POPUP_CONTAINER,] }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopupService, [{
        type: Injectable
    }], function () { return [{ type: ApplicationRef }, { type: ComponentFactoryResolver }, { type: Injector }, { type: ElementRef, decorators: [{
                type: Inject,
                args: [POPUP_CONTAINER]
            }, {
                type: Optional
            }] }]; }, null); })();

const POPUP_DIRECTIVES = [PopupComponent];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Popup component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Popup module
 * import { PopupModule } from '@progress/kendo-angular-popup';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, PopupModule], // import Popup module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class PopupModule {
}
PopupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PopupModule });
PopupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PopupModule_Factory(t) { return new (t || PopupModule)(); }, providers: [PopupService], imports: [[CommonModule, ResizeSensorModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PopupModule, { declarations: function () { return [PopupComponent]; }, imports: function () { return [CommonModule, ResizeSensorModule]; }, exports: function () { return [PopupComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopupModule, [{
        type: NgModule,
        args: [{
                declarations: [POPUP_DIRECTIVES],
                entryComponents: [POPUP_DIRECTIVES],
                exports: [POPUP_DIRECTIVES],
                imports: [CommonModule, ResizeSensorModule],
                providers: [PopupService]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0dBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUdBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7c0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttSEFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztzRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnSEFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7MEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0hBZUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0dBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzBCQVNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdCwgT3B0aW9uYWwsIE5nWm9uZSwgRXZlbnRFbWl0dGVyLCBpc0Rldk1vZGUsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgUmVuZGVyZXIyLCBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQsIFRlbXBsYXRlUmVmLCBBcHBsaWNhdGlvblJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBJbmplY3RvciwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHNpYmxpbmdDb250YWluZXIsIHBhcmVudHMsIGFkZFNjcm9sbCwgYWxpZ24sIGJvdW5kaW5nT2Zmc2V0LCBvZmZzZXQsIHBvc2l0aW9uV2l0aFNjcm9sbCwgcmVtb3ZlU2Nyb2xsLCByZXN0cmljdFRvVmlldywgc2Nyb2xsUG9zaXRpb24sIGdldFdpbmRvd1ZpZXdQb3J0IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLXBvcHVwLWNvbW1vbic7XG5pbXBvcnQgeyBpc0RvY3VtZW50QXZhaWxhYmxlLCBoYXNPYnNlcnZlcnMsIFJlc2l6ZVNlbnNvckNvbXBvbmVudCwgUmVzaXplU2Vuc29yTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIGZyb20gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGF1ZGl0VGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IHN0eWxlLCBhbmltYXRlLCBBbmltYXRpb25CdWlsZGVyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZWl0aGVyUmVjdCA9IChyZWN0LCBvZmZzZXQkJDEpID0+IHtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiAwLCBsZWZ0OiBvZmZzZXQkJDEubGVmdCwgdG9wOiBvZmZzZXQkJDEudG9wLCB3aWR0aDogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmVtb3ZlU3RhY2tpbmdPZmZzZXQgPSAocmVjdCwgc3RhY2tpbmdPZmZzZXQpID0+IHtcbiAgICBpZiAoIXN0YWNraW5nT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIHN0YWNraW5nT2Zmc2V0LmxlZnQsXG4gICAgICAgIHRvcDogcmVjdC50b3AgLSBzdGFja2luZ09mZnNldC50b3AsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0RpZmZlcmVudE9mZnNldCA9IChvbGRPZmZzZXQsIG5ld09mZnNldCkgPT4ge1xuICAgIGNvbnN0IHsgbGVmdDogb2xkTGVmdCwgdG9wOiBvbGRUb3AgfSA9IG9sZE9mZnNldDtcbiAgICBjb25zdCB7IGxlZnQ6IG5ld0xlZnQsIHRvcDogbmV3VG9wIH0gPSBuZXdPZmZzZXQ7XG4gICAgcmV0dXJuIE1hdGguYWJzKG9sZExlZnQgLSBuZXdMZWZ0KSA+PSAxIHx8IE1hdGguYWJzKG9sZFRvcCAtIG5ld1RvcCkgPj0gMTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNXaW5kb3dBdmFpbGFibGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBPVkVSRkxPV19SRUdFWFAgPSAvYXV0b3xzY3JvbGwvO1xuY29uc3Qgb3ZlcmZsb3dFbGVtZW50U3R5bGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBgJHtlbGVtZW50LnN0eWxlLm92ZXJmbG93fSR7ZWxlbWVudC5zdHlsZS5vdmVyZmxvd1h9JHtlbGVtZW50LnN0eWxlLm92ZXJmbG93WX1gO1xufTtcbmNvbnN0IG92ZXJmbG93Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGAke3N0eWxlcy5vdmVyZmxvd30ke3N0eWxlcy5vdmVyZmxvd1h9JHtzdHlsZXMub3ZlcmZsb3dZfWA7XG59O1xuY29uc3Qgb3ZlcmZsb3dTdHlsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIG92ZXJmbG93RWxlbWVudFN0eWxlKGVsZW1lbnQpIHx8IG92ZXJmbG93Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2Nyb2xsYWJsZVBhcmVudHMgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnRzID0gW107XG4gICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkgfHwgIWlzV2luZG93QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudEVsZW1lbnRzO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKE9WRVJGTE9XX1JFR0VYUC50ZXN0KG92ZXJmbG93U3R5bGUocGFyZW50KSkgfHwgcGFyZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zY3JvbGxhYmxlJykpIHtcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcGFyZW50RWxlbWVudHMucHVzaCh3aW5kb3cpO1xuICAgIHJldHVybiBwYXJlbnRFbGVtZW50cztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgRlJBTUVfRFVSQVRJT04gPSAxMDAwIC8gNjA7IC8vMTAwMG1zIGRpdmlkZWQgYnkgNjBmcHNcbmZ1bmN0aW9uIG1lbW9pemUoZnVuKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZnVuKC4uLmFyZ3MpO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzUmVsYXRpdmVTdGFja2luZ0NvbnRleHQgPSBtZW1vaXplKCgpID0+IHtcbiAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBkb2N1bWVudC5ib2R5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gMTA7XG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwYXJlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgoMTAsIDAsIDAsIDEwLCAwLCAwKVwiO1xuICAgIHBhcmVudC5pbm5lckhUTUwgPSBgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBmaXhlZDsgdG9wOiAke3RvcH1weDtcIj5jaGlsZDwvZGl2PmA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYXJlbnQpO1xuICAgIGNvbnN0IGlzRGlmZmVyZW50ID0gcGFyZW50LmNoaWxkcmVuWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAhPT0gdG9wO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGFyZW50KTtcbiAgICByZXR1cm4gaXNEaWZmZXJlbnQ7XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB6SW5kZXggPSAoYW5jaG9yLCBjb250YWluZXIpID0+IHtcbiAgICBpZiAoIWFuY2hvciB8fCAhaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICFpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ0NvbnRhaW5lcihhbmNob3IsIGNvbnRhaW5lcik7XG4gICAgaWYgKCFzaWJsaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbYW5jaG9yXS5jb25jYXQocGFyZW50cyhhbmNob3IsIHNpYmxpbmcpKS5yZWR1Y2UoKGluZGV4LCBwKSA9PiB7XG4gICAgICAgIGNvbnN0IHpJbmRleFN0eWxlID0gcC5zdHlsZS56SW5kZXggfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUocCkuekluZGV4O1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VJbnQoekluZGV4U3R5bGUsIDEwKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPiBpbmRleCA/IGN1cnJlbnQgOiBpbmRleDtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gcmVzdWx0ID8gKHJlc3VsdCArIDEpIDogbnVsbDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc2NhbGVSZWN0ID0gKHJlY3QsIHNjYWxlKSA9PiB7XG4gICAgaWYgKCFyZWN0IHx8IHNjYWxlID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gc2NhbGUsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCAvIHNjYWxlLFxuICAgICAgICB0b3A6IHJlY3QudG9wIC8gc2NhbGUsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC8gc2NhbGVcbiAgICB9O1xufTtcblxuY29uc3QgU1RZTEVTID0gW1xuICAgICdmb250LXNpemUnLFxuICAgICdmb250LWZhbWlseScsXG4gICAgJ2ZvbnQtc3RyZXRjaCcsXG4gICAgJ2ZvbnQtc3R5bGUnLFxuICAgICdmb250LXdlaWdodCcsXG4gICAgJ2xpbmUtaGVpZ2h0J1xuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBET01TZXJ2aWNlIHtcbiAgICBhZGRPZmZzZXQoY3VycmVudCwgYWRkaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGN1cnJlbnQubGVmdCArIGFkZGl0aW9uLmxlZnQsXG4gICAgICAgICAgICB0b3A6IGN1cnJlbnQudG9wICsgYWRkaXRpb24udG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZFNjcm9sbChyZWN0LCBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIGFkZFNjcm9sbChyZWN0LCBzY3JvbGwpO1xuICAgIH1cbiAgICBhbGlnbihzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gYWxpZ24oc2V0dGluZ3MpO1xuICAgIH1cbiAgICBib3VuZGluZ09mZnNldChlbCkge1xuICAgICAgICByZXR1cm4gYm91bmRpbmdPZmZzZXQodGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgfVxuICAgIGdldEZvbnRTdHlsZXMoZWwpIHtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gdGhpcy5nZXRXaW5kb3coKTtcbiAgICAgICAgaWYgKCF3aW5kb3cgfHwgIWVsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpKTtcbiAgICAgICAgcmV0dXJuIFNUWUxFUy5tYXAoZm9udCA9PiAoeyBrZXk6IGZvbnQsIHZhbHVlOiBjb21wdXRlZFN0eWxlc1tmb250XSB9KSk7XG4gICAgfVxuICAgIGdldFdpbmRvdygpIHtcbiAgICAgICAgcmV0dXJuIGlzV2luZG93QXZhaWxhYmxlKCkgPyB3aW5kb3cgOiBudWxsO1xuICAgIH1cbiAgICBoYXNPZmZzZXRQYXJlbnQoZWwpIHtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMubmF0aXZlRWxlbWVudChlbCkub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgICBvZmZzZXQoZWwpIHtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldCh0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpKTtcbiAgICB9XG4gICAgb2Zmc2V0QXRQb2ludChlbCwgY3VycmVudExvY2F0aW9uKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpO1xuICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCwgdHJhbnNpdGlvbiB9ID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtjdXJyZW50TG9jYXRpb24ubGVmdH1weGA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7Y3VycmVudExvY2F0aW9uLnRvcH1weGA7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBvZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gdG9wO1xuICAgICAgICAvLyBwcmV2ZW50cyBlbGVtZW50cyB3aXRoIHRyYW5zaXRpb24gdG8gYmUgYW5pbWF0ZWQgYmVjYXVzZSBvZiB0aGUgY2hhbmdlXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuICAgICAgICBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIG5hdGl2ZUVsZW1lbnQoZWwpIHtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLm5hdGl2ZUVsZW1lbnQgfHwgZWw7XG4gICAgfVxuICAgIHBvc2l0aW9uKGVsZW1lbnQsIHBvcHVwLCBzY2FsZSA9IDEpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFwb3B1cCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uV2l0aFNjcm9sbCh0aGlzLm5hdGl2ZUVsZW1lbnQoZWxlbWVudCksIHRoaXMubmF0aXZlRWxlbWVudChwb3B1cCksIHNjYWxlKTtcbiAgICB9XG4gICAgcmVtb3ZlU2Nyb2xsKHJlY3QsIHNjcm9sbCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsKHJlY3QsIHNjcm9sbCk7XG4gICAgfVxuICAgIHJlc3RyaWN0VG9WaWV3KHNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiByZXN0cmljdFRvVmlldyhzZXR0aW5ncyk7XG4gICAgfVxuICAgIHNjcm9sbFBvc2l0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxQb3NpdGlvbih0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpKTtcbiAgICB9XG4gICAgc2Nyb2xsYWJsZVBhcmVudHMoZWwpIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbGFibGVQYXJlbnRzKHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgIH1cbiAgICBzdGFja2luZ0VsZW1lbnRPZmZzZXQoZWwpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVDb250ZXh0RWxlbWVudCA9IHRoaXMuZ2V0UmVsYXRpdmVDb250ZXh0RWxlbWVudChlbCk7XG4gICAgICAgIGlmICghcmVsYXRpdmVDb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldChyZWxhdGl2ZUNvbnRleHRFbGVtZW50KTtcbiAgICB9XG4gICAgc3RhY2tpbmdFbGVtZW50U2Nyb2xsKGVsKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlQ29udGV4dEVsZW1lbnQgPSB0aGlzLmdldFJlbGF0aXZlQ29udGV4dEVsZW1lbnQoZWwpO1xuICAgICAgICBpZiAoIXJlbGF0aXZlQ29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcmVsYXRpdmVDb250ZXh0RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgeTogcmVsYXRpdmVDb250ZXh0RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UmVsYXRpdmVDb250ZXh0RWxlbWVudChlbCkge1xuICAgICAgICBpZiAoIWVsIHx8ICFoYXNSZWxhdGl2ZVN0YWNraW5nQ29udGV4dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50KGVsKS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KS50cmFuc2Zvcm0gIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdXNlUmVsYXRpdmVQb3NpdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFJlbGF0aXZlQ29udGV4dEVsZW1lbnQoZWwpO1xuICAgIH1cbiAgICB3aW5kb3dWaWV3UG9ydChlbCkge1xuICAgICAgICByZXR1cm4gZ2V0V2luZG93Vmlld1BvcnQodGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgfVxuICAgIHpJbmRleChhbmNob3IsIGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gekluZGV4KHRoaXMubmF0aXZlRWxlbWVudChhbmNob3IpLCB0aGlzLm5hdGl2ZUVsZW1lbnQoY29udGFpbmVyKSk7XG4gICAgfVxuICAgIHpvb21MZXZlbCgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkgfHwgIWlzV2luZG93QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aCkudG9GaXhlZCgyKSkgfHwgMTtcbiAgICB9XG4gICAgaXNab29tZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21MZXZlbCgpID4gMTtcbiAgICB9XG59XG5ET01TZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKipcbiAqIFVzZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBzY2FsZSB3aGVuIHVzaW5nIGEgW3NjYWxlIHRyYW5zZm9ybV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1mdW5jdGlvbi9zY2FsZSkuXG4gKlxuICogVGhlIGRvY3VtZW50IG9yIGNvbnRhaW5lciBzY2FsZSBpcyByZXF1aXJlZCB0byBjb21wdXRlIHRoZSBwb3B1cCBwb3NpdGlvbiBjb3JyZWN0bHkuIERldGVjdGluZyB0aGUgc2NhbGUgaXMgbm90IHJlbGlhYmxlIGFuZCBtdXN0IGJlIHNldCBieSBwcm92aWRpbmcgYSB2YWx1ZSBmb3IgU0NBTEUuIFNlZSBbU3VwcG9ydCBmb3IgRG9jdW1lbnQgU2NhbGVdKHslIHNsdWcgZG9jdW1lbnRzY2FsZV9wb3B1cCAlfSkuXG4gKlxuICogPiBVc2luZyB0aGlzIHRva2VuIGlzIG5vdCBuZWNlc3NhcnkgZm9yIHVzZXItYXBwbGllZCBicm93c2VyIHpvb20uXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6MzAwICV9XG4gKiB7JSBlbWJlZF9maWxlIHNjYWxlL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBzY2FsZS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNjYWxlL21haW4udHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqXG4gKlxuICovXG5jb25zdCBTQ0FMRSA9IG5ldyBJbmplY3Rpb25Ub2tlbignUG9wdXAgRG9jdW1lbnQgU2NhbGUnKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEFsaWduU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoX2RvbSwgc2NhbGUgPSAxKSB7XG4gICAgICAgIHRoaXMuX2RvbSA9IF9kb207XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB9XG4gICAgYWxpZ25FbGVtZW50KHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgYW5jaG9yLCBlbGVtZW50LCBhbmNob3JBbGlnbiwgZWxlbWVudEFsaWduLCBtYXJnaW4sIG9mZnNldDogb2Zmc2V0JCQxLCBwb3NpdGlvbk1vZGUgfSA9IHNldHRpbmdzO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGUgfHwgMTtcbiAgICAgICAgY29uc3QgZml4ZWRNb2RlID0gcG9zaXRpb25Nb2RlID09PSAnZml4ZWQnIHx8ICF0aGlzLl9kb20uaGFzT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBhbmNob3JSZWN0ID0gZml4ZWRNb2RlID8gdGhpcy5hYnNvbHV0ZVJlY3QoYW5jaG9yLCBlbGVtZW50LCBvZmZzZXQkJDEsIHNjYWxlKSA6IHRoaXMucmVsYXRpdmVSZWN0KGFuY2hvciwgZWxlbWVudCwgb2Zmc2V0JCQxLCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gc2NhbGVSZWN0KHRoaXMuX2RvbS5vZmZzZXQoZWxlbWVudCksIHNjYWxlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZG9tLmFsaWduKHtcbiAgICAgICAgICAgIGFuY2hvckFsaWduOiBhbmNob3JBbGlnbixcbiAgICAgICAgICAgIGFuY2hvclJlY3Q6IGFuY2hvclJlY3QsXG4gICAgICAgICAgICBlbGVtZW50QWxpZ246IGVsZW1lbnRBbGlnbixcbiAgICAgICAgICAgIGVsZW1lbnRSZWN0OiBlbGVtZW50UmVjdCxcbiAgICAgICAgICAgIG1hcmdpblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYWJzb2x1dGVSZWN0KGFuY2hvciwgZWxlbWVudCwgb2Zmc2V0JCQxLCBzY2FsZSkge1xuICAgICAgICBjb25zdCBzY3JvbGxQb3MgPSB0aGlzLmVsZW1lbnRTY3JvbGxQb3NpdGlvbihhbmNob3IsIGVsZW1lbnQpO1xuICAgICAgICBjb25zdCByZWN0ID0gZWl0aGVyUmVjdCh0aGlzLl9kb20ub2Zmc2V0KGFuY2hvciksIG9mZnNldCQkMSk7XG4gICAgICAgIGNvbnN0IHN0YWNrU2NhbGUgPSAyICogc2NhbGU7XG4gICAgICAgIGNvbnN0IHN0YWNrU2Nyb2xsID0gdGhpcy5fZG9tLnN0YWNraW5nRWxlbWVudFNjcm9sbChlbGVtZW50KTtcbiAgICAgICAgaWYgKHNjYWxlICE9PSAxICYmIHN0YWNrU2Nyb2xsKSB7XG4gICAgICAgICAgICBzdGFja1Njcm9sbC54IC89IHN0YWNrU2NhbGU7XG4gICAgICAgICAgICBzdGFja1Njcm9sbC55IC89IHN0YWNrU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhY2tPZmZzZXQgPSB0aGlzLl9kb20uc3RhY2tpbmdFbGVtZW50T2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoc2NhbGUgIT09IDEgJiYgc3RhY2tPZmZzZXQpIHtcbiAgICAgICAgICAgIHN0YWNrT2Zmc2V0LmxlZnQgLz0gc3RhY2tTY2FsZTtcbiAgICAgICAgICAgIHN0YWNrT2Zmc2V0LnRvcCAvPSBzdGFja1NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kb20ucmVtb3ZlU2Nyb2xsKHRoaXMuX2RvbS5hZGRTY3JvbGwocmVtb3ZlU3RhY2tpbmdPZmZzZXQoc2NhbGVSZWN0KHJlY3QsIHNjYWxlKSwgc3RhY2tPZmZzZXQpLCBzdGFja1Njcm9sbCksIHNjcm9sbFBvcyk7XG4gICAgfVxuICAgIGVsZW1lbnRTY3JvbGxQb3NpdGlvbihhbmNob3IsIGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFuY2hvciA/IHsgeDogMCwgeTogMCB9IDogdGhpcy5fZG9tLnNjcm9sbFBvc2l0aW9uKGVsZW1lbnQpO1xuICAgIH1cbiAgICByZWxhdGl2ZVJlY3QoYW5jaG9yLCBlbGVtZW50LCBvZmZzZXQkJDEsIHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBlaXRoZXJSZWN0KHRoaXMuX2RvbS5wb3NpdGlvbihhbmNob3IsIGVsZW1lbnQsIHNjYWxlKSwgb2Zmc2V0JCQxKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlUmVjdChyZWN0LCBzY2FsZSk7XG4gICAgfVxufVxuQWxpZ25TZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5BbGlnblNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBET01TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOdW1iZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW1NDQUxFLF0gfSwgeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUG9zaXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihfZG9tLCBzY2FsZSA9IDEpIHtcbiAgICAgICAgdGhpcy5fZG9tID0gX2RvbTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIH1cbiAgICBwb3NpdGlvbkVsZW1lbnQoc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgeyBhbmNob3IsIGN1cnJlbnRMb2NhdGlvbiwgZWxlbWVudCwgYW5jaG9yQWxpZ24sIGVsZW1lbnRBbGlnbiwgY29sbGlzaW9ucywgbWFyZ2luIH0gPSBzZXR0aW5ncztcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy5fZG9tO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGUgfHwgMTtcbiAgICAgICAgY29uc3QgZWxlbWVudE9mZnNldCA9IGRvbS5vZmZzZXRBdFBvaW50KGVsZW1lbnQsIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gc2NhbGVSZWN0KGVsZW1lbnRPZmZzZXQsIHNjYWxlKTtcbiAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gc2NhbGVSZWN0KGRvbS5vZmZzZXQoYW5jaG9yKSwgc2NhbGUpO1xuICAgICAgICBjb25zdCBhbmNob3JSZWN0ID0gZWl0aGVyUmVjdChhbmNob3JPZmZzZXQsIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0ID0gc2V0dGluZ3Mudmlld1BvcnQgfHwgZG9tLndpbmRvd1ZpZXdQb3J0KGVsZW1lbnQpO1xuICAgICAgICB2aWV3UG9ydC53aWR0aCA9IHZpZXdQb3J0LndpZHRoIC8gc2NhbGU7XG4gICAgICAgIHZpZXdQb3J0LmhlaWdodCA9IHZpZXdQb3J0LmhlaWdodCAvIHNjYWxlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkb20ucmVzdHJpY3RUb1ZpZXcoe1xuICAgICAgICAgICAgYW5jaG9yQWxpZ24sXG4gICAgICAgICAgICBhbmNob3JSZWN0LFxuICAgICAgICAgICAgY29sbGlzaW9ucyxcbiAgICAgICAgICAgIGVsZW1lbnRBbGlnbixcbiAgICAgICAgICAgIGVsZW1lbnRSZWN0LFxuICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgdmlld1BvcnRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9mZnNldCQkMSA9IGRvbS5hZGRPZmZzZXQoY3VycmVudExvY2F0aW9uLCByZXN1bHQub2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZsaXA6IHJlc3VsdC5mbGlwLFxuICAgICAgICAgICAgZmxpcHBlZDogcmVzdWx0LmZsaXBwZWQsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCQkMVxuICAgICAgICB9O1xuICAgIH1cbn1cblBvc2l0aW9uU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUG9zaXRpb25TZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRE9NU2VydmljZSB9LFxuICAgIHsgdHlwZTogTnVtYmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtTQ0FMRSxdIH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJlc2l6ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9kb20sIF96b25lKSB7XG4gICAgICAgIHRoaXMuX2RvbSA9IF9kb207XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGZyb21FdmVudCh0aGlzLl9kb20uZ2V0V2luZG93KCksIFwicmVzaXplXCIpXG4gICAgICAgICAgICAgICAgLnBpcGUoYXVkaXRUaW1lKEZSQU1FX0RVUkFUSU9OKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpc1Vuc3Vic2NyaWJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9uICYmIHRoaXMuc3Vic2NyaXB0aW9uLmNsb3NlZDtcbiAgICB9XG59XG5SZXNpemVTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5SZXNpemVTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRE9NU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBUSFJFU0hPTERfRElGRiA9IDE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2Nyb2xsYWJsZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9kb20sIF96b25lKSB7XG4gICAgICAgIHRoaXMuX2RvbSA9IF9kb207XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICB9XG4gICAgZm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICFpc0RvY3VtZW50QXZhaWxhYmxlKCkgfHwgIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSB0aGlzLl9kb20ubmF0aXZlRWxlbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICBjb25zdCBwYXJlbnRzJCQxID0gdGhpcy5fZG9tLnNjcm9sbGFibGVQYXJlbnRzKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZXMgPSBwYXJlbnRzJCQxLm1hcChwID0+IGZyb21FdmVudChwLCBcInNjcm9sbFwiKS5waXBlKGF1ZGl0VGltZShGUkFNRV9EVVJBVElPTikpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUGFyZW50ID0gcGFyZW50cyQkMS5maWx0ZXIocCA9PiBwID09PSB0YXJnZXQpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEb2N1bWVudCA9IHRhcmdldCA9PT0gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNXaW5kb3cgPSB0YXJnZXQgPT09IHdpbmRvdztcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXJlbnQgfHwgaXNEb2N1bWVudCB8fCBpc1dpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLmlzVmlzaWJsZShuYXRpdmVFbGVtZW50LCB0YXJnZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBtZXJnZSguLi5vYnNlcnZhYmxlcykuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpc1Zpc2libGUoZWxlbSwgY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IGVsZW1SZWN0ID0gdGhpcy5fZG9tLmJvdW5kaW5nT2Zmc2V0KGVsZW0pO1xuICAgICAgICBjb25zdCBjb250YWluZXJSZWN0ID0gdGhpcy5fZG9tLmJvdW5kaW5nT2Zmc2V0KGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChUSFJFU0hPTERfRElGRiA8IChjb250YWluZXJSZWN0LnRvcCAtIGVsZW1SZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVEhSRVNIT0xEX0RJRkYgPCAoZWxlbVJlY3QudG9wIC0gY29udGFpbmVyUmVjdC5ib3R0b20pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRIUkVTSE9MRF9ESUZGIDwgKGVsZW1SZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LnJpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUSFJFU0hPTERfRElGRiA8IChjb250YWluZXJSZWN0LmxlZnQgLSBlbGVtUmVjdC5yaWdodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5TY3JvbGxhYmxlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU2Nyb2xsYWJsZVNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBET01TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcblxuY29uc3QgTEVGVCA9ICdsZWZ0JztcbmNvbnN0IFJJR0hUID0gJ3JpZ2h0JztcbmNvbnN0IERPV04gPSAnZG93bic7XG5jb25zdCBVUCA9ICd1cCc7XG5jb25zdCBERUZBVUxUX1RZUEUgPSAnc2xpZGUnO1xuY29uc3QgREVGQVVMVF9EVVJBVElPTiA9IDEwMDtcbmNvbnN0IGFuaW1hdGlvblR5cGVzID0ge307XG4vKiB0c2xpbnQ6ZGlzYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXMgKi9cbmFuaW1hdGlvblR5cGVzLmV4cGFuZCA9IChkaXJlY3Rpb24pID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IGRpcmVjdGlvbiA9PT0gVVAgfHwgZGlyZWN0aW9uID09PSBET1dOID8gJ3NjYWxlWScgOiAnc2NhbGVYJztcbiAgICBjb25zdCBzdGFydFNjYWxlID0gMDtcbiAgICBjb25zdCBlbmRTY2FsZSA9IDE7XG4gICAgbGV0IG9yaWdpbjtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgIG9yaWdpbiA9ICd0b3AnO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgb3JpZ2luID0gUklHSFQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgb3JpZ2luID0gTEVGVDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9yaWdpbiA9ICdib3R0b20nO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogeyB0cmFuc2Zvcm06IGAke3NjYWxlfSgke3N0YXJ0U2NhbGV9KWAsIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luIH0sXG4gICAgICAgIGVuZDogeyB0cmFuc2Zvcm06IGAke3NjYWxlfSgke2VuZFNjYWxlfSlgIH1cbiAgICB9O1xufTtcbmFuaW1hdGlvblR5cGVzLnNsaWRlID0gKGRpcmVjdGlvbikgPT4ge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGRpcmVjdGlvbiA9PT0gTEVGVCB8fCBkaXJlY3Rpb24gPT09IFJJR0hUID8gJ3RyYW5zbGF0ZVgnIDogJ3RyYW5zbGF0ZVknO1xuICAgIGNvbnN0IHN0YXJ0ID0gZGlyZWN0aW9uID09PSBSSUdIVCB8fCBkaXJlY3Rpb24gPT09IERPV04gPyAtMTAwIDogMTAwO1xuICAgIGNvbnN0IGVuZCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHsgdHJhbnNmb3JtOiBgJHt0cmFuc2xhdGV9KCR7c3RhcnR9JSlgIH0sXG4gICAgICAgIGVuZDogeyB0cmFuc2Zvcm06IGAke3RyYW5zbGF0ZX0oJHtlbmR9JSlgIH1cbiAgICB9O1xufTtcbmFuaW1hdGlvblR5cGVzLmZhZGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICBlbmQ6IHsgb3BhY2l0eTogMSB9XG4gICAgfTtcbn07XG5hbmltYXRpb25UeXBlcy56b29tID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gMDtcbiAgICBjb25zdCBlbmQgPSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7IHRyYW5zZm9ybTogYHNjYWxlKCR7c3RhcnR9KWAgfSxcbiAgICAgICAgZW5kOiB7IHRyYW5zZm9ybTogYHNjYWxlKCR7ZW5kfSlgIH1cbiAgICB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBBbmltYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb25CdWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQnVpbGRlciA9IGFuaW1hdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBwbGF5KGVsZW1lbnQsIG9wdGlvbnMsIGZsaXApIHtcbiAgICAgICAgaWYgKCF0aGlzLmZsaXAgfHwgdGhpcy5mbGlwLmhvcml6b250YWwgIT09IGZsaXAuaG9yaXpvbnRhbCB8fFxuICAgICAgICAgICAgdGhpcy5mbGlwLnZlcnRpY2FsICE9PSBmbGlwLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmZsaXAgPSBmbGlwO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZXNGbiA9IGFuaW1hdGlvblR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKHN0YXRlc0ZuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oZmxpcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVzID0gc3RhdGVzRm4oZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlTdGF0ZXMoZWxlbWVudCwgc3RhdGVzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhbmltYXRpb24gdHlwZTogXCIke3R5cGV9XCIuIFRoZSBzdXBwb3J0ZWQgdHlwZXMgYXJlIHNsaWRlLCBleHBhbmQsIGZhZGUgYW5kIHpvb20uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3RvcFBsYXllcigpO1xuICAgIH1cbiAgICBwbGF5U3RhdGVzKGVsZW1lbnQsIHN0YXRlcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3BQbGF5ZXIoKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IERFRkFVTFRfRFVSQVRJT047XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmFuaW1hdGlvbkJ1aWxkZXIuYnVpbGQoW1xuICAgICAgICAgICAgc3R5bGUoc3RhdGVzLnN0YXJ0KSxcbiAgICAgICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHN0YXRlcy5lbmQpKVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5wbGF5ZXIgPSBmYWN0b3J5LmNyZWF0ZShlbGVtZW50KTtcbiAgICAgICAgcGxheWVyLm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZC5lbWl0KCk7XG4gICAgICAgICAgICB0aGlzLnN0b3BQbGF5ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhcnQuZW1pdCgpO1xuICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgIH1cbiAgICBnZXREaXJlY3Rpb24oZmxpcCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgRE9XTjtcbiAgICAgICAgaWYgKGZsaXAuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTEVGVCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFJJR0hUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBSSUdIVCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IExFRlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsaXAudmVydGljYWwpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERPV04pIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBVUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBET1dOO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfVxuICAgIHN0b3BQbGF5ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcikge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuQW5pbWF0aW9uU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQW5pbWF0aW9uU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEFuaW1hdGlvbkJ1aWxkZXIgfVxuXTtcblxuY29uc3QgREVGQVVMVF9PRkZTRVQgPSB7IGxlZnQ6IC0xMDAwMCwgdG9wOiAwIH07XG5jb25zdCBBTklNQVRJT05fQ09OVEFJTkVSID0gJ2stYW5pbWF0aW9uLWNvbnRhaW5lcic7XG5jb25zdCBBTklNQVRJT05fQ09OVEFJTkVSX0ZJWEVEID0gJ2stYW5pbWF0aW9uLWNvbnRhaW5lci1maXhlZCc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBQb3B1cCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfcG9wdXAgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8YnV0dG9uICNhbmNob3IgKGNsaWNrKT1cInNob3c9IXNob3dcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqICA8a2VuZG8tcG9wdXAgKm5nSWY9XCJzaG93XCIgW2FuY2hvcl09XCJhbmNob3JcIj5cbiAqICAgICAgPHN0cm9uZz5Qb3B1cCBjb250ZW50ITwvc3Ryb25nPlxuICogIDwva2VuZG8tcG9wdXA+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIHNob3c6IGJvb2xlYW4gPSBmYWxzZTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBQb3B1cENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBfYWxpZ25TZXJ2aWNlLCBkb21TZXJ2aWNlLCBfcG9zaXRpb25TZXJ2aWNlLCBfcmVzaXplU2VydmljZSwgX3Njcm9sbGFibGVTZXJ2aWNlLCBhbmltYXRpb25TZXJ2aWNlLCBfcmVuZGVyZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9hbGlnblNlcnZpY2UgPSBfYWxpZ25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmRvbVNlcnZpY2UgPSBkb21TZXJ2aWNlO1xuICAgICAgICB0aGlzLl9wb3NpdGlvblNlcnZpY2UgPSBfcG9zaXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlID0gX3Jlc2l6ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3Njcm9sbGFibGVTZXJ2aWNlID0gX3Njcm9sbGFibGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblNlcnZpY2UgPSBhbmltYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgdGhlIFBvcHVwIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgYW5pbWF0aW9uc1xuICAgICAgICAgKiBhcmUgZW5hYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFuaW1hdGlvbnNfcG9wdXAgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGFuY2hvciBwaXZvdCBwb2ludFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFsaWdubWVudHBvc2l0aW9uaW5nX3BvcHVwICV9I3RvYy1wb3NpdGlvbmluZykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmNob3JBbGlnbiA9IHsgaG9yaXpvbnRhbDogJ2xlZnQnLCB2ZXJ0aWNhbDogJ2JvdHRvbScgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhlIGNvbGxpc2lvbiBiZWhhdmlvciBvZiB0aGUgUG9wdXBcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB2aWV3cG9ydGJvdW5kYXJ5ZGV0ZWN0aW9uX3BvcHVwICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxpc2lvbiA9IHsgaG9yaXpvbnRhbDogJ2ZpdCcsIHZlcnRpY2FsOiAnZmxpcCcgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcGl2b3QgcG9pbnQgb2YgdGhlIFBvcHVwXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYWxpZ25tZW50cG9zaXRpb25pbmdfcG9wdXAgJX0jdG9jLXBvc2l0aW9uaW5nKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcHVwQWxpZ24gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICd0b3AnIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyB3aGV0aGVyIHRoZSBjb21wb25lbnQgd2lsbCBjb3B5IHRoZSBgYW5jaG9yYCBmb250IHN0eWxlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29weUFuY2hvclN0eWxlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBwb3NpdGlvbiBtb2RlIG9mIHRoZSBjb21wb25lbnQuIEJ5IGRlZmF1bHQsIHRoZSBQb3B1cCB1c2VzIGZpeGVkIHBvc2l0aW9uaW5nLlxuICAgICAgICAgKiBUbyBtYWtlIHRoZSBQb3B1cCBhY3F1aXJlIGFic29sdXRlIHBvc2l0aW9uaW5nLCBzZXQgdGhpcyBvcHRpb24gdG8gYGFic29sdXRlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IG1vYmlsZSBicm93c2VycyB3aXRoIHRoZSB6b29tIG9wdGlvbixcbiAgICAgICAgICogdXNlIHRoZSBgYWJzb2x1dGVgIHBvc2l0aW9uaW5nIG9mIHRoZSBQb3B1cC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgaHRtbFxuICAgICAgICAgKiA8c3R5bGU+XG4gICAgICAgICAqICAucGFyZW50LWNvbnRlbnQge1xuICAgICAgICAgKiAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgKiAgICAgd2lkdGg6IDIwMHB4O1xuICAgICAgICAgKiAgICAgaGVpZ2h0OiAyMDBweDtcbiAgICAgICAgICogICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICAgKiAgICAgbWFyZ2luOiAyMDBweCBhdXRvO1xuICAgICAgICAgKiAgICAgYm9yZGVyOiAxcHggc29saWQgcmVkO1xuICAgICAgICAgKiAgfVxuICAgICAgICAgKiAgLmNvbnRlbnQge1xuICAgICAgICAgKiAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgKiAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAgICAgKiAgICAgaGVpZ2h0OiAxMDBweDtcbiAgICAgICAgICogICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICAgKiAgICAgbWFyZ2luOiAzMDBweDtcbiAgICAgICAgICogICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsdWU7XG4gICAgICAgICAqICB9XG4gICAgICAgICAqICAuYW5jaG9yIHtcbiAgICAgICAgICogICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICogICAgIHRvcDogMjAwcHg7XG4gICAgICAgICAqICAgICBsZWZ0OiAyMDBweDtcbiAgICAgICAgICogIH1cbiAgICAgICAgICogPC9zdHlsZT5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgIDxkaXYgY2xhc3M9XCJleGFtcGxlLWNvbmZpZ1wiPlxuICAgICAgICAgKiAgICAgIFBvc2l0aW9uIG1vZGU6XG4gICAgICAgICAqICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiB2YWx1ZT1cImZpeGVkXCIgWyhuZ01vZGVsKV09XCJtb2RlXCIgLz4gRml4ZWQ8L2xhYmVsPlxuICAgICAgICAgKiAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCJhYnNvbHV0ZVwiIFsobmdNb2RlbCldPVwibW9kZVwiIC8+IEFic29sdXRlPC9sYWJlbD5cbiAgICAgICAgICogICA8L2Rpdj5cbiAgICAgICAgICogICA8ZGl2IGNsYXNzPVwiZXhhbXBsZS1jb25maWdcIj5cbiAgICAgICAgICogICAgICAgQXBwZW5kIHRvXG4gICAgICAgICAqICAgICAgIDxsYWJlbD5cbiAgICAgICAgICogICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicGxhY2VcIiBbdmFsdWVdPVwiMVwiIFsobmdNb2RlbCldPVwiY2hlY2tlZFwiIC8+XG4gICAgICAgICAqICAgICAgICAgICBSb290IGNvbXBvbmVudFxuICAgICAgICAgKiAgICAgICA8L2xhYmVsPlxuICAgICAgICAgKiAgICAgICA8bGFiZWw+XG4gICAgICAgICAqICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cInBsYWNlXCIgW3ZhbHVlXT1cIjJcIiBbKG5nTW9kZWwpXT1cImNoZWNrZWRcIiAvPlxuICAgICAgICAgKiAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogcmVkXCI+UmVkIENvbnRhaW5lcjwvc3Bhbj5cbiAgICAgICAgICogICAgICAgPC9sYWJlbD5cbiAgICAgICAgICogICAgICAgPGxhYmVsPlxuICAgICAgICAgKiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJwbGFjZVwiIFt2YWx1ZV09XCIzXCIgWyhuZ01vZGVsKV09XCJjaGVja2VkXCIgLz5cbiAgICAgICAgICogICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IGJsdWVcIj5CbHVlIENvbnRhaW5lcjwvc3Bhbj5cbiAgICAgICAgICogICAgICAgPC9sYWJlbD5cbiAgICAgICAgICogICA8L2Rpdj5cbiAgICAgICAgICogICA8ZGl2IGNsYXNzPVwiZXhhbXBsZVwiPlxuICAgICAgICAgKiAgICAgPGRpdiBjbGFzcz1cInBhcmVudC1jb250ZW50XCIgW3Njcm9sbExlZnRdPVwiMjUwXCIgW3Njcm9sbFRvcF09XCIyMzBcIj5cbiAgICAgICAgICogICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiIFtzY3JvbGxMZWZ0XT1cIjE3MFwiIFtzY3JvbGxUb3BdPVwiMTY1XCI+XG4gICAgICAgICAqICAgICAgICAgICA8YnV0dG9uICNhbmNob3IgY2xhc3M9XCJhbmNob3JcIiAoY2xpY2spPVwic2hvdyA9ICFzaG93XCI+VG9nZ2xlPC9idXR0b24+XG4gICAgICAgICAqICAgICAgICAgICA8a2VuZG8tcG9wdXAgW3Bvc2l0aW9uTW9kZV09XCJtb2RlXCIgW2FuY2hvcl09XCJhbmNob3JcIiAoYW5jaG9yVmlld3BvcnRMZWF2ZSk9XCJzaG93PWZhbHNlXCIgKm5nSWY9XCJzaG93ICYmIGNoZWNrZWQgPT09IDNcIj5cbiAgICAgICAgICogICAgICAgICAgICAgPHVsPlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgPGxpPkl0ZW0xPC9saT5cbiAgICAgICAgICogICAgICAgICAgICAgICAgIDxsaT5JdGVtMjwvbGk+XG4gICAgICAgICAqICAgICAgICAgICAgICAgICA8bGk+SXRlbTM8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgKiAgICAgICAgICAgPC9rZW5kby1wb3B1cD5cbiAgICAgICAgICogICAgICAgICAgIDxzcGFuIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDQwMHB4OyBsZWZ0OiA0MDBweFwiPkJvdHRvbS9SaWdodDwvc3Bhbj5cbiAgICAgICAgICogICAgICAgICA8L2Rpdj5cbiAgICAgICAgICogICAgICAgICA8a2VuZG8tcG9wdXAgW3Bvc2l0aW9uTW9kZV09XCJtb2RlXCIgW2FuY2hvcl09XCJhbmNob3JcIiAoYW5jaG9yVmlld3BvcnRMZWF2ZSk9XCJzaG93PWZhbHNlXCIgKm5nSWY9XCJzaG93ICYmIGNoZWNrZWQgPT09IDJcIj5cbiAgICAgICAgICogICAgICAgICAgIDx1bD5cbiAgICAgICAgICogICAgICAgICAgICAgICA8bGk+SXRlbTE8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICAgIDxsaT5JdGVtMjwvbGk+XG4gICAgICAgICAqICAgICAgICAgICAgICAgPGxpPkl0ZW0zPC9saT5cbiAgICAgICAgICogICAgICAgICAgIDwvdWw+XG4gICAgICAgICAqICAgICAgICAgPC9rZW5kby1wb3B1cD5cbiAgICAgICAgICogICAgICAgICA8c3BhbiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA2MDBweDsgbGVmdDogNjAwcHhcIj5Cb3R0b20vUmlnaHQ8L3NwYW4+XG4gICAgICAgICAqICAgICA8L2Rpdj5cbiAgICAgICAgICogICAgIDxrZW5kby1wb3B1cCBbcG9zaXRpb25Nb2RlXT1cIm1vZGVcIiBbYW5jaG9yXT1cImFuY2hvclwiIChhbmNob3JWaWV3cG9ydExlYXZlKT1cInNob3c9ZmFsc2VcIiAqbmdJZj1cInNob3cgJiYgY2hlY2tlZCA9PT0gMVwiPlxuICAgICAgICAgKiAgICAgICA8dWw+XG4gICAgICAgICAqICAgICAgICAgICA8bGk+SXRlbTE8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgPGxpPkl0ZW0yPC9saT5cbiAgICAgICAgICogICAgICAgICAgIDxsaT5JdGVtMzwvbGk+XG4gICAgICAgICAqICAgICAgIDwvdWw+XG4gICAgICAgICAqICAgICA8L2tlbmRvLXBvcHVwPlxuICAgICAgICAgKiAgIDwvZGl2PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGNoZWNrZWQ6IG51bWJlciA9IDM7XG4gICAgICAgICAqICAgcHVibGljIG1vZGU6IHN0cmluZyA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAqICAgcHVibGljIHNob3c6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGUgPSAnZml4ZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFsaWdubWVudHBvc2l0aW9uaW5nX3BvcHVwICV9I3RvYy1hbGlnbmluZy10by1hYnNvbHV0ZS1wb2ludHMpKS5cbiAgICAgICAgICogVGhlIFBvcHVwIG9wZW5zIG5leHQgdG8gdGhhdCBwb2ludC4gVGhlIFBvcHVwIHBpdm90IHBvaW50IGlzIGRlZmluZWQgYnkgdGhlIGBwb3B1cEFsaWduYCBjb25maWd1cmF0aW9uIG9wdGlvbi5cbiAgICAgICAgICogVGhlIGJvdW5kYXJ5IGRldGVjdGlvbiBpcyBhcHBsaWVkIGJ5IHVzaW5nIHRoZSB3aW5kb3cgdmlld3BvcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IERFRkFVTFRfT0ZGU0VUO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYW5jaG9yIGlzIHNjcm9sbGVkIG91dHNpZGUgdGhlIHNjcmVlbiBib3VuZGFyaWVzLlxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNsb3NpbmdfcG9wdXAgJX0jdG9jLWFmdGVyLWxlYXZpbmctdGhlLXZpZXdwb3J0KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgY29tcG9uZW50IGlzIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgY29tcG9uZW50IGlzIG9wZW5lZCBhbmQgdGhlIG9wZW5pbmcgYW5pbWF0aW9uIGVuZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgY29tcG9uZW50IGlzIG9wZW5lZCBhbmQgdGhlIFBvcHVwIGlzIHBvc2l0aW9uZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgdGhpcy5pbml0aWFsQ2hlY2sgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhjb250YWluZXIubmF0aXZlRWxlbWVudCwgQU5JTUFUSU9OX0NPTlRBSU5FUik7XG4gICAgICAgIHRoaXMudXBkYXRlRml4ZWRDbGFzcygpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZXBvc2l0aW9uID0gdGhpcy5yZXBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNlcnZpY2Uuc3Vic2NyaWJlKHRoaXMucmVwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3Vic2NyaXB0aW9ucyA9IHRoaXMuYW5pbWF0aW9uU2VydmljZS5zdGFydC5zdWJzY3JpYmUodGhpcy5vbkFuaW1hdGlvblN0YXJ0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuYW5pbWF0aW9uU2VydmljZS5lbmQuc3Vic2NyaWJlKHRoaXMub25BbmltYXRpb25FbmQuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zY3JvbGxhYmxlU2VydmljZS5mb3JFbGVtZW50KHRoaXMuYW5jaG9yIHx8IHRoaXMuY29udGFpbmVyKS5zdWJzY3JpYmUodGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50T2Zmc2V0ID0gREVGQVVMVF9PRkZTRVQ7XG4gICAgICAgIHRoaXMuc2V0WkluZGV4KCk7XG4gICAgICAgIHRoaXMuY29weUZvbnRTdHlsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGaXhlZENsYXNzKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuY29weUFuY2hvclN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5jb3B5Rm9udFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBvc2l0aW9uTW9kZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaXhlZENsYXNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnJlcG9zaXRpb24oKTtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25BbmltYXRpb25FbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbENoZWNrKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxDaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZHMgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTkwOTRcbiAgICAgICAgICAgIC8vIHVzZXMgcHJvbWlzZSBiZWNhdXNlIGl0IGlzIGV4ZWN1dGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNvbnRlbnQgaXMgdXBkYXRlZFxuICAgICAgICAgICAgLy8gZG9lcyBub3QgdXNlIG9uU3RhYmxlIGluIGNhc2UgdGhlIGN1cnJlbnQgem9uZSBpcyBub3QgdGhlIGFuZ3VsYXIgb25lLlxuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZVJlcG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3NpdGlvblN1YnNjcmlwdGlvbiA9IGZyb20odGhpcy5yZXNvbHZlZFByb21pc2UpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLnJlcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yVmlld3BvcnRMZWF2ZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICAgICAgICB0aGlzLmNsb3NlLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNlcnZpY2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZVNlcnZpY2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVSZXBvc2l0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5yZXBvc2l0aW9uKCk7XG4gICAgfVxuICAgIG9uQW5pbWF0aW9uU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsICdrLWFuaW1hdGlvbi1jb250YWluZXItc2hvd24nKTtcbiAgICB9XG4gICAgb25BbmltYXRpb25FbmQoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsICdrLWFuaW1hdGlvbi1jb250YWluZXItc2hvd24nKTtcbiAgICAgICAgdGhpcy5vcGVuLmVtaXQoKTtcbiAgICAgICAgdGhpcy5vcGVuLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudE9mZnNldDtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRPZmZzZXQob2Zmc2V0JCQxKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyU3R5bGUoJ2xlZnQnLCBgJHtvZmZzZXQkJDEubGVmdH1weGApO1xuICAgICAgICB0aGlzLnNldENvbnRhaW5lclN0eWxlKCd0b3AnLCBgJHtvZmZzZXQkJDEudG9wfXB4YCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSBvZmZzZXQkJDE7XG4gICAgfVxuICAgIHNldFpJbmRleCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRhaW5lclN0eWxlKCd6LWluZGV4JywgU3RyaW5nKHRoaXMuZG9tU2VydmljZS56SW5kZXgodGhpcy5hbmNob3IsIHRoaXMuY29udGFpbmVyKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcG9zaXRpb24oKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBmbGlwLCBvZmZzZXQ6IG9mZnNldCQkMSB9ID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudE9mZnNldCB8fCBpc0RpZmZlcmVudE9mZnNldCh0aGlzLmN1cnJlbnRPZmZzZXQsIG9mZnNldCQkMSkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE9mZnNldCA9IG9mZnNldCQkMTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5wb3NpdGlvbkNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB0aGlzLnBvc2l0aW9uQ2hhbmdlLmVtaXQoeyBvZmZzZXQ6IG9mZnNldCQkMSwgZmxpcCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TZXJ2aWNlLnBsYXkodGhpcy5jb250ZW50Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIHRoaXMuYW5pbWF0ZSwgZmxpcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemVTZW5zb3IuYWNjZXB0U2l6ZSgpO1xuICAgIH1cbiAgICBwb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgYWxpZ25lZE9mZnNldCA9IHRoaXMuX2FsaWduU2VydmljZS5hbGlnbkVsZW1lbnQoe1xuICAgICAgICAgICAgYW5jaG9yOiB0aGlzLmFuY2hvcixcbiAgICAgICAgICAgIGFuY2hvckFsaWduOiB0aGlzLmFuY2hvckFsaWduLFxuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgICBlbGVtZW50QWxpZ246IHRoaXMucG9wdXBBbGlnbixcbiAgICAgICAgICAgIG1hcmdpbjogdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiB0aGlzLnBvc2l0aW9uTW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uU2VydmljZS5wb3NpdGlvbkVsZW1lbnQoe1xuICAgICAgICAgICAgYW5jaG9yOiB0aGlzLmFuY2hvcixcbiAgICAgICAgICAgIGFuY2hvckFsaWduOiB0aGlzLmFuY2hvckFsaWduLFxuICAgICAgICAgICAgY29sbGlzaW9uczogdGhpcy5jb2xsaXNpb24sXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGFsaWduZWRPZmZzZXQsXG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGVsZW1lbnRBbGlnbjogdGhpcy5wb3B1cEFsaWduLFxuICAgICAgICAgICAgbWFyZ2luOiB0aGlzLm1hcmdpblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25TY3JvbGwoaXNJblZpZXdQb3J0KSB7XG4gICAgICAgIGNvbnN0IGhhc0xlYXZlT2JzZXJ2ZXJzID0gaGFzT2JzZXJ2ZXJzKHRoaXMuYW5jaG9yVmlld3BvcnRMZWF2ZSk7XG4gICAgICAgIGlmIChpc0luVmlld1BvcnQgfHwgIWhhc0xlYXZlT2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNMZWF2ZU9ic2VydmVycykge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yVmlld3BvcnRMZWF2ZS5lbWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3B5Rm9udFN0eWxlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuY2hvciB8fCAhdGhpcy5jb3B5QW5jaG9yU3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb21TZXJ2aWNlLmdldEZvbnRTdHlsZXModGhpcy5hbmNob3IpXG4gICAgICAgICAgICAuZm9yRWFjaChzID0+IHRoaXMuc2V0Q29udGFpbmVyU3R5bGUocy5rZXksIHMudmFsdWUpKTtcbiAgICB9XG4gICAgdXBkYXRlRml4ZWRDbGFzcygpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5wb3NpdGlvbk1vZGUgPT09ICdmaXhlZCcgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJztcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJbYWN0aW9uXSh0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCBBTklNQVRJT05fQ09OVEFJTkVSX0ZJWEVEKTtcbiAgICB9XG4gICAgc2V0Q29udGFpbmVyU3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVJlcG9zaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcG9zaXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuUG9wdXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvLXBvcHVwJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtBbGlnblNlcnZpY2UsIEFuaW1hdGlvblNlcnZpY2UsIERPTVNlcnZpY2UsIFBvc2l0aW9uU2VydmljZSwgUmVzaXplU2VydmljZSwgU2Nyb2xsYWJsZVNlcnZpY2VdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcG9wdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLXBvcHVwXCIgW25nQ2xhc3NdPVwicG9wdXBDbGFzc1wiICNjb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29udGVudFwiIFtuZ0lmXT1cImNvbnRlbnRcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgW3JhdGVMaW1pdF09XCIxMDBcIiAocmVzaXplKT1cIm9uUmVzaXplKClcIj5cbiAgICAgICAgICAgIDwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICAgICAgPC9kaXY+XG4gICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUG9wdXBDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBBbGlnblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IERPTVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFBvc2l0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogUmVzaXplU2VydmljZSB9LFxuICAgIHsgdHlwZTogU2Nyb2xsYWJsZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEFuaW1hdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5Qb3B1cENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBhbmltYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmNob3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFuY2hvckFsaWduOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2xsaXNpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvcHVwQWxpZ246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvcHlBbmNob3JTdHlsZXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvcHVwQ2xhc3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvc2l0aW9uTW9kZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb2Zmc2V0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXJnaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFuY2hvclZpZXdwb3J0TGVhdmU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9wZW46IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBwb3NpdGlvbkNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbnRlbnRDb250YWluZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydjb250YWluZXInLF0gfV0sXG4gICAgcmVzaXplU2Vuc29yOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtSZXNpemVTZW5zb3JDb21wb25lbnQsXSB9XVxufTtcblxuY29uc3QgcmVtb3ZlRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG59O1xuLyoqXG4gKiBVc2VkIHRvIGluamVjdCB0aGUgUG9wdXAgY29udGFpbmVyLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCByb290IGNvbXBvbmVudCBvZlxuICogdGhlIGFwcGxpY2F0aW9uIGlzIHVzZWQuXG4gKlxuICogPiBUaGUgYFBPUFVQX0NPTlRBSU5FUmAgY2FuIGJlIHVzZWQgb25seSB3aXRoIHRoZSBbYFBvcHVwU2VydmljZWBdKHslIHNsdWcgc2VydmljZV9wb3B1cCAlfSkgY2xhc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgUG9wdXAgbW9kdWxlXG4gKiBpbXBvcnQgeyBQb3B1cE1vZHVsZSwgUE9QVVBfQ09OVEFJTkVSIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgRWxlbWVudFJlZiwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBQb3B1cE1vZHVsZV0sIC8vIGltcG9ydCBQb3B1cCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdLFxuICogICAgIHByb3ZpZGVyczogW3tcbiAqICAgICAgIHByb3ZpZGU6IFBPUFVQX0NPTlRBSU5FUixcbiAqICAgICAgIHVzZUZhY3Rvcnk6ICgpID0+IHtcbiAqICAgICAgICAgIC8vcmV0dXJuIHRoZSBjb250YWluZXIgRWxlbWVudFJlZiwgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgaW5qZWN0ZWRcbiAqICAgICAgICAgIHJldHVybiB7IG5hdGl2ZUVsZW1lbnQ6IGRvY3VtZW50LmJvZHkgfSBhcyBFbGVtZW50UmVmO1xuICogICAgICAgfVxuICogICAgIH1dXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKiBgYGBcbiAqL1xuY29uc3QgUE9QVVBfQ09OVEFJTkVSID0gbmV3IEluamVjdGlvblRva2VuKCdQb3B1cCBDb250YWluZXInKTtcbi8qKlxuICogQSBzZXJ2aWNlIGZvciBvcGVuaW5nIFBvcHVwIGNvbXBvbmVudHMgZHluYW1pY2FsbHlcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2VydmljZV9wb3B1cCAlfSkpLlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBQb3B1cFNlcnZpY2VcbiAqL1xuY2xhc3MgUG9wdXBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvblJlZiwgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBpbmplY3RvciwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25SZWYgPSBhcHBsaWNhdGlvblJlZjtcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvb3QgdmlldyBjb250YWluZXIgaW50byB3aGljaCB0aGUgY29tcG9uZW50IHdpbGwgYmUgaW5qZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XG4gICAgICovXG4gICAgZ2V0IHJvb3RWaWV3Q29udGFpbmVyKCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNC4wLngvcGFja2FnZXMvY29yZS9zcmMvYXBwbGljYXRpb25fcmVmLnRzI0w1NzFcbiAgICAgICAgY29uc3Qgcm9vdENvbXBvbmVudHMgPSB0aGlzLmFwcGxpY2F0aW9uUmVmLmNvbXBvbmVudHMgfHwgW107XG4gICAgICAgIGlmIChyb290Q29tcG9uZW50c1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RDb21wb25lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICBWaWV3IENvbnRhaW5lciBub3QgZm91bmQhIEluamVjdCB0aGUgUE9QVVBfQ09OVEFJTkVSIG9yIGRlZmluZSBhIHNwZWNpZmljIFZpZXdDb250YWluZXJSZWYgdmlhIHRoZSBhcHBlbmRUbyBvcHRpb24uXG4gICAgICAgICAgICBTZWUgaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvcG9wdXAvYXBpL1BPUFVQX0NPTlRBSU5FUi8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgSFRNTCBlbGVtZW50IG9mIHRoZSByb290IGNvbXBvbmVudCBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IHJvb3RWaWV3Q29udGFpbmVyTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyID8gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCA6IHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUodGhpcy5yb290Vmlld0NvbnRhaW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgUG9wdXAgY29tcG9uZW50LiBDcmVhdGVkIFBvcHVwcyBhcmUgbW91bnRlZFxuICAgICAqIGluIHRoZSBET00gZGlyZWN0bHkgaW4gdGhlIHJvb3QgYXBwbGljYXRpb24gY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb3B1cFNldHRpbmdzfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgd2hpY2ggZGVmaW5lIHRoZSBQb3B1cC5cbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPFBvcHVwQ29tcG9uZW50Pn0gLSBBIHJlZmVyZW5jZSB0byB0aGUgUG9wdXAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgIDxuZy10ZW1wbGF0ZSAjdGVtcGxhdGU+XG4gICAgICogICAgICBQb3B1cCBjb250ZW50XG4gICAgICogICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogICAgIDxidXR0b24gI2FuY2hvciBrZW5kb0J1dHRvbiAoY2xpY2spPVwib3BlbihhbmNob3IsIHRlbXBsYXRlKVwiPk9wZW48L2J1dHRvbj5cbiAgICAgKiAgIGBcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgICBwdWJsaWMgcG9wdXBSZWY6IFBvcHVwUmVmO1xuICAgICAqXG4gICAgICogICAgIGNvbnN0cnVjdG9yKCBwcml2YXRlIHBvcHVwU2VydmljZTogUG9wdXBTZXJ2aWNlICkge31cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgb3BlbihhbmNob3I6IEVsZW1lbnRSZWYsIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KTogdm9pZCB7XG4gICAgICogICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAqICAgICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICogICAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAqICAgICAgICAgICAgICByZXR1cm47XG4gICAgICogICAgICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKHtcbiAgICAgKiAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICogICAgICAgICAgIGNvbnRlbnQ6IHRlbXBsYXRlXG4gICAgICogICAgICAgICB9KTtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvcGVuKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGNvbXBvbmVudCwgbm9kZXMgfSA9IHRoaXMuY29udGVudEZyb20ob3B0aW9ucy5jb250ZW50KTtcbiAgICAgICAgY29uc3QgcG9wdXBDb21wb25lbnRSZWYgPSB0aGlzLmFwcGVuZFBvcHVwKG5vZGVzLCBvcHRpb25zLmFwcGVuZFRvKTtcbiAgICAgICAgY29uc3QgcG9wdXBJbnN0YW5jZSA9IHBvcHVwQ29tcG9uZW50UmVmLmluc3RhbmNlO1xuICAgICAgICB0aGlzLnByb2plY3RDb21wb25lbnRJbnB1dHMocG9wdXBDb21wb25lbnRSZWYsIG9wdGlvbnMpO1xuICAgICAgICBwb3B1cENvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9wdXBFbGVtZW50ID0gdGhpcy5nZXRDb21wb25lbnRSb290Tm9kZShwb3B1cENvbXBvbmVudFJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9wdXBDb21wb25lbnRSZWYuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIC8vIEFuZ3VsYXIgd2lsbCBub3QgcmVtb3ZlIHRoZSBlbGVtZW50IHVubGVzcyB0aGUgY2hhbmdlIGRldGVjdGlvbiBpcyB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KHBvcHVwRWxlbWVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgcG9wdXA6IHBvcHVwQ29tcG9uZW50UmVmLFxuICAgICAgICAgICAgcG9wdXBBbmNob3JWaWV3cG9ydExlYXZlOiBwb3B1cEluc3RhbmNlLmFuY2hvclZpZXdwb3J0TGVhdmUsXG4gICAgICAgICAgICBwb3B1cENsb3NlOiBwb3B1cEluc3RhbmNlLmNsb3NlLFxuICAgICAgICAgICAgcG9wdXBFbGVtZW50OiBwb3B1cEVsZW1lbnQsXG4gICAgICAgICAgICBwb3B1cE9wZW46IHBvcHVwSW5zdGFuY2Uub3BlbixcbiAgICAgICAgICAgIHBvcHVwUG9zaXRpb25DaGFuZ2U6IHBvcHVwSW5zdGFuY2UucG9zaXRpb25DaGFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kUG9wdXAobm9kZXMsIGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBwb3B1cENvbXBvbmVudFJlZiA9IHRoaXMuY3JlYXRlQ29tcG9uZW50KFBvcHVwQ29tcG9uZW50LCBub2RlcywgY29udGFpbmVyKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdFZpZXdDb250YWluZXJOb2RlLmFwcGVuZENoaWxkKHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUocG9wdXBDb21wb25lbnRSZWYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9wdXBDb21wb25lbnRSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEhUTUwgZWxlbWVudCBmb3IgYSBjb21wb25lbnQgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb21wb25lbnRSZWY8YW55Pn0gY29tcG9uZW50UmVmXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudFJvb3ROb2RlKGNvbXBvbmVudFJlZikge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGBDb21wb25lbnRGYWN0b3J5YCBpbnN0YW5jZSBieSBpdHMgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gY29tcG9uZW50Q2xhc3NcbiAgICAgKiBAcGFyYW0geyp9IG5vZGVzXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudENsYXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBvbmVudCByZWZlcmVuY2UgZnJvbSBhIGBDb21wb25lbnRgIHR5cGUgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGNvbXBvbmVudENsYXNzXG4gICAgICogQHBhcmFtIHsqfSBub2Rlc1xuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cbiAgICAgKi9cbiAgICBjcmVhdGVDb21wb25lbnQoY29tcG9uZW50Q2xhc3MsIG5vZGVzLCBjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZ2V0Q29tcG9uZW50RmFjdG9yeShjb21wb25lbnRDbGFzcyk7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHVuZGVmaW5lZCwgdGhpcy5pbmplY3Rvciwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZmFjdG9yeS5jcmVhdGUodGhpcy5pbmplY3Rvciwgbm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvblJlZi5hdHRhY2hWaWV3KGNvbXBvbmVudC5ob3N0Vmlldyk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RzIHRoZSBpbnB1dHMgb24gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50UmVmPGFueT59IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9qZWN0Q29tcG9uZW50SW5wdXRzKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihwcm9wID0+IHByb3AgIT09ICdjb250ZW50JyB8fCBvcHRpb25zLmNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZilcbiAgICAgICAgICAgIC5tYXAoKHByb3ApID0+IHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb21wb25lbnQgYW5kIHRoZSBub2RlcyB0byBhcHBlbmQgZnJvbSB0aGUgYGNvbnRlbnRgIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gY29udGVudFxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgY29udGVudEZyb20oY29udGVudCkge1xuICAgICAgICBpZiAoIWNvbnRlbnQgfHwgY29udGVudCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnQ6IG51bGwsIG5vZGVzOiBbW11dIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jcmVhdGVDb21wb25lbnQoY29udGVudCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gY29tcG9uZW50ID8gW2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50XSA6IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICBub2RlczogW1xuICAgICAgICAgICAgICAgIG5vZGVzIC8vIDxuZy1jb250ZW50PlxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbn1cblBvcHVwU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUG9wdXBTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQXBwbGljYXRpb25SZWYgfSxcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW1BPUFVQX0NPTlRBSU5FUixdIH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuY29uc3QgUE9QVVBfRElSRUNUSVZFUyA9IFtQb3B1cENvbXBvbmVudF07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBQb3B1cCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgUG9wdXAgbW9kdWxlXG4gKiBpbXBvcnQgeyBQb3B1cE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgUG9wdXBNb2R1bGVdLCAvLyBpbXBvcnQgUG9wdXAgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5jbGFzcyBQb3B1cE1vZHVsZSB7XG59XG5Qb3B1cE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUE9QVVBfRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbUE9QVVBfRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1BPUFVQX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUG9wdXBTZXJ2aWNlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEFsaWduU2VydmljZSwgQW5pbWF0aW9uU2VydmljZSwgRE9NU2VydmljZSwgUG9zaXRpb25TZXJ2aWNlLCBSZXNpemVTZXJ2aWNlLCBTY3JvbGxhYmxlU2VydmljZSwgUG9wdXBTZXJ2aWNlLCBQT1BVUF9DT05UQUlORVIsIFBvcHVwQ29tcG9uZW50LCBQb3B1cE1vZHVsZSwgU0NBTEUgfTtcbiJdfQ==