/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Input, ContentChildren, QueryList, Component, NgZone, Directive, TemplateRef, Optional, forwardRef, SkipSelf, Host, ContentChild, NgModule } from '@angular/core';
import { saveAs } from '@progress/kendo-file-saver';
import { IntlService, ExcelExporter, Workbook } from '@progress/kendo-ooxml';
import * as ɵngcc0 from '@angular/core';
export * from '@progress/kendo-ooxml';
import { toString } from '@telerik/kendo-intl';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';

/* tslint:disable align */
/* tslint:disable:no-use-before-declare */
const compileTemplate = (templateRef, context, updateContext) => {
    let embeddedView = templateRef.createEmbeddedView(context);
    const result = (data) => {
        updateContext(context, data);
        embeddedView.detectChanges();
        return embeddedView.rootNodes.reduce((content, rootNode) => {
            return content + rootNode.textContent;
        }, '').trim();
    };
    result.destroy = () => {
        embeddedView.destroy();
        embeddedView = null;
    };
    return result;
};
const updateGroupHeaderContext = (context, data) => {
    context.$implicit = context.group = data;
    context.field = data.field;
    context.value = data.value;
    context.aggregates = data.aggregates;
};
const updateGroupFooterContext = (context, data) => {
    context.group = data.group;
    context.$implicit = context.aggregates = data;
};
const updateFooterContext = (context, data) => {
    context.aggregates = data.aggregates;
};
/**
 * @hidden
 */
const toExporterColumns = (sourceColumns) => {
    const exporterColumns = [];
    let columnIndex = 0;
    const addColumns = (columns, result, level) => {
        columns.forEach((column) => {
            if (column.level === level) {
                const exporterColumn = new ExporterColumn(column, columnIndex);
                result.push(exporterColumn);
                if (column.children && column.children.some(c => c !== column)) {
                    const children = exporterColumn.columns = [];
                    addColumns(column.children, children, level + 1);
                }
                else {
                    columnIndex++;
                }
            }
        });
    };
    addColumns(sourceColumns, exporterColumns, 0);
    return exporterColumns;
};
/**
 * @hidden
 */
const destroyColumns = (columns) => {
    if (columns) {
        columns.forEach(column => {
            column.destroy();
        });
    }
};
/**
 * @hidden
 */
class ExporterColumn {
    constructor(column, columnIndex) {
        this.title = column.title;
        this.field = column.field;
        this.hidden = column.hidden;
        this.locked = column.locked;
        this.width = column.width;
        this.headerCellOptions = column.headerCellOptions;
        this.cellOptions = column.cellOptions;
        this.groupHeaderCellOptions = column.groupHeaderCellOptions;
        this.groupFooterCellOptions = column.groupFooterCellOptions;
        this.footerCellOptions = column.footerCellOptions;
        if (column.footerTemplate) {
            this.footerTemplate = compileTemplate(column.footerTemplate.templateRef, {
                $implicit: column,
                column: column,
                columnIndex: columnIndex
            }, updateFooterContext);
        }
        if (column.groupFooterTemplate) {
            this.groupFooterTemplate = compileTemplate(column.groupFooterTemplate.templateRef, {
                column: column,
                field: column.field
            }, updateGroupFooterContext);
        }
        if (column.groupHeaderTemplate) {
            this.groupHeaderTemplate = compileTemplate(column.groupHeaderTemplate.templateRef, {}, updateGroupHeaderContext);
        }
        if (column.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate = compileTemplate(column.groupHeaderColumnTemplate.templateRef, {}, updateGroupHeaderContext);
        }
    }
    destroy() {
        if (this.footerTemplate) {
            this.footerTemplate.destroy();
        }
        if (this.groupFooterTemplate) {
            this.groupFooterTemplate.destroy();
        }
        if (this.groupHeaderTemplate) {
            this.groupHeaderTemplate.destroy();
        }
        if (this.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate.destroy();
        }
        destroyColumns(this.columns);
    }
}

IntlService.register({ toString });
/**
 *
 * @hidden
 */
const workbookOptions = (options) => {
    const columns = toExporterColumns(options.columns);
    const exporter = new ExcelExporter({
        columns: columns,
        data: options.data,
        filterable: options.filterable,
        groups: options.group,
        paddingCellOptions: options.paddingCellOptions,
        headerPaddingCellOptions: options.headerPaddingCellOptions,
        collapsible: options.collapsible,
        hierarchy: options.hierarchy,
        aggregates: options.aggregates
    });
    const result = exporter.workbook();
    result.creator = options.creator;
    result.date = options.date;
    result.rtl = options.rtl;
    destroyColumns(columns);
    return result;
};
/**
 * @hidden
 */
const toDataURL = (options) => {
    const workbook = new Workbook(options);
    return workbook.toDataURL();
};
/**
 * @hidden
 */
const isWorkbookOptions = (value) => {
    return value && value.sheets;
};

/**
 * @hidden
 */
class ColumnBase {
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * @hidden
     */
    get level() {
        return this.parent ? this.parent.level + 1 : 0;
    }
}
ColumnBase.ɵfac = function ColumnBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ColumnBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnBase, contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { title: "title", width: "width", locked: "locked", hidden: "hidden", headerCellOptions: "headerCellOptions" } });
ColumnBase.propDecorators = {
    title: [{ type: Input }],
    width: [{ type: Input }],
    locked: [{ type: Input }],
    hidden: [{ type: Input }],
    headerCellOptions: [{ type: Input }],
    children: [{ type: ContentChildren, args: [ColumnBase,] }]
};


// tslint:disable:max-line-length
/**
 * Represents the [Kendo UI Excel Export component for Angular]({% slug overview_excelexport %}).
 * Configures the settings for the Excel export of the Kendo UI Grid.
 */
class ExcelExportComponent {
    constructor(localization, zone) {
        this.localization = localization;
        this.zone = zone;
        /**
         * Specifies the name of the file that is exported to Excel.
         * @default "Export.xlsx"
         */
        this.fileName = 'Export.xlsx';
        /**
         * @hidden
         */
        this.columns = new QueryList();
        this.saveFile = this.saveFile.bind(this);
    }
    /**
     * Saves the data to Excel.
     *
     * @param exportData - An optional parameter. Can be the data that will be exported or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}).
     */
    save(exportData) {
        this.toDataURL(exportData).then(this.saveFile);
    }
    /**
     * Based on the specified columns and data, returns
     * [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %})
     * ([see example]({% slug customrowsandcells_excelexport %})).
     *
     * @param exportData - The optional data to be exported.
     * @returns {WorkbookOptions} - The workbook options.
     */
    workbookOptions(exportData) {
        const currentData = this.getExportData(exportData);
        const options = workbookOptions({
            columns: this.columns,
            data: currentData.data,
            group: currentData.group,
            filterable: this.filterable,
            creator: this.creator,
            date: this.date,
            rtl: this.localization.rtl,
            paddingCellOptions: this.paddingCellOptions,
            headerPaddingCellOptions: this.headerPaddingCellOptions,
            collapsible: this.collapsible
        });
        return options;
    }
    /**
     * Returns a promise which will be resolved with the file data URI
     * ([see example]({% slug filesaving_excelexport %})).
     *
     * @param exportData - The optional data or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}) that will be used to generate the data URI.
     * @returns {Promise<string>} - The promise that will be resolved by the file data URI.
     */
    toDataURL(exportData) {
        const options = isWorkbookOptions(exportData) ?
            exportData :
            this.workbookOptions(exportData);
        return this.zone.runOutsideAngular(() => toDataURL(options));
    }
    getExportData(exportData) {
        let result;
        if (exportData) {
            if (Array.isArray(exportData)) {
                result = {
                    data: exportData
                };
            }
            else {
                result = exportData;
            }
        }
        else {
            result = {
                data: this.data,
                group: this.group
            };
        }
        return result;
    }
    saveFile(dataURL) {
        saveAs(dataURL, this.fileName, {
            forceProxy: this.forceProxy,
            proxyURL: this.proxyURL
        });
    }
}
ExcelExportComponent.ɵfac = function ExcelExportComponent_Factory(t) { return new (t || ExcelExportComponent)(ɵngcc0.ɵɵdirectiveInject(LocalizationService), ɵngcc0.ɵɵdirectiveInject(NgZone)); };
ExcelExportComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ExcelExportComponent, selectors: [["kendo-excelexport"]], contentQueries: function ExcelExportComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { fileName: "fileName", filterable: "filterable", collapsible: "collapsible", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", data: "data", group: "group", paddingCellOptions: "paddingCellOptions", headerPaddingCellOptions: "headerPaddingCellOptions" }, exportAs: ["kendoExcelExport"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.excelexport'
            }
        ])], decls: 0, vars: 0, template: function ExcelExportComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ExcelExportComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: NgZone }
];
ExcelExportComponent.propDecorators = {
    fileName: [{ type: Input }],
    filterable: [{ type: Input }],
    collapsible: [{ type: Input }],
    creator: [{ type: Input }],
    date: [{ type: Input }],
    forceProxy: [{ type: Input }],
    proxyURL: [{ type: Input }],
    data: [{ type: Input }],
    group: [{ type: Input }],
    paddingCellOptions: [{ type: Input }],
    headerPaddingCellOptions: [{ type: Input }],
    columns: [{ type: ContentChildren, args: [ColumnBase, { descendants: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelExportComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoExcelExport',
                selector: 'kendo-excelexport',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.excelexport'
                    }
                ],
                template: ``
            }]
    }], function () { return [{ type: LocalizationService }, { type: NgZone }]; }, { fileName: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase, { descendants: true }]
        }], filterable: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], creator: [{
            type: Input
        }], date: [{
            type: Input
        }], forceProxy: [{
            type: Input
        }], proxyURL: [{
            type: Input
        }], data: [{
            type: Input
        }], group: [{
            type: Input
        }], paddingCellOptions: [{
            type: Input
        }], headerPaddingCellOptions: [{
            type: Input
        }] }); })();

/**
 * Represents the group header cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-template)).
 * Enables you to customize the content of the group header item.
 */
class GroupHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) { return new (t || GroupHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef, 8)); };
GroupHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderTemplate", ""]] });
/** @nocollapse */
GroupHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderTemplate]'
            }]
    }], function () { return [{ type: TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the group header column template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-column-template)).
 */
class GroupHeaderColumnTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) { return new (t || GroupHeaderColumnTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef, 8)); };
GroupHeaderColumnTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderColumnTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderColumnTemplate", ""]] });
/** @nocollapse */
GroupHeaderColumnTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupHeaderColumnTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderColumnTemplate]'
            }]
    }], function () { return [{ type: TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the group footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-footer-template)).
 * Enables you to customize the group footer cell of the column.
 */
class GroupFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) { return new (t || GroupFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef, 8)); };
GroupFooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupFooterTemplateDirective, selectors: [["", "kendoExcelExportGroupFooterTemplate", ""]] });
/** @nocollapse */
GroupFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupFooterTemplate]'
            }]
    }], function () { return [{ type: TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-footer-template)).
 * Enables you to customize the footer cell of the column.
 */
class FooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) { return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef, 8)); };
FooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FooterTemplateDirective, selectors: [["", "kendoExcelExportFooterTemplate", ""]] });
/** @nocollapse */
FooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportFooterTemplate]'
            }]
    }], function () { return [{ type: TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the columns of the Kendo UI Excel Export component for Angular.
 */
class ColumnComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
    }
}
ColumnComponent.ɵfac = function ColumnComponent_Factory(t) { return new (t || ColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnComponent, selectors: [["kendo-excelexport-column"]], contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
    } }, inputs: { field: "field", cellOptions: "cellOptions", groupHeaderCellOptions: "groupHeaderCellOptions", groupFooterCellOptions: "groupFooterCellOptions", footerCellOptions: "footerCellOptions" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnComponent.ctorParameters = () => [
    { type: ColumnBase, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }
];
ColumnComponent.propDecorators = {
    field: [{ type: Input }],
    cellOptions: [{ type: Input }],
    groupHeaderCellOptions: [{ type: Input }],
    groupFooterCellOptions: [{ type: Input }],
    footerCellOptions: [{ type: Input }],
    groupHeaderTemplate: [{ type: ContentChild, args: [GroupHeaderTemplateDirective,] }],
    groupHeaderColumnTemplate: [{ type: ContentChild, args: [GroupHeaderColumnTemplateDirective,] }],
    groupFooterTemplate: [{ type: ContentChild, args: [GroupFooterTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, { field: [{
            type: Input
        }], cellOptions: [{
            type: Input
        }], groupHeaderCellOptions: [{
            type: Input
        }], groupFooterCellOptions: [{
            type: Input
        }], footerCellOptions: [{
            type: Input
        }], groupHeaderTemplate: [{
            type: ContentChild,
            args: [GroupHeaderTemplateDirective]
        }], groupHeaderColumnTemplate: [{
            type: ContentChild,
            args: [GroupHeaderColumnTemplateDirective]
        }], groupFooterTemplate: [{
            type: ContentChild,
            args: [GroupFooterTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective]
        }] }); })();

/**
 * Represents the column group component of the Kendo UI Excel Export component.
 */
class ColumnGroupComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
        this.parent = parent;
    }
}
ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) { return new (t || ColumnGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnGroupComponent, selectors: [["kendo-excelexport-column-group"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnGroupComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnGroupComponent.ctorParameters = () => [
    { type: ColumnBase, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnGroupComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnGroupComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column-group',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, null); })();

const declarations = [
    ExcelExportComponent,
    ColumnComponent,
    ColumnGroupComponent,
    FooterTemplateDirective,
    GroupFooterTemplateDirective,
    GroupHeaderTemplateDirective,
    GroupHeaderColumnTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Excel Export component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the ExcelExportModule module
 * import { ExcelExportModule } from '@progress/kendo-angular-excel-export';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ExcelExportModule], // import ExcelExportModule module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class ExcelExportModule {
}
ExcelExportModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ExcelExportModule });
ExcelExportModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ExcelExportModule_Factory(t) { return new (t || ExcelExportModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExcelExportModule, { declarations: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective], exports: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelExportModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [declarations]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { GroupHeaderColumnTemplateDirective, ExcelExportComponent, ExcelExportModule, ColumnBase, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, workbookOptions, toDataURL, isWorkbookOptions };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7bUlBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7bUhBY0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FMQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUtBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3NKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IElucHV0LCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgQ29tcG9uZW50LCBOZ1pvbmUsIERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYsIE9wdGlvbmFsLCBmb3J3YXJkUmVmLCBTa2lwU2VsZiwgSG9zdCwgQ29udGVudENoaWxkLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgc2F2ZUFzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWZpbGUtc2F2ZXInO1xuaW1wb3J0IHsgSW50bFNlcnZpY2UsIEV4Y2VsRXhwb3J0ZXIsIFdvcmtib29rIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLW9veG1sJztcbmV4cG9ydCAqIGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1vb3htbCc7XG5pbXBvcnQgeyB0b1N0cmluZyB9IGZyb20gJ0B0ZWxlcmlrL2tlbmRvLWludGwnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVggfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcblxuLyogdHNsaW50OmRpc2FibGUgYWxpZ24gKi9cbi8qIHRzbGludDpkaXNhYmxlOm5vLXVzZS1iZWZvcmUtZGVjbGFyZSAqL1xuY29uc3QgY29tcGlsZVRlbXBsYXRlID0gKHRlbXBsYXRlUmVmLCBjb250ZXh0LCB1cGRhdGVDb250ZXh0KSA9PiB7XG4gICAgbGV0IGVtYmVkZGVkVmlldyA9IHRlbXBsYXRlUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhjb250ZXh0KTtcbiAgICBjb25zdCByZXN1bHQgPSAoZGF0YSkgPT4ge1xuICAgICAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICBlbWJlZGRlZFZpZXcuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICByZXR1cm4gZW1iZWRkZWRWaWV3LnJvb3ROb2Rlcy5yZWR1Y2UoKGNvbnRlbnQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudCArIHJvb3ROb2RlLnRleHRDb250ZW50O1xuICAgICAgICB9LCAnJykudHJpbSgpO1xuICAgIH07XG4gICAgcmVzdWx0LmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGVtYmVkZGVkVmlldy5kZXN0cm95KCk7XG4gICAgICAgIGVtYmVkZGVkVmlldyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IHVwZGF0ZUdyb3VwSGVhZGVyQ29udGV4dCA9IChjb250ZXh0LCBkYXRhKSA9PiB7XG4gICAgY29udGV4dC4kaW1wbGljaXQgPSBjb250ZXh0Lmdyb3VwID0gZGF0YTtcbiAgICBjb250ZXh0LmZpZWxkID0gZGF0YS5maWVsZDtcbiAgICBjb250ZXh0LnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICBjb250ZXh0LmFnZ3JlZ2F0ZXMgPSBkYXRhLmFnZ3JlZ2F0ZXM7XG59O1xuY29uc3QgdXBkYXRlR3JvdXBGb290ZXJDb250ZXh0ID0gKGNvbnRleHQsIGRhdGEpID0+IHtcbiAgICBjb250ZXh0Lmdyb3VwID0gZGF0YS5ncm91cDtcbiAgICBjb250ZXh0LiRpbXBsaWNpdCA9IGNvbnRleHQuYWdncmVnYXRlcyA9IGRhdGE7XG59O1xuY29uc3QgdXBkYXRlRm9vdGVyQ29udGV4dCA9IChjb250ZXh0LCBkYXRhKSA9PiB7XG4gICAgY29udGV4dC5hZ2dyZWdhdGVzID0gZGF0YS5hZ2dyZWdhdGVzO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b0V4cG9ydGVyQ29sdW1ucyA9IChzb3VyY2VDb2x1bW5zKSA9PiB7XG4gICAgY29uc3QgZXhwb3J0ZXJDb2x1bW5zID0gW107XG4gICAgbGV0IGNvbHVtbkluZGV4ID0gMDtcbiAgICBjb25zdCBhZGRDb2x1bW5zID0gKGNvbHVtbnMsIHJlc3VsdCwgbGV2ZWwpID0+IHtcbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4ubGV2ZWwgPT09IGxldmVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0ZXJDb2x1bW4gPSBuZXcgRXhwb3J0ZXJDb2x1bW4oY29sdW1uLCBjb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXhwb3J0ZXJDb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uY2hpbGRyZW4gJiYgY29sdW1uLmNoaWxkcmVuLnNvbWUoYyA9PiBjICE9PSBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZXhwb3J0ZXJDb2x1bW4uY29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhZGRDb2x1bW5zKGNvbHVtbi5jaGlsZHJlbiwgY2hpbGRyZW4sIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhZGRDb2x1bW5zKHNvdXJjZUNvbHVtbnMsIGV4cG9ydGVyQ29sdW1ucywgMCk7XG4gICAgcmV0dXJuIGV4cG9ydGVyQ29sdW1ucztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGVzdHJveUNvbHVtbnMgPSAoY29sdW1ucykgPT4ge1xuICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICAgICAgY29sdW1uLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBFeHBvcnRlckNvbHVtbiB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uLCBjb2x1bW5JbmRleCkge1xuICAgICAgICB0aGlzLnRpdGxlID0gY29sdW1uLnRpdGxlO1xuICAgICAgICB0aGlzLmZpZWxkID0gY29sdW1uLmZpZWxkO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGNvbHVtbi5oaWRkZW47XG4gICAgICAgIHRoaXMubG9ja2VkID0gY29sdW1uLmxvY2tlZDtcbiAgICAgICAgdGhpcy53aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgdGhpcy5oZWFkZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5oZWFkZXJDZWxsT3B0aW9ucztcbiAgICAgICAgdGhpcy5jZWxsT3B0aW9ucyA9IGNvbHVtbi5jZWxsT3B0aW9ucztcbiAgICAgICAgdGhpcy5ncm91cEhlYWRlckNlbGxPcHRpb25zID0gY29sdW1uLmdyb3VwSGVhZGVyQ2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBGb290ZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5ncm91cEZvb3RlckNlbGxPcHRpb25zO1xuICAgICAgICB0aGlzLmZvb3RlckNlbGxPcHRpb25zID0gY29sdW1uLmZvb3RlckNlbGxPcHRpb25zO1xuICAgICAgICBpZiAoY29sdW1uLmZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvb3RlclRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKGNvbHVtbi5mb290ZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZiwge1xuICAgICAgICAgICAgICAgICRpbXBsaWNpdDogY29sdW1uLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleFxuICAgICAgICAgICAgfSwgdXBkYXRlRm9vdGVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbi5ncm91cEZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwRm9vdGVyVGVtcGxhdGUgPSBjb21waWxlVGVtcGxhdGUoY29sdW1uLmdyb3VwRm9vdGVyVGVtcGxhdGUudGVtcGxhdGVSZWYsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBmaWVsZDogY29sdW1uLmZpZWxkXG4gICAgICAgICAgICB9LCB1cGRhdGVHcm91cEZvb3RlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4uZ3JvdXBIZWFkZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlclRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKGNvbHVtbi5ncm91cEhlYWRlclRlbXBsYXRlLnRlbXBsYXRlUmVmLCB7fSwgdXBkYXRlR3JvdXBIZWFkZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZS50ZW1wbGF0ZVJlZiwge30sIHVwZGF0ZUdyb3VwSGVhZGVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9vdGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9vdGVyVGVtcGxhdGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwRm9vdGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBGb290ZXJUZW1wbGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlclRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlc3Ryb3lDb2x1bW5zKHRoaXMuY29sdW1ucyk7XG4gICAgfVxufVxuXG5JbnRsU2VydmljZS5yZWdpc3Rlcih7IHRvU3RyaW5nIH0pO1xuLyoqXG4gKlxuICogQGhpZGRlblxuICovXG5jb25zdCB3b3JrYm9va09wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0b0V4cG9ydGVyQ29sdW1ucyhvcHRpb25zLmNvbHVtbnMpO1xuICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IEV4Y2VsRXhwb3J0ZXIoe1xuICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgIGZpbHRlcmFibGU6IG9wdGlvbnMuZmlsdGVyYWJsZSxcbiAgICAgICAgZ3JvdXBzOiBvcHRpb25zLmdyb3VwLFxuICAgICAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IG9wdGlvbnMucGFkZGluZ0NlbGxPcHRpb25zLFxuICAgICAgICBoZWFkZXJQYWRkaW5nQ2VsbE9wdGlvbnM6IG9wdGlvbnMuaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zLFxuICAgICAgICBjb2xsYXBzaWJsZTogb3B0aW9ucy5jb2xsYXBzaWJsZSxcbiAgICAgICAgaGllcmFyY2h5OiBvcHRpb25zLmhpZXJhcmNoeSxcbiAgICAgICAgYWdncmVnYXRlczogb3B0aW9ucy5hZ2dyZWdhdGVzXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gZXhwb3J0ZXIud29ya2Jvb2soKTtcbiAgICByZXN1bHQuY3JlYXRvciA9IG9wdGlvbnMuY3JlYXRvcjtcbiAgICByZXN1bHQuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICByZXN1bHQucnRsID0gb3B0aW9ucy5ydGw7XG4gICAgZGVzdHJveUNvbHVtbnMoY29sdW1ucyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9EYXRhVVJMID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB3b3JrYm9vayA9IG5ldyBXb3JrYm9vayhvcHRpb25zKTtcbiAgICByZXR1cm4gd29ya2Jvb2sudG9EYXRhVVJMKCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzV29ya2Jvb2tPcHRpb25zID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnNoZWV0cztcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmxldmVsICsgMSA6IDA7XG4gICAgfVxufVxuQ29sdW1uQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgd2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvY2tlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGlkZGVuOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoZWFkZXJDZWxsT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2hpbGRyZW46IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0NvbHVtbkJhc2UsXSB9XVxufTtcblxuLy8gdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBFeGNlbCBFeHBvcnQgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2V4Y2VsZXhwb3J0ICV9KS5cbiAqIENvbmZpZ3VyZXMgdGhlIHNldHRpbmdzIGZvciB0aGUgRXhjZWwgZXhwb3J0IG9mIHRoZSBLZW5kbyBVSSBHcmlkLlxuICovXG5jbGFzcyBFeGNlbEV4cG9ydENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCB6b25lKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgaXMgZXhwb3J0ZWQgdG8gRXhjZWwuXG4gICAgICAgICAqIEBkZWZhdWx0IFwiRXhwb3J0Lnhsc3hcIlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9ICdFeHBvcnQueGxzeCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMuc2F2ZUZpbGUgPSB0aGlzLnNhdmVGaWxlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBkYXRhIHRvIEV4Y2VsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4cG9ydERhdGEgLSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIuIENhbiBiZSB0aGUgZGF0YSB0aGF0IHdpbGwgYmUgZXhwb3J0ZWQgb3IgW2BXb3JrYm9va09wdGlvbnNgXSh7JSBzbHVnIGFwaV9leGNlbC1leHBvcnRfd29ya2Jvb2tvcHRpb25zICV9KS5cbiAgICAgKi9cbiAgICBzYXZlKGV4cG9ydERhdGEpIHtcbiAgICAgICAgdGhpcy50b0RhdGFVUkwoZXhwb3J0RGF0YSkudGhlbih0aGlzLnNhdmVGaWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdGhlIHNwZWNpZmllZCBjb2x1bW5zIGFuZCBkYXRhLCByZXR1cm5zXG4gICAgICogW2BXb3JrYm9va09wdGlvbnNgXSh7JSBzbHVnIGFwaV9leGNlbC1leHBvcnRfd29ya2Jvb2tvcHRpb25zICV9KVxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY3VzdG9tcm93c2FuZGNlbGxzX2V4Y2VsZXhwb3J0ICV9KSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwb3J0RGF0YSAtIFRoZSBvcHRpb25hbCBkYXRhIHRvIGJlIGV4cG9ydGVkLlxuICAgICAqIEByZXR1cm5zIHtXb3JrYm9va09wdGlvbnN9IC0gVGhlIHdvcmtib29rIG9wdGlvbnMuXG4gICAgICovXG4gICAgd29ya2Jvb2tPcHRpb25zKGV4cG9ydERhdGEpIHtcbiAgICAgICAgY29uc3QgY3VycmVudERhdGEgPSB0aGlzLmdldEV4cG9ydERhdGEoZXhwb3J0RGF0YSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB3b3JrYm9va09wdGlvbnMoe1xuICAgICAgICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLFxuICAgICAgICAgICAgZGF0YTogY3VycmVudERhdGEuZGF0YSxcbiAgICAgICAgICAgIGdyb3VwOiBjdXJyZW50RGF0YS5ncm91cCxcbiAgICAgICAgICAgIGZpbHRlcmFibGU6IHRoaXMuZmlsdGVyYWJsZSxcbiAgICAgICAgICAgIGNyZWF0b3I6IHRoaXMuY3JlYXRvcixcbiAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF0ZSxcbiAgICAgICAgICAgIHJ0bDogdGhpcy5sb2NhbGl6YXRpb24ucnRsLFxuICAgICAgICAgICAgcGFkZGluZ0NlbGxPcHRpb25zOiB0aGlzLnBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlclBhZGRpbmdDZWxsT3B0aW9uczogdGhpcy5oZWFkZXJQYWRkaW5nQ2VsbE9wdGlvbnMsXG4gICAgICAgICAgICBjb2xsYXBzaWJsZTogdGhpcy5jb2xsYXBzaWJsZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZmlsZSBkYXRhIFVSSVxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZmlsZXNhdmluZ19leGNlbGV4cG9ydCAlfSkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4cG9ydERhdGEgLSBUaGUgb3B0aW9uYWwgZGF0YSBvciBbYFdvcmtib29rT3B0aW9uc2BdKHslIHNsdWcgYXBpX2V4Y2VsLWV4cG9ydF93b3JrYm9va29wdGlvbnMgJX0pIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBkYXRhIFVSSS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFRoZSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBieSB0aGUgZmlsZSBkYXRhIFVSSS5cbiAgICAgKi9cbiAgICB0b0RhdGFVUkwoZXhwb3J0RGF0YSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gaXNXb3JrYm9va09wdGlvbnMoZXhwb3J0RGF0YSkgP1xuICAgICAgICAgICAgZXhwb3J0RGF0YSA6XG4gICAgICAgICAgICB0aGlzLndvcmtib29rT3B0aW9ucyhleHBvcnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0b0RhdGFVUkwob3B0aW9ucykpO1xuICAgIH1cbiAgICBnZXRFeHBvcnREYXRhKGV4cG9ydERhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGV4cG9ydERhdGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4cG9ydERhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBleHBvcnREYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cG9ydERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgIGdyb3VwOiB0aGlzLmdyb3VwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNhdmVGaWxlKGRhdGFVUkwpIHtcbiAgICAgICAgc2F2ZUFzKGRhdGFVUkwsIHRoaXMuZmlsZU5hbWUsIHtcbiAgICAgICAgICAgIGZvcmNlUHJveHk6IHRoaXMuZm9yY2VQcm94eSxcbiAgICAgICAgICAgIHByb3h5VVJMOiB0aGlzLnByb3h5VVJMXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkV4Y2VsRXhwb3J0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0V4Y2VsRXhwb3J0JyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4Y2VsZXhwb3J0JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmV4Y2VsZXhwb3J0J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRXhjZWxFeHBvcnRDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcbkV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZpbGVOYW1lOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2xsYXBzaWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3JlYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9yY2VQcm94eTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcHJveHlVUkw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGE6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGdyb3VwOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhlYWRlclBhZGRpbmdDZWxsT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sdW1uczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbQ29sdW1uQmFzZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZ3JvdXAgaGVhZGVyIGNlbGwgdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1ncm91cC1oZWFkZXItdGVtcGxhdGUpKS5cbiAqIEVuYWJsZXMgeW91IHRvIGN1c3RvbWl6ZSB0aGUgY29udGVudCBvZiB0aGUgZ3JvdXAgaGVhZGVyIGl0ZW0uXG4gKi9cbmNsYXNzIEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Hcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FeGNlbEV4cG9ydEdyb3VwSGVhZGVyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Hcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZ3JvdXAgaGVhZGVyIGNvbHVtbiB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWdyb3VwLWhlYWRlci1jb2x1bW4tdGVtcGxhdGUpKS5cbiAqL1xuY2xhc3MgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0R3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBncm91cCBmb290ZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWdyb3VwLWZvb3Rlci10ZW1wbGF0ZSkpLlxuICogRW5hYmxlcyB5b3UgdG8gY3VzdG9taXplIHRoZSBncm91cCBmb290ZXIgY2VsbCBvZiB0aGUgY29sdW1uLlxuICovXG5jbGFzcyBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRXhjZWxFeHBvcnRHcm91cEZvb3RlclRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGZvb3RlciBjZWxsIHRlbXBsYXRlIG9mIHRoZSBFeGNlbCBFeHBvcnQgY29sdW1uIGNvbXBvbmVudFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjb2x1bW5zX2V4Y2VsLWV4cG9ydCAlfSN0b2MtZm9vdGVyLXRlbXBsYXRlKSkuXG4gKiBFbmFibGVzIHlvdSB0byBjdXN0b21pemUgdGhlIGZvb3RlciBjZWxsIG9mIHRoZSBjb2x1bW4uXG4gKi9cbmNsYXNzIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0Rm9vdGVyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Gb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbHVtbnMgb2YgdGhlIEtlbmRvIFVJIEV4Y2VsIEV4cG9ydCBjb21wb25lbnQgZm9yIEFuZ3VsYXIuXG4gKi9cbmNsYXNzIENvbHVtbkNvbXBvbmVudCBleHRlbmRzIENvbHVtbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICBzdXBlcihwYXJlbnQpO1xuICAgIH1cbn1cbkNvbHVtbkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sdW1uQ29tcG9uZW50KSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZXhjZWxleHBvcnQtY29sdW1uJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sdW1uQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ29sdW1uQmFzZSwgZGVjb3JhdG9yczogW3sgdHlwZTogU2tpcFNlbGYgfSwgeyB0eXBlOiBIb3N0IH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcbkNvbHVtbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBmaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGdyb3VwSGVhZGVyQ2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGdyb3VwRm9vdGVyQ2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZvb3RlckNlbGxPcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBncm91cEhlYWRlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGdyb3VwRm9vdGVyVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0dyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBmb290ZXJUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW4gZ3JvdXAgY29tcG9uZW50IG9mIHRoZSBLZW5kbyBVSSBFeGNlbCBFeHBvcnQgY29tcG9uZW50LlxuICovXG5jbGFzcyBDb2x1bW5Hcm91cENvbXBvbmVudCBleHRlbmRzIENvbHVtbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG59XG5Db2x1bW5Hcm91cENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sdW1uR3JvdXBDb21wb25lbnQpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1leGNlbGV4cG9ydC1jb2x1bW4tZ3JvdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db2x1bW5Hcm91cENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbHVtbkJhc2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IFNraXBTZWxmIH0sIHsgdHlwZTogSG9zdCB9LCB7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbmNvbnN0IGRlY2xhcmF0aW9ucyA9IFtcbiAgICBFeGNlbEV4cG9ydENvbXBvbmVudCxcbiAgICBDb2x1bW5Db21wb25lbnQsXG4gICAgQ29sdW1uR3JvdXBDb21wb25lbnQsXG4gICAgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBFeGNlbCBFeHBvcnQgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIEV4Y2VsRXhwb3J0TW9kdWxlIG1vZHVsZVxuICogaW1wb3J0IHsgRXhjZWxFeHBvcnRNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1leGNlbC1leHBvcnQnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBFeGNlbEV4cG9ydE1vZHVsZV0sIC8vIGltcG9ydCBFeGNlbEV4cG9ydE1vZHVsZSBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIEV4Y2VsRXhwb3J0TW9kdWxlIHtcbn1cbkV4Y2VsRXhwb3J0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtkZWNsYXJhdGlvbnNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtkZWNsYXJhdGlvbnNdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSwgRXhjZWxFeHBvcnRDb21wb25lbnQsIEV4Y2VsRXhwb3J0TW9kdWxlLCBDb2x1bW5CYXNlLCBDb2x1bW5Db21wb25lbnQsIENvbHVtbkdyb3VwQ29tcG9uZW50LCBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgd29ya2Jvb2tPcHRpb25zLCB0b0RhdGFVUkwsIGlzV29ya2Jvb2tPcHRpb25zIH07XG4iXX0=