var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-collection.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, ViewEncapsulation } from '@angular/core';
import { reaction } from 'mobx';
import { observable, computed, action } from '../mobx-angular/mobx-proxy';
import { TreeModel } from '../models/tree.model';
var TreeNodeCollectionComponent = /** @class */ (function () {
    function TreeNodeCollectionComponent() {
        this._dispose = [];
    }
    Object.defineProperty(TreeNodeCollectionComponent.prototype, "nodes", {
        get: /**
         * @return {?}
         */
        function () {
            return this._nodes;
        },
        set: /**
         * @param {?} nodes
         * @return {?}
         */
        function (nodes) {
            this.setNodes(nodes);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNodeCollectionComponent.prototype, "marginTop", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];
            /** @type {?} */
            var relativePosition = firstNode && firstNode.parent
                ? firstNode.position -
                    firstNode.parent.position -
                    firstNode.parent.getSelfHeight()
                : 0;
            return relativePosition + "px";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} nodes
     * @return {?}
     */
    TreeNodeCollectionComponent.prototype.setNodes = /**
     * @param {?} nodes
     * @return {?}
     */
    function (nodes) {
        this._nodes = nodes;
    };
    /**
     * @return {?}
     */
    TreeNodeCollectionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.virtualScroll = this.treeModel.virtualScroll;
        this._dispose = [
            // return node indexes so we can compare structurally,
            reaction((/**
             * @return {?}
             */
            function () {
                return _this.virtualScroll
                    .getViewportNodes(_this.nodes)
                    .map((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) { return n.index; }));
            }), (/**
             * @param {?} nodeIndexes
             * @return {?}
             */
            function (nodeIndexes) {
                _this.viewportNodes = nodeIndexes.map((/**
                 * @param {?} i
                 * @return {?}
                 */
                function (i) { return _this.nodes[i]; }));
            }), (/** @type {?} */ ({ compareStructural: true, fireImmediately: true }))),
            reaction((/**
             * @return {?}
             */
            function () { return _this.nodes; }), (/**
             * @param {?} nodes
             * @return {?}
             */
            function (nodes) {
                _this.viewportNodes = _this.virtualScroll.getViewportNodes(nodes);
            }))
        ];
    };
    /**
     * @return {?}
     */
    TreeNodeCollectionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._dispose.forEach((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d(); }));
    };
    /**
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    TreeNodeCollectionComponent.prototype.trackNode = /**
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    function (index, node) {
        return node.id;
    };
    TreeNodeCollectionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'tree-node-collection',
                    encapsulation: ViewEncapsulation.None,
                    template: "\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div [style.margin-top]=\"marginTop\">\n        <tree-node\n          *ngFor=\"let node of viewportNodes; let i = index; trackBy: trackNode\"\n          [node]=\"node\"\n          [index]=\"i\"\n          [templates]=\"templates\"\n        >\n        </tree-node>\n      </div>\n    </ng-container>\n  "
                }] }
    ];
    TreeNodeCollectionComponent.propDecorators = {
        nodes: [{ type: Input }],
        treeModel: [{ type: Input }],
        templates: [{ type: Input }]
    };
    __decorate([
        observable,
        __metadata("design:type", Object)
    ], TreeNodeCollectionComponent.prototype, "_nodes", void 0);
    __decorate([
        observable,
        __metadata("design:type", Array)
    ], TreeNodeCollectionComponent.prototype, "viewportNodes", void 0);
    __decorate([
        computed,
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TreeNodeCollectionComponent.prototype, "marginTop", null);
    __decorate([
        action,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], TreeNodeCollectionComponent.prototype, "setNodes", null);
    return TreeNodeCollectionComponent;
}());
export { TreeNodeCollectionComponent };
if (false) {
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.treeModel;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype._nodes;
    /**
     * @type {?}
     * @private
     */
    TreeNodeCollectionComponent.prototype.virtualScroll;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.templates;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.viewportNodes;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype._dispose;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLWNvbGxlY3Rpb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNpcmNsb24vYW5ndWxhci10cmVlLWNvbXBvbmVudC8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3RyZWUtbm9kZS1jb2xsZWN0aW9uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLGlCQUFpQixFQUdsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2hDLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRzFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVqRDtJQUFBO1FBK0NFLGFBQVEsR0FBRyxFQUFFLENBQUM7SUFxQ2hCLENBQUM7SUFsRUMsc0JBQ0ksOENBQUs7Ozs7UUFEVDtZQUVFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDOzs7OztRQUNELFVBQVUsS0FBSztZQUNiLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdkIsQ0FBQzs7O09BSEE7SUFhUyxzQkFBSSxrREFBUzs7OztRQUFiOztnQkFDRixTQUFTLEdBQ2IsSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzs7Z0JBQ3BFLGdCQUFnQixHQUNwQixTQUFTLElBQUksU0FBUyxDQUFDLE1BQU07Z0JBQzNCLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUTtvQkFDbEIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRO29CQUN6QixTQUFTLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRTtnQkFDbEMsQ0FBQyxDQUFDLENBQUM7WUFFUCxPQUFVLGdCQUFnQixPQUFJLENBQUM7UUFDakMsQ0FBQzs7O09BQUE7Ozs7O0lBSU8sOENBQVE7Ozs7SUFBUixVQUFTLEtBQUs7UUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDdEIsQ0FBQzs7OztJQUVELDhDQUFROzs7SUFBUjtRQUFBLGlCQXNCQztRQXJCQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDO1FBQ2xELElBQUksQ0FBQyxRQUFRLEdBQUc7WUFDZCxzREFBc0Q7WUFDdEQsUUFBUTs7O1lBQ047Z0JBQ0UsT0FBTyxLQUFJLENBQUMsYUFBYTtxQkFDdEIsZ0JBQWdCLENBQUMsS0FBSSxDQUFDLEtBQUssQ0FBQztxQkFDNUIsR0FBRzs7OztnQkFBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxLQUFLLEVBQVAsQ0FBTyxFQUFDLENBQUM7WUFDdkIsQ0FBQzs7OztZQUNELFVBQUEsV0FBVztnQkFDVCxLQUFJLENBQUMsYUFBYSxHQUFHLFdBQVcsQ0FBQyxHQUFHOzs7O2dCQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsS0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBYixDQUFhLEVBQUMsQ0FBQztZQUMzRCxDQUFDLEdBQ0QsbUJBQUEsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLElBQUksRUFBRSxFQUFPLENBQzFEO1lBQ0QsUUFBUTs7O1lBQ04sY0FBTSxPQUFBLEtBQUksQ0FBQyxLQUFLLEVBQVYsQ0FBVTs7OztZQUNoQixVQUFBLEtBQUs7Z0JBQ0gsS0FBSSxDQUFDLGFBQWEsR0FBRyxLQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2xFLENBQUMsRUFDRjtTQUNGLENBQUM7SUFDSixDQUFDOzs7O0lBRUQsaURBQVc7OztJQUFYO1FBQ0UsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPOzs7O1FBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLEVBQUUsRUFBSCxDQUFHLEVBQUMsQ0FBQztJQUNsQyxDQUFDOzs7Ozs7SUFFRCwrQ0FBUzs7Ozs7SUFBVCxVQUFVLEtBQUssRUFBRSxJQUFJO1FBQ25CLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUNqQixDQUFDOztnQkFuRkYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxzQkFBc0I7b0JBQ2hDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO29CQUNyQyxRQUFRLEVBQUUsc1hBWVQ7aUJBQ0Y7Ozt3QkFFRSxLQUFLOzRCQVFMLEtBQUs7NEJBSUwsS0FBSzs7SUFGTTtRQUFYLFVBQVU7OytEQUFRO0lBSVA7UUFBWCxVQUFVOztzRUFBMkI7SUFFNUI7UUFBVCxRQUFROzs7Z0VBV1I7SUFJTztRQUFQLE1BQU07Ozs7K0RBRU47SUFpQ0gsa0NBQUM7Q0FBQSxBQXBGRCxJQW9GQztTQW5FWSwyQkFBMkI7OztJQVN0QyxnREFBOEI7O0lBRTlCLDZDQUFtQjs7Ozs7SUFDbkIsb0RBQXlDOztJQUN6QyxnREFBbUI7O0lBRW5CLG9EQUFzQzs7SUFldEMsK0NBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBWaWV3RW5jYXBzdWxhdGlvbixcclxuICBPbkluaXQsXHJcbiAgT25EZXN0cm95XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IHJlYWN0aW9uIH0gZnJvbSAnbW9ieCc7XHJcbmltcG9ydCB7IG9ic2VydmFibGUsIGNvbXB1dGVkLCBhY3Rpb24gfSBmcm9tICcuLi9tb2J4LWFuZ3VsYXIvbW9ieC1wcm94eSc7XHJcbmltcG9ydCB7IFRyZWVWaXJ0dWFsU2Nyb2xsIH0gZnJvbSAnLi4vbW9kZWxzL3RyZWUtdmlydHVhbC1zY3JvbGwubW9kZWwnO1xyXG5pbXBvcnQgeyBUcmVlTm9kZSB9IGZyb20gJy4uL21vZGVscy90cmVlLW5vZGUubW9kZWwnO1xyXG5pbXBvcnQgeyBUcmVlTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvdHJlZS5tb2RlbCc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3RyZWUtbm9kZS1jb2xsZWN0aW9uJyxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8bmctY29udGFpbmVyICp0cmVlTW9ieEF1dG9ydW49XCJ7IGRvbnREZXRhY2g6IHRydWUgfVwiPlxyXG4gICAgICA8ZGl2IFtzdHlsZS5tYXJnaW4tdG9wXT1cIm1hcmdpblRvcFwiPlxyXG4gICAgICAgIDx0cmVlLW5vZGVcclxuICAgICAgICAgICpuZ0Zvcj1cImxldCBub2RlIG9mIHZpZXdwb3J0Tm9kZXM7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrTm9kZVwiXHJcbiAgICAgICAgICBbbm9kZV09XCJub2RlXCJcclxuICAgICAgICAgIFtpbmRleF09XCJpXCJcclxuICAgICAgICAgIFt0ZW1wbGF0ZXNdPVwidGVtcGxhdGVzXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgPC90cmVlLW5vZGU+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVHJlZU5vZGVDb2xsZWN0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IG5vZGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX25vZGVzO1xyXG4gIH1cclxuICBzZXQgbm9kZXMobm9kZXMpIHtcclxuICAgIHRoaXMuc2V0Tm9kZXMobm9kZXMpO1xyXG4gIH1cclxuXHJcbiAgQElucHV0KCkgdHJlZU1vZGVsOiBUcmVlTW9kZWw7XHJcblxyXG4gIEBvYnNlcnZhYmxlIF9ub2RlcztcclxuICBwcml2YXRlIHZpcnR1YWxTY3JvbGw6IFRyZWVWaXJ0dWFsU2Nyb2xsOyAvLyBDYW5ub3QgaW5qZWN0IHRoaXMsIGJlY2F1c2Ugd2UgbWlnaHQgYmUgaW5zaWRlIHRyZWVOb2RlVGVtcGxhdGVGdWxsXHJcbiAgQElucHV0KCkgdGVtcGxhdGVzO1xyXG5cclxuICBAb2JzZXJ2YWJsZSB2aWV3cG9ydE5vZGVzOiBUcmVlTm9kZVtdO1xyXG5cclxuICBAY29tcHV0ZWQgZ2V0IG1hcmdpblRvcCgpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgZmlyc3ROb2RlID1cclxuICAgICAgdGhpcy52aWV3cG9ydE5vZGVzICYmIHRoaXMudmlld3BvcnROb2Rlcy5sZW5ndGggJiYgdGhpcy52aWV3cG9ydE5vZGVzWzBdO1xyXG4gICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9XHJcbiAgICAgIGZpcnN0Tm9kZSAmJiBmaXJzdE5vZGUucGFyZW50XHJcbiAgICAgICAgPyBmaXJzdE5vZGUucG9zaXRpb24gLVxyXG4gICAgICAgICAgZmlyc3ROb2RlLnBhcmVudC5wb3NpdGlvbiAtXHJcbiAgICAgICAgICBmaXJzdE5vZGUucGFyZW50LmdldFNlbGZIZWlnaHQoKVxyXG4gICAgICAgIDogMDtcclxuXHJcbiAgICByZXR1cm4gYCR7cmVsYXRpdmVQb3NpdGlvbn1weGA7XHJcbiAgfVxyXG5cclxuICBfZGlzcG9zZSA9IFtdO1xyXG5cclxuICBAYWN0aW9uIHNldE5vZGVzKG5vZGVzKSB7XHJcbiAgICB0aGlzLl9ub2RlcyA9IG5vZGVzO1xyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICB0aGlzLnZpcnR1YWxTY3JvbGwgPSB0aGlzLnRyZWVNb2RlbC52aXJ0dWFsU2Nyb2xsO1xyXG4gICAgdGhpcy5fZGlzcG9zZSA9IFtcclxuICAgICAgLy8gcmV0dXJuIG5vZGUgaW5kZXhlcyBzbyB3ZSBjYW4gY29tcGFyZSBzdHJ1Y3R1cmFsbHksXHJcbiAgICAgIHJlYWN0aW9uKFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnZpcnR1YWxTY3JvbGxcclxuICAgICAgICAgICAgLmdldFZpZXdwb3J0Tm9kZXModGhpcy5ub2RlcylcclxuICAgICAgICAgICAgLm1hcChuID0+IG4uaW5kZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9kZUluZGV4ZXMgPT4ge1xyXG4gICAgICAgICAgdGhpcy52aWV3cG9ydE5vZGVzID0gbm9kZUluZGV4ZXMubWFwKGkgPT4gdGhpcy5ub2Rlc1tpXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IGNvbXBhcmVTdHJ1Y3R1cmFsOiB0cnVlLCBmaXJlSW1tZWRpYXRlbHk6IHRydWUgfSBhcyBhbnlcclxuICAgICAgKSxcclxuICAgICAgcmVhY3Rpb24oXHJcbiAgICAgICAgKCkgPT4gdGhpcy5ub2RlcyxcclxuICAgICAgICBub2RlcyA9PiB7XHJcbiAgICAgICAgICB0aGlzLnZpZXdwb3J0Tm9kZXMgPSB0aGlzLnZpcnR1YWxTY3JvbGwuZ2V0Vmlld3BvcnROb2Rlcyhub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICApXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9kaXNwb3NlLmZvckVhY2goZCA9PiBkKCkpO1xyXG4gIH1cclxuXHJcbiAgdHJhY2tOb2RlKGluZGV4LCBub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5pZDtcclxuICB9XHJcbn1cclxuIl19