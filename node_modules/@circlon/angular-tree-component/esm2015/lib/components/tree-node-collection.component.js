var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-collection.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, ViewEncapsulation } from '@angular/core';
import { reaction } from 'mobx';
import { observable, computed, action } from '../mobx-angular/mobx-proxy';
import { TreeModel } from '../models/tree.model';
export class TreeNodeCollectionComponent {
    constructor() {
        this._dispose = [];
    }
    /**
     * @return {?}
     */
    get nodes() {
        return this._nodes;
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    set nodes(nodes) {
        this.setNodes(nodes);
    }
    /**
     * @return {?}
     */
    get marginTop() {
        /** @type {?} */
        const firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];
        /** @type {?} */
        const relativePosition = firstNode && firstNode.parent
            ? firstNode.position -
                firstNode.parent.position -
                firstNode.parent.getSelfHeight()
            : 0;
        return `${relativePosition}px`;
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    setNodes(nodes) {
        this._nodes = nodes;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.virtualScroll = this.treeModel.virtualScroll;
        this._dispose = [
            // return node indexes so we can compare structurally,
            reaction((/**
             * @return {?}
             */
            () => {
                return this.virtualScroll
                    .getViewportNodes(this.nodes)
                    .map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.index));
            }), (/**
             * @param {?} nodeIndexes
             * @return {?}
             */
            nodeIndexes => {
                this.viewportNodes = nodeIndexes.map((/**
                 * @param {?} i
                 * @return {?}
                 */
                i => this.nodes[i]));
            }), (/** @type {?} */ ({ compareStructural: true, fireImmediately: true }))),
            reaction((/**
             * @return {?}
             */
            () => this.nodes), (/**
             * @param {?} nodes
             * @return {?}
             */
            nodes => {
                this.viewportNodes = this.virtualScroll.getViewportNodes(nodes);
            }))
        ];
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._dispose.forEach((/**
         * @param {?} d
         * @return {?}
         */
        d => d()));
    }
    /**
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    trackNode(index, node) {
        return node.id;
    }
}
TreeNodeCollectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'tree-node-collection',
                encapsulation: ViewEncapsulation.None,
                template: `
    <ng-container *treeMobxAutorun="{ dontDetach: true }">
      <div [style.margin-top]="marginTop">
        <tree-node
          *ngFor="let node of viewportNodes; let i = index; trackBy: trackNode"
          [node]="node"
          [index]="i"
          [templates]="templates"
        >
        </tree-node>
      </div>
    </ng-container>
  `
            }] }
];
TreeNodeCollectionComponent.propDecorators = {
    nodes: [{ type: Input }],
    treeModel: [{ type: Input }],
    templates: [{ type: Input }]
};
__decorate([
    observable,
    __metadata("design:type", Object)
], TreeNodeCollectionComponent.prototype, "_nodes", void 0);
__decorate([
    observable,
    __metadata("design:type", Array)
], TreeNodeCollectionComponent.prototype, "viewportNodes", void 0);
__decorate([
    computed,
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], TreeNodeCollectionComponent.prototype, "marginTop", null);
__decorate([
    action,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], TreeNodeCollectionComponent.prototype, "setNodes", null);
if (false) {
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.treeModel;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype._nodes;
    /**
     * @type {?}
     * @private
     */
    TreeNodeCollectionComponent.prototype.virtualScroll;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.templates;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.viewportNodes;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype._dispose;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLWNvbGxlY3Rpb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNpcmNsb24vYW5ndWxhci10cmVlLWNvbXBvbmVudC8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3RyZWUtbm9kZS1jb2xsZWN0aW9uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLGlCQUFpQixFQUdsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2hDLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRzFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQW1CakQsTUFBTSxPQUFPLDJCQUEyQjtJQWpCeEM7UUErQ0UsYUFBUSxHQUFHLEVBQUUsQ0FBQztJQXFDaEIsQ0FBQzs7OztJQWxFQyxJQUNJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQzs7Ozs7SUFDRCxJQUFJLEtBQUssQ0FBQyxLQUFLO1FBQ2IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDOzs7O0lBVVMsSUFBSSxTQUFTOztjQUNmLFNBQVMsR0FDYixJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDOztjQUNwRSxnQkFBZ0IsR0FDcEIsU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNO1lBQzNCLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUTtnQkFDbEIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRO2dCQUN6QixTQUFTLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRTtZQUNsQyxDQUFDLENBQUMsQ0FBQztRQUVQLE9BQU8sR0FBRyxnQkFBZ0IsSUFBSSxDQUFDO0lBQ2pDLENBQUM7Ozs7O0lBSU8sUUFBUSxDQUFDLEtBQUs7UUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDdEIsQ0FBQzs7OztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDO1FBQ2xELElBQUksQ0FBQyxRQUFRLEdBQUc7WUFDZCxzREFBc0Q7WUFDdEQsUUFBUTs7O1lBQ04sR0FBRyxFQUFFO2dCQUNILE9BQU8sSUFBSSxDQUFDLGFBQWE7cUJBQ3RCLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7cUJBQzVCLEdBQUc7Ozs7Z0JBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFDLENBQUM7WUFDdkIsQ0FBQzs7OztZQUNELFdBQVcsQ0FBQyxFQUFFO2dCQUNaLElBQUksQ0FBQyxhQUFhLEdBQUcsV0FBVyxDQUFDLEdBQUc7Ozs7Z0JBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUM7WUFDM0QsQ0FBQyxHQUNELG1CQUFBLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQUUsRUFBTyxDQUMxRDtZQUNELFFBQVE7OztZQUNOLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLOzs7O1lBQ2hCLEtBQUssQ0FBQyxFQUFFO2dCQUNOLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsRSxDQUFDLEVBQ0Y7U0FDRixDQUFDO0lBQ0osQ0FBQzs7OztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU87Ozs7UUFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFDLENBQUM7SUFDbEMsQ0FBQzs7Ozs7O0lBRUQsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJO1FBQ25CLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUNqQixDQUFDOzs7WUFuRkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxzQkFBc0I7Z0JBQ2hDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7OztHQVlUO2FBQ0Y7OztvQkFFRSxLQUFLO3dCQVFMLEtBQUs7d0JBSUwsS0FBSzs7QUFGTTtJQUFYLFVBQVU7OzJEQUFRO0FBSVA7SUFBWCxVQUFVOztrRUFBMkI7QUFFNUI7SUFBVCxRQUFROzs7NERBV1I7QUFJTztJQUFQLE1BQU07Ozs7MkRBRU47OztJQXpCRCxnREFBOEI7O0lBRTlCLDZDQUFtQjs7Ozs7SUFDbkIsb0RBQXlDOztJQUN6QyxnREFBbUI7O0lBRW5CLG9EQUFzQzs7SUFldEMsK0NBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBWaWV3RW5jYXBzdWxhdGlvbixcclxuICBPbkluaXQsXHJcbiAgT25EZXN0cm95XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IHJlYWN0aW9uIH0gZnJvbSAnbW9ieCc7XHJcbmltcG9ydCB7IG9ic2VydmFibGUsIGNvbXB1dGVkLCBhY3Rpb24gfSBmcm9tICcuLi9tb2J4LWFuZ3VsYXIvbW9ieC1wcm94eSc7XHJcbmltcG9ydCB7IFRyZWVWaXJ0dWFsU2Nyb2xsIH0gZnJvbSAnLi4vbW9kZWxzL3RyZWUtdmlydHVhbC1zY3JvbGwubW9kZWwnO1xyXG5pbXBvcnQgeyBUcmVlTm9kZSB9IGZyb20gJy4uL21vZGVscy90cmVlLW5vZGUubW9kZWwnO1xyXG5pbXBvcnQgeyBUcmVlTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvdHJlZS5tb2RlbCc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3RyZWUtbm9kZS1jb2xsZWN0aW9uJyxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8bmctY29udGFpbmVyICp0cmVlTW9ieEF1dG9ydW49XCJ7IGRvbnREZXRhY2g6IHRydWUgfVwiPlxyXG4gICAgICA8ZGl2IFtzdHlsZS5tYXJnaW4tdG9wXT1cIm1hcmdpblRvcFwiPlxyXG4gICAgICAgIDx0cmVlLW5vZGVcclxuICAgICAgICAgICpuZ0Zvcj1cImxldCBub2RlIG9mIHZpZXdwb3J0Tm9kZXM7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrTm9kZVwiXHJcbiAgICAgICAgICBbbm9kZV09XCJub2RlXCJcclxuICAgICAgICAgIFtpbmRleF09XCJpXCJcclxuICAgICAgICAgIFt0ZW1wbGF0ZXNdPVwidGVtcGxhdGVzXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgPC90cmVlLW5vZGU+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVHJlZU5vZGVDb2xsZWN0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IG5vZGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX25vZGVzO1xyXG4gIH1cclxuICBzZXQgbm9kZXMobm9kZXMpIHtcclxuICAgIHRoaXMuc2V0Tm9kZXMobm9kZXMpO1xyXG4gIH1cclxuXHJcbiAgQElucHV0KCkgdHJlZU1vZGVsOiBUcmVlTW9kZWw7XHJcblxyXG4gIEBvYnNlcnZhYmxlIF9ub2RlcztcclxuICBwcml2YXRlIHZpcnR1YWxTY3JvbGw6IFRyZWVWaXJ0dWFsU2Nyb2xsOyAvLyBDYW5ub3QgaW5qZWN0IHRoaXMsIGJlY2F1c2Ugd2UgbWlnaHQgYmUgaW5zaWRlIHRyZWVOb2RlVGVtcGxhdGVGdWxsXHJcbiAgQElucHV0KCkgdGVtcGxhdGVzO1xyXG5cclxuICBAb2JzZXJ2YWJsZSB2aWV3cG9ydE5vZGVzOiBUcmVlTm9kZVtdO1xyXG5cclxuICBAY29tcHV0ZWQgZ2V0IG1hcmdpblRvcCgpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgZmlyc3ROb2RlID1cclxuICAgICAgdGhpcy52aWV3cG9ydE5vZGVzICYmIHRoaXMudmlld3BvcnROb2Rlcy5sZW5ndGggJiYgdGhpcy52aWV3cG9ydE5vZGVzWzBdO1xyXG4gICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9XHJcbiAgICAgIGZpcnN0Tm9kZSAmJiBmaXJzdE5vZGUucGFyZW50XHJcbiAgICAgICAgPyBmaXJzdE5vZGUucG9zaXRpb24gLVxyXG4gICAgICAgICAgZmlyc3ROb2RlLnBhcmVudC5wb3NpdGlvbiAtXHJcbiAgICAgICAgICBmaXJzdE5vZGUucGFyZW50LmdldFNlbGZIZWlnaHQoKVxyXG4gICAgICAgIDogMDtcclxuXHJcbiAgICByZXR1cm4gYCR7cmVsYXRpdmVQb3NpdGlvbn1weGA7XHJcbiAgfVxyXG5cclxuICBfZGlzcG9zZSA9IFtdO1xyXG5cclxuICBAYWN0aW9uIHNldE5vZGVzKG5vZGVzKSB7XHJcbiAgICB0aGlzLl9ub2RlcyA9IG5vZGVzO1xyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICB0aGlzLnZpcnR1YWxTY3JvbGwgPSB0aGlzLnRyZWVNb2RlbC52aXJ0dWFsU2Nyb2xsO1xyXG4gICAgdGhpcy5fZGlzcG9zZSA9IFtcclxuICAgICAgLy8gcmV0dXJuIG5vZGUgaW5kZXhlcyBzbyB3ZSBjYW4gY29tcGFyZSBzdHJ1Y3R1cmFsbHksXHJcbiAgICAgIHJlYWN0aW9uKFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnZpcnR1YWxTY3JvbGxcclxuICAgICAgICAgICAgLmdldFZpZXdwb3J0Tm9kZXModGhpcy5ub2RlcylcclxuICAgICAgICAgICAgLm1hcChuID0+IG4uaW5kZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9kZUluZGV4ZXMgPT4ge1xyXG4gICAgICAgICAgdGhpcy52aWV3cG9ydE5vZGVzID0gbm9kZUluZGV4ZXMubWFwKGkgPT4gdGhpcy5ub2Rlc1tpXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IGNvbXBhcmVTdHJ1Y3R1cmFsOiB0cnVlLCBmaXJlSW1tZWRpYXRlbHk6IHRydWUgfSBhcyBhbnlcclxuICAgICAgKSxcclxuICAgICAgcmVhY3Rpb24oXHJcbiAgICAgICAgKCkgPT4gdGhpcy5ub2RlcyxcclxuICAgICAgICBub2RlcyA9PiB7XHJcbiAgICAgICAgICB0aGlzLnZpZXdwb3J0Tm9kZXMgPSB0aGlzLnZpcnR1YWxTY3JvbGwuZ2V0Vmlld3BvcnROb2Rlcyhub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICApXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9kaXNwb3NlLmZvckVhY2goZCA9PiBkKCkpO1xyXG4gIH1cclxuXHJcbiAgdHJhY2tOb2RlKGluZGV4LCBub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5pZDtcclxuICB9XHJcbn1cclxuIl19