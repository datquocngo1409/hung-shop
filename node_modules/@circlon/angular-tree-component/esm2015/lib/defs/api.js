/**
 * @fileoverview added by tsickle
 * Generated from: lib/defs/api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
export function IAllowDropFn() { }
/**
 * @record
 */
export function INodeHeightFn() { }
/**
 * @record
 */
export function IAllowDragFn() { }
/**
 * @record
 */
export function ITreeState() { }
if (false) {
    /** @type {?|undefined} */
    ITreeState.prototype.expandedNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.selectedNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.activeNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.hiddenNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.selectedLeafNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.focusedNodeId;
}
/**
 * @record
 */
export function ITreeOptions() { }
if (false) {
    /**
     * A string representing the attribute of the node that indicates whether there are child nodes.
     * **Default value: `hasChildren`.**
     * For example, if your nodes have an `isDirectory` attribute that indicates whether there are children, use:
     * ```
     * options = { hasChildrenField: 'isDirectory' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.hasChildrenField;
    /**
     * A string representing the attribute of the node that contains the array of children.
     * **Default value: `children`.**
     * For example, if your nodes have a `nodes` attribute, that contains the children, use:
     * ```
     * options = { childrenField: 'nodes' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.childrenField;
    /**
     * A string representing the attribute of the node to display.
     * **Default value: `name`**
     * For example, if your nodes have a `title` attribute that should be displayed, use:
     * ```
     * options = { displayField: 'title' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.displayField;
    /**
     * A string representing the attribute of the node that contains the unique ID.
     * This will be used to construct the `path`, which is an array of IDs that point to the node.
     * **Default value: `id`.**
     * For example, if your nodes have a `uuid` attribute, that contains the unique key, use:
     * ```
     * options = { idField: 'uuid' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.idField;
    /**
     * A string representing the attribute of the node that contains whether the node starts as expanded.
     * **Default value: `isExpanded`.**
     * For example, if your nodes have an `expanded` attribute, that contains a boolean value, use:
     * ```
     * options = { isExpandedField: 'expanded' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.isExpandedField;
    /**
     * Function for loading a node's children.
     * The function receives a TreeNode, and returns a value or a promise that resolves to the node's children.
     * This function will be called whenever a node is expanded, the `hasChildren` (`options.hasChildrenField`)
     * field is true, and the `children` field is empty.
     * The result will be loaded into the node's children attribute.
     * Example:
     * ```
     * options = {
     *   getChildren: (node:TreeNode) => {
     *     return request('/api/children/' + node.id);
     *   }
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.getChildren;
    /**
     * Rewire which trigger causes which action using this attribute, or create custom actions / event bindings.
     * See the [Action Mapping Section](https://angular2-tree.readme.io/docs/action-mapping) for more details.
     * @type {?|undefined}
     */
    ITreeOptions.prototype.actionMapping;
    /**
     * Specify if dragging tree nodes is allowed.
     * This could be a boolean, or a function that receives a TreeNode and returns a boolean
     * **Default value: false**
     * Example:
     * ```
     * options = {
     *  allowDrag: true
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.allowDrag;
    /**
     * Specify whether dropping inside the tree is allowed. Optional types:
     *  - boolean
     *  - (element:any, to:{parent:TreeNode, index:number}):boolean
     * A function that receives the dragged element, and the drop location (parent node and index inside the parent),
     * and returns true or false.
     * **Default Value: true**
     * example:
     * ```
     * options = {
     *  allowDrop: (element, {parent, index}) => parent.isLeaf
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.allowDrop;
    /**
     * Boolean flag to allow adding and removing is-dragging-over and is-dragging-over-disabled classes.
     * If set to false it will not add the above mentioned classes and you should handle the styling yourself with css and in
     * the actionMapping -> mouse -> dragEnter, dragLeave
     * **Default Value: true**
     * example:
     * ```
     * options = {
     *   allowDrop: true,
     *   allowDragoverStyling: false
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.allowDragoverStyling;
    /**
     * Specify padding per node (integer).
     * Each node will have padding-left value of level * levelPadding, instead of using the default padding for children.
     * This option is good for example for allowing whole row selection, etc.
     * You can alternatively use the tree-node-level-X classes to give padding on a per-level basis.
     * **Default value: 0**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.levelPadding;
    /**
     * Specify a function that returns a class per node. Useful for styling the nodes individually.
     * Example:
     * ```
     * options = {
     *   nodeClass: (node:TreeNode) => {
     *     return 'icon-' + node.data.icon;
     *   }
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.nodeClass;
    /**
     * Boolean flag to use the virtual scroll option.
     * To use this option, you must supply the height of the container, and the height of each node in the tree.
     * You can also specify height for the dropSlot which is located between nodes.
     * **Default Value: false**
     * example:
     * ```
     * options = {
     *   useVirtualScroll: true,
     *   nodeHeight: (node: TreeNode) => node.myHeight,
     *   dropSlotHeight: 3
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.useVirtualScroll;
    /**
     * For use with `useVirtualScroll` option.
     * Specify a height for nodes in pixels. Could be either:
     * - number
     * - (node: TreeNode) => number
     * **Default Value: 22**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.nodeHeight;
    /**
     * For use with `useVirtualScroll` option.
     * Specify a height for drop slots (located between nodes) in pixels
     * **Default Value: 2**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.dropSlotHeight;
    /**
     * Boolean whether or not to animate expand / collapse of nodes.
     * **Default Value: false**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.animateExpand;
    /**
     * Speed of expand animation (described in pixels per 17 ms).
     * **Default Value: 30**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.animateSpeed;
    /**
     * Increase of expand animation speed (described in multiply per 17 ms).
     * **Default Value: 1.2**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.animateAcceleration;
    /**
     * Whether to scroll to the node to make it visible when it is activated.
     * **Default Value: true**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.scrollOnActivate;
    /**
     * Function to clone a node.
     * Receives a TreeNode object, and returns a node object (only the data).
     * This callback will be called when copying a node inside the tree,
     * by either calling copyNode, or by dragging and holding the ctrl key
     *
     * For example:
     * ```
     * options: ITreeOptions = {
     * getNodeClone: (node) => ({
     * ...node.data,
     * id: uuid.v4(),
     * name: `copy of ${node.data.name}`
     * })
     * };
     * ```
     *
     * **Default Value: clone the node using Object.assign, and remove 'id' property**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.getNodeClone;
    /**
     * Makes the tree right-to-left.
     * This include direction, expander style, and change key binding (right key collapse and left key expands instead of vice-versa)
     * @type {?|undefined}
     */
    ITreeOptions.prototype.rtl;
    /**
     * Specifies id of root node (virtualRoot)
     * @type {?|undefined}
     */
    ITreeOptions.prototype.rootId;
    /**
     * Whether to display a checkbox next to the node or not
     * @type {?|undefined}
     */
    ITreeOptions.prototype.useCheckbox;
    /**
     * Whether to use master checkboxes mechanism if the useCheckbox is set to true
     * @type {?|undefined}
     */
    ITreeOptions.prototype.useTriState;
    /**
     * The HTML element that is the scroll container for the tree.
     * The default behaviour is to wrap the tree with a container that has overflow: hidden,
     * and then the scrolling container is the viewport inside the tree component
     * @type {?|undefined}
     */
    ITreeOptions.prototype.scrollContainer;
}
/**
 * @record
 */
export function ITreeNode() { }
if (false) {
    /**
     * Parent node
     * @type {?}
     */
    ITreeNode.prototype.parent;
    /**
     * The value of the node's field that is used for displaying its content.
     * By default 'name', unless stated otherwise in the options
     * @type {?}
     */
    ITreeNode.prototype.displayField;
    /**
     * The children of the node.
     * By default is determined by 'node.data.children', unless stated otherwise in the options
     * @type {?}
     */
    ITreeNode.prototype.children;
    /**
     * Pointer to the original data.
     * @type {?}
     */
    ITreeNode.prototype.data;
    /**
     * Pointer to the ElementRef of the TreeNodeComponent that's displaying this node
     * @type {?}
     */
    ITreeNode.prototype.elementRef;
    /**
     * Level in the tree (starts from 1).
     * @type {?}
     */
    ITreeNode.prototype.level;
    /**
     * Path in the tree: Array of IDs.
     * @type {?}
     */
    ITreeNode.prototype.path;
    /**
     * index of the node inside its parent's children
     * @type {?}
     */
    ITreeNode.prototype.index;
    /**
     * A unique key of this node among its siblings.
     * By default it's the 'id' of the original node, unless stated otherwise in options.idField
     * @type {?}
     */
    ITreeNode.prototype.id;
    /** @type {?} */
    ITreeNode.prototype.isExpanded;
    /** @type {?} */
    ITreeNode.prototype.isActive;
    /** @type {?} */
    ITreeNode.prototype.isFocused;
    /** @type {?} */
    ITreeNode.prototype.isCollapsed;
    /** @type {?} */
    ITreeNode.prototype.isLeaf;
    /** @type {?} */
    ITreeNode.prototype.hasChildren;
    /** @type {?} */
    ITreeNode.prototype.isRoot;
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} next sibling (or null)
     */
    ITreeNode.prototype.findNextSibling = function (skipHidden) { };
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} previous sibling (or null)
     */
    ITreeNode.prototype.findPreviousSibling = function (skipHidden) { };
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} first child (or null)
     */
    ITreeNode.prototype.getFirstChild = function (skipHidden) { };
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} last child (or null)
     */
    ITreeNode.prototype.getLastChild = function (skipHidden) { };
    /**
     * Finds the visually next node in the tree.
     * @param {?} goInside whether to look for children or just siblings
     * @return {?} next node.
     */
    ITreeNode.prototype.findNextNode = function (goInside) { };
    /**
     * Finds the visually previous node in the tree.
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} previous node.
     */
    ITreeNode.prototype.findPreviousNode = function (skipHidden) { };
    /**
     * @param {?} node
     * @return {?} true if this node is a descendant of the parameter node
     */
    ITreeNode.prototype.isDescendantOf = function (node) { };
    /**
     * @return {?} in case levelPadding option is supplied, returns the current node's padding
     */
    ITreeNode.prototype.getNodePadding = function () { };
    /**
     * @return {?} in case nodeClass option is supplied, returns the current node's class
     */
    ITreeNode.prototype.getClass = function () { };
    /**
     * Expands / Collapses the node
     * @return {?}
     */
    ITreeNode.prototype.toggleExpanded = function () { };
    /**
     * Expands the node
     * @return {?}
     */
    ITreeNode.prototype.expand = function () { };
    /**
     * Collapses the node
     * @return {?}
     */
    ITreeNode.prototype.collapse = function () { };
    /**
     * Expands all ancestors of the node
     * @return {?}
     */
    ITreeNode.prototype.ensureVisible = function () { };
    /**
     * Activates / Deactivates the node (selects / deselects)
     * @param {?} multi
     * @return {?}
     */
    ITreeNode.prototype.toggleActivated = function (multi) { };
    /**
     * Focus on the node
     * @return {?}
     */
    ITreeNode.prototype.focus = function () { };
    /**
     * Blur (unfocus) the node
     * @return {?}
     */
    ITreeNode.prototype.blur = function () { };
    /**
     * Hides the node
     * @return {?}
     */
    ITreeNode.prototype.hide = function () { };
    /**
     * Makes the node visible
     * @return {?}
     */
    ITreeNode.prototype.show = function () { };
    /**
     * @param {?} value  if true makes the node hidden, otherwise visible
     * @return {?}
     */
    ITreeNode.prototype.setIsHidden = function (value) { };
    /**
     * Scroll the screen to make the node visible
     * @return {?}
     */
    ITreeNode.prototype.scrollIntoView = function () { };
    /**
     * Fire an event to the renderer of the tree (if it was registered)
     * @param {?} event
     * @return {?}
     */
    ITreeNode.prototype.fireEvent = function (event) { };
    /**
     * Invokes a method for every node under this one - depth first
     * @param {?} fn  a function that receives the node
     * @return {?}
     */
    ITreeNode.prototype.doForAll = function (fn) { };
    /**
     * expand all nodes under this one
     * @return {?}
     */
    ITreeNode.prototype.expandAll = function () { };
    /**
     * collapse all nodes under this one
     * @return {?}
     */
    ITreeNode.prototype.collapseAll = function () { };
    /**
     * sets the node to active / inactive according to the value.
     * If multi is true (default false) - does a multiselect.
     * @param {?} value
     * @param {?=} multi
     * @return {?}
     */
    ITreeNode.prototype.setIsActive = function (value, multi) { };
    /**
     * sets the node to be active and makes sure it's visible by expanding all nodes above it and scrolling it into view.
     * Very similar to calling `activate`, `ensureVisible` and `scrollIntoView` methods.
     * If multi is true (default false) - does a multiselect.
     * @param {?} multi
     * @return {?}
     */
    ITreeNode.prototype.setActiveAndVisible = function (multi) { };
}
/**
 * @record
 */
export function ITreeModel() { }
if (false) {
    /**
     * All root nodes
     * @type {?}
     */
    ITreeModel.prototype.roots;
    /**
     * Current focused node
     * @type {?}
     */
    ITreeModel.prototype.focusedNode;
    /**
     * Options that were passed to the tree component
     * @type {?}
     */
    ITreeModel.prototype.options;
    /**
     * Is the tree currently focused
     * @type {?}
     */
    ITreeModel.prototype.isFocused;
    /**
     * \@return Current active nodes
     * @type {?}
     */
    ITreeModel.prototype.activeNodes;
    /**
     * \@return Current expanded nodes
     * @type {?}
     */
    ITreeModel.prototype.expandedNodes;
    /**
     * @return {?} Current active node. If multiple nodes are active - returns the first one.
     */
    ITreeModel.prototype.getActiveNode = function () { };
    /**
     * @return {?} Current focused node (either hovered or traversed with keys)
     */
    ITreeModel.prototype.getFocusedNode = function () { };
    /**
     * Set focus on a node
     * @param {?} node
     * @return {?}
     */
    ITreeModel.prototype.setFocusedNode = function (node) { };
    /**
     * @param {?=} skipHidden  true or false - whether to skip hidden nodes
     * @return {?} first root of the tree
     */
    ITreeModel.prototype.getFirstRoot = function (skipHidden) { };
    /**
     * @param {?=} skipHidden  true or false - whether to skip hidden nodes
     * @return {?} last root of the tree
     */
    ITreeModel.prototype.getLastRoot = function (skipHidden) { };
    /**
     * @return {?} true if the tree is empty
     */
    ITreeModel.prototype.isEmptyTree = function () { };
    /**
     * @return {?} All root nodes that pass the current filter
     */
    ITreeModel.prototype.getVisibleRoots = function () { };
    /**
     * @param {?} path  array of node IDs to be traversed respectively
     * @param {?=} startNode
     * @return {?} The node, if found - null otherwise
     */
    ITreeModel.prototype.getNodeByPath = function (path, startNode) { };
    /**
     * @param {?} id  node ID to find
     * @return {?} The node, if found - null otherwise
     */
    ITreeModel.prototype.getNodeById = function (id) { };
    /**
     * @param {?} predicate - either an object or a function, used as a test condition on all nodes.
     *            Could be every predicate that's supported by lodash's `find` method
     * @param {?=} startNode
     * @return {?} First node that matches the predicate, if found - null otherwise
     */
    ITreeModel.prototype.getNodeBy = function (predicate, startNode) { };
    /**
     * get tree state
     * @return {?}
     */
    ITreeModel.prototype.getState = function () { };
    /**
     * Focuses or blurs the tree
     * @param {?} value  true or false - whether to set focus or blur.
     * @return {?}
     */
    ITreeModel.prototype.setFocus = function (value) { };
    /**
     * Focuses on the next node in the tree (same as down arrow)
     * @return {?}
     */
    ITreeModel.prototype.focusNextNode = function () { };
    /**
     * Focuses on the previous node in the tree (same as up arrow)
     * @return {?}
     */
    ITreeModel.prototype.focusPreviousNode = function () { };
    /**
     * Focuses on the inner child of the current focused node (same as right arrow on an expanded node)
     * @return {?}
     */
    ITreeModel.prototype.focusDrillDown = function () { };
    /**
     * Focuses on the parent of the current focused node (same as left arrow on a collapsed node)
     * @return {?}
     */
    ITreeModel.prototype.focusDrillUp = function () { };
    /**
     * Marks isHidden field in all nodes recursively according to the filter param.
     * If a node is marked visible, all of its ancestors will be marked visible as well.
     * @param {?} filter  either a string or a function.
     *   In case it's a string, it will be searched case insensitively in the node's display attribute
     *   In case it's a function, it will be passed the node, and should return true if the node should be visible, false otherwise
     * @param {?=} autoShow  if true, make sure all nodes that passed the filter are visible
     * @return {?}
     */
    ITreeModel.prototype.filterNodes = function (filter, autoShow) { };
    /**
     * Marks all nodes isHidden = false
     * @return {?}
     */
    ITreeModel.prototype.clearFilter = function () { };
    /**
     * moves a node from one location in the tree to another
     * @param {?} node describes which node needs to be moved
     * @param {?} to describes where to move the node to.
     * @param {?} from describes where to move the node from.
     * Contains a 'parent' node, an 'index', and a 'dropOnNode' - to distinguish between dropping between nodes or on the node
     * @return {?}
     */
    ITreeModel.prototype.moveNode = function (node, to, from) { };
    /**
     * Invokes a method for every node of the tree - depth first
     * @param {?} fn  a function that receives the node
     * @return {?}
     */
    ITreeModel.prototype.doForAll = function (fn) { };
    /**
     * expand all nodes
     * @return {?}
     */
    ITreeModel.prototype.expandAll = function () { };
    /**
     * collapse all nodes
     * @return {?}
     */
    ITreeModel.prototype.collapseAll = function () { };
    /**
     * set tree state
     * @param {?} state
     * @return {?}
     */
    ITreeModel.prototype.setState = function (state) { };
    /**
     * @param {?} fn
     * @return {?}
     */
    ITreeModel.prototype.subscribeToState = function (fn) { };
}
/**
 * This is the interface of the TreeNodeDrag service
 * @record
 */
export function ITreeNodeDrag() { }
if (false) {
    /**
     * Gets the current dragged node. Useful for overriding the drop action.
     * @return {?}
     */
    ITreeNodeDrag.prototype.getDragNode = function () { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNpcmNsb24vYW5ndWxhci10cmVlLWNvbXBvbmVudC8iLCJzb3VyY2VzIjpbImxpYi9kZWZzL2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQVdBLGtDQUVDOzs7O0FBRUQsbUNBRUM7Ozs7QUFFRCxrQ0FFQzs7OztBQUdELGdDQU9DOzs7SUFOQyxxQ0FBbUM7O0lBQ25DLHFDQUFtQzs7SUFDbkMsbUNBQWlDOztJQUNqQyxtQ0FBaUM7O0lBQ2pDLHlDQUF1Qzs7SUFDdkMsbUNBQXVCOzs7OztBQUd6QixrQ0E4UEU7Ozs7Ozs7Ozs7O0lBblBDLHdDQUEwQjs7Ozs7Ozs7OztJQVcxQixxQ0FBdUI7Ozs7Ozs7Ozs7SUFXdkIsb0NBQXNCOzs7Ozs7Ozs7OztJQVl0QiwrQkFBaUI7Ozs7Ozs7Ozs7SUFXakIsdUNBQXlCOzs7Ozs7Ozs7Ozs7Ozs7OztJQWtCekIsbUNBQXNDOzs7Ozs7SUFLdEMscUNBQW9COzs7Ozs7Ozs7Ozs7O0lBY3BCLGlDQUFtQzs7Ozs7Ozs7Ozs7Ozs7OztJQWlCbkMsaUNBQW1DOzs7Ozs7Ozs7Ozs7Ozs7SUFpQm5DLDRDQUErQjs7Ozs7Ozs7O0lBVy9CLG9DQUFzQjs7Ozs7Ozs7Ozs7OztJQWF0QixpQ0FBdUM7Ozs7Ozs7Ozs7Ozs7Ozs7SUFtQnZDLHdDQUEyQjs7Ozs7Ozs7O0lBUzNCLGtDQUFvQzs7Ozs7OztJQU9wQyxzQ0FBd0I7Ozs7OztJQU14QixxQ0FBd0I7Ozs7OztJQU14QixvQ0FBc0I7Ozs7OztJQU10QiwyQ0FBNkI7Ozs7OztJQU03Qix3Q0FBMkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9CMUIsb0NBQXVDOzs7Ozs7SUFLdkMsMkJBQWM7Ozs7O0lBSWQsOEJBQWE7Ozs7O0lBSWIsbUNBQXNCOzs7OztJQUl0QixtQ0FBc0I7Ozs7Ozs7SUFNdEIsdUNBQThCOzs7OztBQUdsQywrQkE2S0M7Ozs7OztJQXhLQywyQkFBa0I7Ozs7OztJQUtsQixpQ0FBcUI7Ozs7OztJQUtyQiw2QkFBc0I7Ozs7O0lBSXRCLHlCQUFVOzs7OztJQUlWLCtCQUFnQjs7Ozs7SUFJaEIsMEJBQWM7Ozs7O0lBSWQseUJBQWU7Ozs7O0lBSWYsMEJBQWM7Ozs7OztJQUtkLHVCQUFXOztJQUdYLCtCQUFvQjs7SUFDcEIsNkJBQWtCOztJQUNsQiw4QkFBbUI7O0lBQ25CLGdDQUFxQjs7SUFDckIsMkJBQWdCOztJQUNoQixnQ0FBcUI7O0lBQ3JCLDJCQUFnQjs7Ozs7SUFPaEIsZ0VBQXVDOzs7OztJQUt2QyxvRUFBMkM7Ozs7O0lBSzNDLDhEQUFxQzs7Ozs7SUFLckMsNkRBQW9DOzs7Ozs7SUFNcEMsMkRBQTJDOzs7Ozs7SUFNM0MsaUVBQXdDOzs7OztJQUt4Qyx5REFBeUM7Ozs7SUFLekMscURBQXlCOzs7O0lBS3pCLCtDQUFtQjs7Ozs7SUFNbkIscURBQWlCOzs7OztJQUlqQiw2Q0FBUzs7Ozs7SUFJVCwrQ0FBVzs7Ozs7SUFJWCxvREFBZ0I7Ozs7OztJQUloQiwyREFBdUI7Ozs7O0lBSXZCLDRDQUFROzs7OztJQUlSLDJDQUFPOzs7OztJQUlQLDJDQUFPOzs7OztJQUlQLDJDQUFPOzs7OztJQUlQLHVEQUE0Qjs7Ozs7SUFJNUIscURBQWlCOzs7Ozs7SUFJakIscURBQXNCOzs7Ozs7SUFLdEIsaURBQXVDOzs7OztJQUl2QyxnREFBWTs7Ozs7SUFJWixrREFBYzs7Ozs7Ozs7SUFLZCw4REFBNkM7Ozs7Ozs7O0lBTTdDLCtEQUFvQzs7Ozs7QUFHdEMsZ0NBaUpDOzs7Ozs7SUE1SUMsMkJBQW1COzs7OztJQUluQixpQ0FBdUI7Ozs7O0lBSXZCLDZCQUFzQjs7Ozs7SUFLdEIsK0JBQW1COzs7OztJQUluQixpQ0FBeUI7Ozs7O0lBSXpCLG1DQUEyQjs7OztJQU0zQixxREFBMkI7Ozs7SUFJM0Isc0RBQTRCOzs7Ozs7SUFLNUIsMERBQWdDOzs7OztJQUtoQyw4REFBOEM7Ozs7O0lBSzlDLDZEQUE2Qzs7OztJQUk3QyxtREFBdUI7Ozs7SUFJdkIsdURBQStCOzs7Ozs7SUFNL0Isb0VBQTZEOzs7OztJQUs3RCxxREFBbUM7Ozs7Ozs7SUFPbkMscUVBQTREOzs7OztJQUk1RCxnREFBdUI7Ozs7OztJQU92QixxREFBeUI7Ozs7O0lBSXpCLHFEQUFnQjs7Ozs7SUFJaEIseURBQW9COzs7OztJQUlwQixzREFBaUI7Ozs7O0lBSWpCLG9EQUFlOzs7Ozs7Ozs7O0lBU2YsbUVBQXdDOzs7OztJQUl4QyxtREFBYzs7Ozs7Ozs7O0lBUWQsOERBQWlJOzs7Ozs7SUFLakksa0RBQXVDOzs7OztJQUl2QyxpREFBWTs7Ozs7SUFJWixtREFBYzs7Ozs7O0lBSWQscURBQTRCOzs7OztJQUU1QiwwREFBaUQ7Ozs7OztBQUtuRCxtQ0FPQzs7Ozs7O0lBREMsc0RBQWlEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFdlbGNvbWUgdG8gbmcydHJlZVxyXG4gKi9cclxuZXhwb3J0IHR5cGUgSURUeXBlID0gc3RyaW5nIHwgbnVtYmVyO1xyXG5leHBvcnQgdHlwZSBJRFR5cGVEaWN0aW9uYXJ5ID0geyBbaWQ6IHN0cmluZ106IGJvb2xlYW4sIFtpZDogbnVtYmVyXTogYm9vbGVhbiB9O1xyXG5cclxuLyoqXHJcbiAqIFNlZSBJVHJlZU5vZGUgZm9yIGRvY3VtZW50YXRpb25cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIHR5cGUgVHJlZU5vZGUgPSBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBbGxvd0Ryb3BGbiB7XHJcbiAgKGVsZW1lbnQ6IGFueSwgdG86IHtwYXJlbnQ6IFRyZWVOb2RlLCBpbmRleDogbnVtYmVyfSwgJGV2ZW50PzogYW55KTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJTm9kZUhlaWdodEZuIHtcclxuICAobm9kZTogVHJlZU5vZGUpOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFsbG93RHJhZ0ZuIHtcclxuICAobm9kZTogVHJlZU5vZGUpOiBib29sZWFuO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJVHJlZVN0YXRlIHtcclxuICBleHBhbmRlZE5vZGVJZHM/OiBJRFR5cGVEaWN0aW9uYXJ5O1xyXG4gIHNlbGVjdGVkTm9kZUlkcz86IElEVHlwZURpY3Rpb25hcnk7XHJcbiAgYWN0aXZlTm9kZUlkcz86IElEVHlwZURpY3Rpb25hcnk7XHJcbiAgaGlkZGVuTm9kZUlkcz86IElEVHlwZURpY3Rpb25hcnk7XHJcbiAgc2VsZWN0ZWRMZWFmTm9kZUlkcz86IElEVHlwZURpY3Rpb25hcnk7XHJcbiAgZm9jdXNlZE5vZGVJZD86IElEVHlwZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJVHJlZU9wdGlvbnMge1xyXG4gICAvKipcclxuICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGUgb2YgdGhlIG5vZGUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBhcmUgY2hpbGQgbm9kZXMuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgdmFsdWU6IGBoYXNDaGlsZHJlbmAuKipcclxuXHJcbiAgICBGb3IgZXhhbXBsZSwgaWYgeW91ciBub2RlcyBoYXZlIGFuIGBpc0RpcmVjdG9yeWAgYXR0cmlidXRlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgYXJlIGNoaWxkcmVuLCB1c2U6XHJcbiAgICBgYGBcclxuICAgICAgb3B0aW9ucyA9IHsgaGFzQ2hpbGRyZW5GaWVsZDogJ2lzRGlyZWN0b3J5JyB9XHJcbiAgICBgYGBcclxuICAgICovXHJcbiAgIGhhc0NoaWxkcmVuRmllbGQ/OiBzdHJpbmc7XHJcbiAgIC8qKlxyXG4gICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBhcnJheSBvZiBjaGlsZHJlbi5cclxuXHJcbiAgICAqICoqRGVmYXVsdCB2YWx1ZTogYGNoaWxkcmVuYC4qKlxyXG5cclxuICAgIEZvciBleGFtcGxlLCBpZiB5b3VyIG5vZGVzIGhhdmUgYSBgbm9kZXNgIGF0dHJpYnV0ZSwgdGhhdCBjb250YWlucyB0aGUgY2hpbGRyZW4sIHVzZTpcclxuICAgIGBgYFxyXG4gICAgICBvcHRpb25zID0geyBjaGlsZHJlbkZpZWxkOiAnbm9kZXMnIH1cclxuICAgIGBgYFxyXG4gICAgKi9cclxuICAgY2hpbGRyZW5GaWVsZD86IHN0cmluZztcclxuICAgLyoqXHJcbiAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlIG9mIHRoZSBub2RlIHRvIGRpc3BsYXkuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgdmFsdWU6IGBuYW1lYCoqXHJcblxyXG4gICAgICBGb3IgZXhhbXBsZSwgaWYgeW91ciBub2RlcyBoYXZlIGEgYHRpdGxlYCBhdHRyaWJ1dGUgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkLCB1c2U6XHJcbiAgICAgIGBgYFxyXG4gICAgICAgIG9wdGlvbnMgPSB7IGRpc3BsYXlGaWVsZDogJ3RpdGxlJyB9XHJcbiAgICAgIGBgYFxyXG4gICAgKi9cclxuICAgZGlzcGxheUZpZWxkPzogc3RyaW5nO1xyXG4gICAvKipcclxuICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGUgb2YgdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgdW5pcXVlIElELlxyXG4gICAgICBUaGlzIHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGBwYXRoYCwgd2hpY2ggaXMgYW4gYXJyYXkgb2YgSURzIHRoYXQgcG9pbnQgdG8gdGhlIG5vZGUuXHJcblxyXG4gICAgICAqICoqRGVmYXVsdCB2YWx1ZTogYGlkYC4qKlxyXG5cclxuICAgICAgRm9yIGV4YW1wbGUsIGlmIHlvdXIgbm9kZXMgaGF2ZSBhIGB1dWlkYCBhdHRyaWJ1dGUsIHRoYXQgY29udGFpbnMgdGhlIHVuaXF1ZSBrZXksIHVzZTpcclxuICAgICAgYGBgXHJcbiAgICAgICAgb3B0aW9ucyA9IHsgaWRGaWVsZDogJ3V1aWQnIH1cclxuICAgICAgYGBgXHJcbiAgICAqL1xyXG4gICBpZEZpZWxkPzogc3RyaW5nO1xyXG4gICAvKipcclxuICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGUgb2YgdGhlIG5vZGUgdGhhdCBjb250YWlucyB3aGV0aGVyIHRoZSBub2RlIHN0YXJ0cyBhcyBleHBhbmRlZC5cclxuXHJcbiAgICAgICogKipEZWZhdWx0IHZhbHVlOiBgaXNFeHBhbmRlZGAuKipcclxuXHJcbiAgICAgIEZvciBleGFtcGxlLCBpZiB5b3VyIG5vZGVzIGhhdmUgYW4gYGV4cGFuZGVkYCBhdHRyaWJ1dGUsIHRoYXQgY29udGFpbnMgYSBib29sZWFuIHZhbHVlLCB1c2U6XHJcbiAgICAgIGBgYFxyXG4gICAgICAgIG9wdGlvbnMgPSB7IGlzRXhwYW5kZWRGaWVsZDogJ2V4cGFuZGVkJyB9XHJcbiAgICAgIGBgYFxyXG4gICAgKi9cclxuICAgaXNFeHBhbmRlZEZpZWxkPzogc3RyaW5nO1xyXG4gICAvKipcclxuICAgICogRnVuY3Rpb24gZm9yIGxvYWRpbmcgYSBub2RlJ3MgY2hpbGRyZW4uXHJcbiAgICAgIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIFRyZWVOb2RlLCBhbmQgcmV0dXJucyBhIHZhbHVlIG9yIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW4uXHJcblxyXG4gICAgICBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbm9kZSBpcyBleHBhbmRlZCwgdGhlIGBoYXNDaGlsZHJlbmAgKGBvcHRpb25zLmhhc0NoaWxkcmVuRmllbGRgKVxyXG4gICAgICBmaWVsZCBpcyB0cnVlLCBhbmQgdGhlIGBjaGlsZHJlbmAgZmllbGQgaXMgZW1wdHkuXHJcbiAgICAgIFRoZSByZXN1bHQgd2lsbCBiZSBsb2FkZWQgaW50byB0aGUgbm9kZSdzIGNoaWxkcmVuIGF0dHJpYnV0ZS5cclxuXHJcbiAgICAgIEV4YW1wbGU6XHJcbiAgICAgIGBgYFxyXG4gICAgICAqIG9wdGlvbnMgPSB7XHJcbiAgICAgICogICBnZXRDaGlsZHJlbjogKG5vZGU6VHJlZU5vZGUpID0+IHtcclxuICAgICAgKiAgICAgcmV0dXJuIHJlcXVlc3QoJy9hcGkvY2hpbGRyZW4vJyArIG5vZGUuaWQpO1xyXG4gICAgICAqICAgfVxyXG4gICAgICAqIH1cclxuICAgICAgYGBgXHJcbiAgICAqL1xyXG4gICBnZXRDaGlsZHJlbj86IChub2RlOiBUcmVlTm9kZSkgPT4gYW55O1xyXG4gICAvKipcclxuICAgICogUmV3aXJlIHdoaWNoIHRyaWdnZXIgY2F1c2VzIHdoaWNoIGFjdGlvbiB1c2luZyB0aGlzIGF0dHJpYnV0ZSwgb3IgY3JlYXRlIGN1c3RvbSBhY3Rpb25zIC8gZXZlbnQgYmluZGluZ3MuXHJcbiAgICAqIFNlZSB0aGUgW0FjdGlvbiBNYXBwaW5nIFNlY3Rpb25dKGh0dHBzOi8vYW5ndWxhcjItdHJlZS5yZWFkbWUuaW8vZG9jcy9hY3Rpb24tbWFwcGluZykgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICovXHJcbiAgIGFjdGlvbk1hcHBpbmc/OiBhbnk7XHJcbiAgIC8qKlxyXG4gICAgKiBTcGVjaWZ5IGlmIGRyYWdnaW5nIHRyZWUgbm9kZXMgaXMgYWxsb3dlZC5cclxuICAgICogVGhpcyBjb3VsZCBiZSBhIGJvb2xlYW4sIG9yIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIFRyZWVOb2RlIGFuZCByZXR1cm5zIGEgYm9vbGVhblxyXG5cclxuICAgICogKipEZWZhdWx0IHZhbHVlOiBmYWxzZSoqXHJcblxyXG4gICAgRXhhbXBsZTpcclxuICAgIGBgYFxyXG4gICAgKiBvcHRpb25zID0ge1xyXG4gICAgKiAgYWxsb3dEcmFnOiB0cnVlXHJcbiAgICAqIH1cclxuICAgIGBgYFxyXG4gICAgKi9cclxuICAgYWxsb3dEcmFnPzogYm9vbGVhbiB8IElBbGxvd0RyYWdGbjtcclxuICAgLyoqXHJcbiAgICAqIFNwZWNpZnkgd2hldGhlciBkcm9wcGluZyBpbnNpZGUgdGhlIHRyZWUgaXMgYWxsb3dlZC4gT3B0aW9uYWwgdHlwZXM6XHJcbiAgICAqICAtIGJvb2xlYW5cclxuICAgICogIC0gKGVsZW1lbnQ6YW55LCB0bzp7cGFyZW50OlRyZWVOb2RlLCBpbmRleDpudW1iZXJ9KTpib29sZWFuXHJcbiAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgZHJhZ2dlZCBlbGVtZW50LCBhbmQgdGhlIGRyb3AgbG9jYXRpb24gKHBhcmVudCBub2RlIGFuZCBpbmRleCBpbnNpZGUgdGhlIHBhcmVudCksXHJcbiAgICAgICAgIGFuZCByZXR1cm5zIHRydWUgb3IgZmFsc2UuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IHRydWUqKlxyXG5cclxuICAgIGV4YW1wbGU6XHJcbiAgICBgYGBcclxuICAgICogb3B0aW9ucyA9IHtcclxuICAgICogIGFsbG93RHJvcDogKGVsZW1lbnQsIHtwYXJlbnQsIGluZGV4fSkgPT4gcGFyZW50LmlzTGVhZlxyXG4gICAgKiB9XHJcbiAgICBgYGBcclxuICAgKi9cclxuICAgYWxsb3dEcm9wPzogYm9vbGVhbiB8IElBbGxvd0Ryb3BGbjtcclxuICAgIC8qKlxyXG4gICAgQm9vbGVhbiBmbGFnIHRvIGFsbG93IGFkZGluZyBhbmQgcmVtb3ZpbmcgaXMtZHJhZ2dpbmctb3ZlciBhbmQgaXMtZHJhZ2dpbmctb3Zlci1kaXNhYmxlZCBjbGFzc2VzLlxyXG5cclxuICAgIElmIHNldCB0byBmYWxzZSBpdCB3aWxsIG5vdCBhZGQgdGhlIGFib3ZlIG1lbnRpb25lZCBjbGFzc2VzIGFuZCB5b3Ugc2hvdWxkIGhhbmRsZSB0aGUgc3R5bGluZyB5b3Vyc2VsZiB3aXRoIGNzcyBhbmQgaW5cclxuICAgIHRoZSBhY3Rpb25NYXBwaW5nIC0+IG1vdXNlIC0+IGRyYWdFbnRlciwgZHJhZ0xlYXZlXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IHRydWUqKlxyXG5cclxuICAgIGV4YW1wbGU6XHJcbiAgICBgYGBcclxuICAgICogb3B0aW9ucyA9IHtcclxuICAgICogICBhbGxvd0Ryb3A6IHRydWUsXHJcbiAgICAqICAgYWxsb3dEcmFnb3ZlclN0eWxpbmc6IGZhbHNlXHJcbiAgICAqIH1cclxuICAgIGBgYFxyXG4gICAgKi9cclxuICAgYWxsb3dEcmFnb3ZlclN0eWxpbmc/OiBib29sZWFuO1xyXG4gICAvKipcclxuICAgKiBTcGVjaWZ5IHBhZGRpbmcgcGVyIG5vZGUgKGludGVnZXIpLlxyXG4gICAgRWFjaCBub2RlIHdpbGwgaGF2ZSBwYWRkaW5nLWxlZnQgdmFsdWUgb2YgbGV2ZWwgKiBsZXZlbFBhZGRpbmcsIGluc3RlYWQgb2YgdXNpbmcgdGhlIGRlZmF1bHQgcGFkZGluZyBmb3IgY2hpbGRyZW4uXHJcblxyXG4gICAgVGhpcyBvcHRpb24gaXMgZ29vZCBmb3IgZXhhbXBsZSBmb3IgYWxsb3dpbmcgd2hvbGUgcm93IHNlbGVjdGlvbiwgZXRjLlxyXG5cclxuICAgIFlvdSBjYW4gYWx0ZXJuYXRpdmVseSB1c2UgdGhlIHRyZWUtbm9kZS1sZXZlbC1YIGNsYXNzZXMgdG8gZ2l2ZSBwYWRkaW5nIG9uIGEgcGVyLWxldmVsIGJhc2lzLlxyXG5cclxuICAgICogKipEZWZhdWx0IHZhbHVlOiAwKipcclxuICAgKi9cclxuICAgbGV2ZWxQYWRkaW5nPzogbnVtYmVyO1xyXG4gICAvKipcclxuICAgICogU3BlY2lmeSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNsYXNzIHBlciBub2RlLiBVc2VmdWwgZm9yIHN0eWxpbmcgdGhlIG5vZGVzIGluZGl2aWR1YWxseS5cclxuXHJcbiAgICAgIEV4YW1wbGU6XHJcbiAgICAgIGBgYFxyXG4gICAgICAqIG9wdGlvbnMgPSB7XHJcbiAgICAgICogICBub2RlQ2xhc3M6IChub2RlOlRyZWVOb2RlKSA9PiB7XHJcbiAgICAgICogICAgIHJldHVybiAnaWNvbi0nICsgbm9kZS5kYXRhLmljb247XHJcbiAgICAgICogICB9XHJcbiAgICAgICogfVxyXG4gICAgICBgYGBcclxuICAgICovXHJcbiAgIG5vZGVDbGFzcz86IChub2RlOiBUcmVlTm9kZSkgPT4gc3RyaW5nO1xyXG4gICAvKipcclxuICAgIEJvb2xlYW4gZmxhZyB0byB1c2UgdGhlIHZpcnR1YWwgc2Nyb2xsIG9wdGlvbi5cclxuXHJcbiAgICBUbyB1c2UgdGhpcyBvcHRpb24sIHlvdSBtdXN0IHN1cHBseSB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIsIGFuZCB0aGUgaGVpZ2h0IG9mIGVhY2ggbm9kZSBpbiB0aGUgdHJlZS5cclxuXHJcbiAgICBZb3UgY2FuIGFsc28gc3BlY2lmeSBoZWlnaHQgZm9yIHRoZSBkcm9wU2xvdCB3aGljaCBpcyBsb2NhdGVkIGJldHdlZW4gbm9kZXMuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IGZhbHNlKipcclxuXHJcbiAgICBleGFtcGxlOlxyXG4gICAgYGBgXHJcbiAgICAqIG9wdGlvbnMgPSB7XHJcbiAgICAqICAgdXNlVmlydHVhbFNjcm9sbDogdHJ1ZSxcclxuICAgICogICBub2RlSGVpZ2h0OiAobm9kZTogVHJlZU5vZGUpID0+IG5vZGUubXlIZWlnaHQsXHJcbiAgICAqICAgZHJvcFNsb3RIZWlnaHQ6IDNcclxuICAgICogfVxyXG4gICAgYGBgXHJcbiAgICAqL1xyXG4gICB1c2VWaXJ0dWFsU2Nyb2xsPzogYm9vbGVhbjtcclxuICAgLyoqXHJcbiAgICAqIEZvciB1c2Ugd2l0aCBgdXNlVmlydHVhbFNjcm9sbGAgb3B0aW9uLlxyXG4gICAgKiBTcGVjaWZ5IGEgaGVpZ2h0IGZvciBub2RlcyBpbiBwaXhlbHMuIENvdWxkIGJlIGVpdGhlcjpcclxuICAgICogLSBudW1iZXJcclxuICAgICogLSAobm9kZTogVHJlZU5vZGUpID0+IG51bWJlclxyXG5cclxuICAgICogKipEZWZhdWx0IFZhbHVlOiAyMioqXHJcbiAgICAqL1xyXG4gICBub2RlSGVpZ2h0PzogbnVtYmVyIHwgSU5vZGVIZWlnaHRGbjtcclxuICAgLyoqXHJcbiAgICAqIEZvciB1c2Ugd2l0aCBgdXNlVmlydHVhbFNjcm9sbGAgb3B0aW9uLlxyXG4gICAgKiBTcGVjaWZ5IGEgaGVpZ2h0IGZvciBkcm9wIHNsb3RzIChsb2NhdGVkIGJldHdlZW4gbm9kZXMpIGluIHBpeGVsc1xyXG5cclxuICAgICogKipEZWZhdWx0IFZhbHVlOiAyKipcclxuICAgICovXHJcbiAgIGRyb3BTbG90SGVpZ2h0PzogbnVtYmVyO1xyXG4gICAvKipcclxuICAgICogQm9vbGVhbiB3aGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIGV4cGFuZCAvIGNvbGxhcHNlIG9mIG5vZGVzLlxyXG5cclxuICAgICogKipEZWZhdWx0IFZhbHVlOiBmYWxzZSoqXHJcbiAgICAqL1xyXG4gICBhbmltYXRlRXhwYW5kPzogYm9vbGVhbjtcclxuICAgLyoqXHJcbiAgICAqIFNwZWVkIG9mIGV4cGFuZCBhbmltYXRpb24gKGRlc2NyaWJlZCBpbiBwaXhlbHMgcGVyIDE3IG1zKS5cclxuXHJcbiAgICAqICoqRGVmYXVsdCBWYWx1ZTogMzAqKlxyXG4gICAgKi9cclxuICAgYW5pbWF0ZVNwZWVkPzogbnVtYmVyO1xyXG4gICAvKipcclxuICAgICogSW5jcmVhc2Ugb2YgZXhwYW5kIGFuaW1hdGlvbiBzcGVlZCAoZGVzY3JpYmVkIGluIG11bHRpcGx5IHBlciAxNyBtcykuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IDEuMioqXHJcbiAgICAqL1xyXG4gICBhbmltYXRlQWNjZWxlcmF0aW9uPzogbnVtYmVyO1xyXG4gICAvKipcclxuICAgICogV2hldGhlciB0byBzY3JvbGwgdG8gdGhlIG5vZGUgdG8gbWFrZSBpdCB2aXNpYmxlIHdoZW4gaXQgaXMgYWN0aXZhdGVkLlxyXG5cclxuICAgICogKipEZWZhdWx0IFZhbHVlOiB0cnVlKipcclxuICAgICovXHJcbiAgIHNjcm9sbE9uQWN0aXZhdGU/OiBib29sZWFuO1xyXG4gICAvKipcclxuICAgICogRnVuY3Rpb24gdG8gY2xvbmUgYSBub2RlLlxyXG4gICAgKiBSZWNlaXZlcyBhIFRyZWVOb2RlIG9iamVjdCwgYW5kIHJldHVybnMgYSBub2RlIG9iamVjdCAob25seSB0aGUgZGF0YSkuXHJcbiAgICAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBjb3B5aW5nIGEgbm9kZSBpbnNpZGUgdGhlIHRyZWUsXHJcbiAgICAqIGJ5IGVpdGhlciBjYWxsaW5nIGNvcHlOb2RlLCBvciBieSBkcmFnZ2luZyBhbmQgaG9sZGluZyB0aGUgY3RybCBrZXlcclxuICAgICpcclxuICAgICogRm9yIGV4YW1wbGU6XHJcbiAgICAgIGBgYFxyXG4gICAgICAgIG9wdGlvbnM6IElUcmVlT3B0aW9ucyA9IHtcclxuICAgICAgICAgIGdldE5vZGVDbG9uZTogKG5vZGUpID0+ICh7XHJcbiAgICAgICAgICAgIC4uLm5vZGUuZGF0YSxcclxuICAgICAgICAgICAgaWQ6IHV1aWQudjQoKSxcclxuICAgICAgICAgICAgbmFtZTogYGNvcHkgb2YgJHtub2RlLmRhdGEubmFtZX1gXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH07XHJcbiAgICAgIGBgYFxyXG4gICAgKlxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IGNsb25lIHRoZSBub2RlIHVzaW5nIE9iamVjdC5hc3NpZ24sIGFuZCByZW1vdmUgJ2lkJyBwcm9wZXJ0eSoqXHJcbiAgICAqL1xyXG4gICAgZ2V0Tm9kZUNsb25lPzogKG5vZGU6IFRyZWVOb2RlKSA9PiBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoZSB0cmVlIHJpZ2h0LXRvLWxlZnQuXHJcbiAgICAgKiBUaGlzIGluY2x1ZGUgZGlyZWN0aW9uLCBleHBhbmRlciBzdHlsZSwgYW5kIGNoYW5nZSBrZXkgYmluZGluZyAocmlnaHQga2V5IGNvbGxhcHNlIGFuZCBsZWZ0IGtleSBleHBhbmRzIGluc3RlYWQgb2YgdmljZS12ZXJzYSlcclxuICAgICAqL1xyXG4gICAgcnRsPzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIGlkIG9mIHJvb3Qgbm9kZSAodmlydHVhbFJvb3QpXHJcbiAgICAgKi9cclxuICAgIHJvb3RJZD86IGFueTtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBkaXNwbGF5IGEgY2hlY2tib3ggbmV4dCB0byB0aGUgbm9kZSBvciBub3RcclxuICAgICAqL1xyXG4gICAgdXNlQ2hlY2tib3g/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHVzZSBtYXN0ZXIgY2hlY2tib3hlcyBtZWNoYW5pc20gaWYgdGhlIHVzZUNoZWNrYm94IGlzIHNldCB0byB0cnVlXHJcbiAgICAgKi9cclxuICAgIHVzZVRyaVN0YXRlPzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIEhUTUwgZWxlbWVudCB0aGF0IGlzIHRoZSBzY3JvbGwgY29udGFpbmVyIGZvciB0aGUgdHJlZS5cclxuICAgICAqIFRoZSBkZWZhdWx0IGJlaGF2aW91ciBpcyB0byB3cmFwIHRoZSB0cmVlIHdpdGggYSBjb250YWluZXIgdGhhdCBoYXMgb3ZlcmZsb3c6IGhpZGRlbixcclxuICAgICAqIGFuZCB0aGVuIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGlzIHRoZSB2aWV3cG9ydCBpbnNpZGUgdGhlIHRyZWUgY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHNjcm9sbENvbnRhaW5lcj86IEhUTUxFbGVtZW50O1xyXG4gfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJVHJlZU5vZGUge1xyXG4gIC8vIHByb3BlcnRpZXNcclxuICAvKipcclxuICAgKiBQYXJlbnQgbm9kZVxyXG4gICAqL1xyXG4gIHBhcmVudDogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSdzIGZpZWxkIHRoYXQgaXMgdXNlZCBmb3IgZGlzcGxheWluZyBpdHMgY29udGVudC5cclxuICAgKiBCeSBkZWZhdWx0ICduYW1lJywgdW5sZXNzIHN0YXRlZCBvdGhlcndpc2UgaW4gdGhlIG9wdGlvbnNcclxuICAgKi9cclxuICBkaXNwbGF5RmllbGQ6IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgY2hpbGRyZW4gb2YgdGhlIG5vZGUuXHJcbiAgICogQnkgZGVmYXVsdCBpcyBkZXRlcm1pbmVkIGJ5ICdub2RlLmRhdGEuY2hpbGRyZW4nLCB1bmxlc3Mgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGUgb3B0aW9uc1xyXG4gICAqL1xyXG4gIGNoaWxkcmVuOiBJVHJlZU5vZGVbXTtcclxuICAvKipcclxuICAgKiBQb2ludGVyIHRvIHRoZSBvcmlnaW5hbCBkYXRhLlxyXG4gICAqL1xyXG4gIGRhdGE6IGFueTtcclxuICAvKipcclxuICAgKiBQb2ludGVyIHRvIHRoZSBFbGVtZW50UmVmIG9mIHRoZSBUcmVlTm9kZUNvbXBvbmVudCB0aGF0J3MgZGlzcGxheWluZyB0aGlzIG5vZGVcclxuICAgKi9cclxuICBlbGVtZW50UmVmOiBhbnk7XHJcbiAgLyoqXHJcbiAgICogTGV2ZWwgaW4gdGhlIHRyZWUgKHN0YXJ0cyBmcm9tIDEpLlxyXG4gICAqL1xyXG4gIGxldmVsOiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogUGF0aCBpbiB0aGUgdHJlZTogQXJyYXkgb2YgSURzLlxyXG4gICAqL1xyXG4gIHBhdGg6IHN0cmluZ1tdO1xyXG4gIC8qKlxyXG4gICAqIGluZGV4IG9mIHRoZSBub2RlIGluc2lkZSBpdHMgcGFyZW50J3MgY2hpbGRyZW5cclxuICAgKi9cclxuICBpbmRleDogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIEEgdW5pcXVlIGtleSBvZiB0aGlzIG5vZGUgYW1vbmcgaXRzIHNpYmxpbmdzLlxyXG4gICAqIEJ5IGRlZmF1bHQgaXQncyB0aGUgJ2lkJyBvZiB0aGUgb3JpZ2luYWwgbm9kZSwgdW5sZXNzIHN0YXRlZCBvdGhlcndpc2UgaW4gb3B0aW9ucy5pZEZpZWxkXHJcbiAgICovXHJcbiAgaWQ6IElEVHlwZTtcclxuXHJcbiAgLy8gaGVscGVyc1xyXG4gIGlzRXhwYW5kZWQ6IGJvb2xlYW47XHJcbiAgaXNBY3RpdmU6IGJvb2xlYW47XHJcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xyXG4gIGlzQ29sbGFwc2VkOiBib29sZWFuO1xyXG4gIGlzTGVhZjogYm9vbGVhbjtcclxuICBoYXNDaGlsZHJlbjogYm9vbGVhbjtcclxuICBpc1Jvb3Q6IGJvb2xlYW47XHJcblxyXG4gIC8vIHRyYXZlcnNpbmdcclxuICAvKipcclxuICAgKiBAcGFyYW0gc2tpcEhpZGRlbiB3aGV0aGVyIHRvIHNraXAgaGlkZGVuIG5vZGVzXHJcbiAgICogQHJldHVybnMgbmV4dCBzaWJsaW5nIChvciBudWxsKVxyXG4gICAqL1xyXG4gIGZpbmROZXh0U2libGluZyhza2lwSGlkZGVuKTogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBza2lwSGlkZGVuIHdoZXRoZXIgdG8gc2tpcCBoaWRkZW4gbm9kZXNcclxuICAgKiBAcmV0dXJucyBwcmV2aW91cyBzaWJsaW5nIChvciBudWxsKVxyXG4gICAqL1xyXG4gIGZpbmRQcmV2aW91c1NpYmxpbmcoc2tpcEhpZGRlbik6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBAcGFyYW0gc2tpcEhpZGRlbiB3aGV0aGVyIHRvIHNraXAgaGlkZGVuIG5vZGVzXHJcbiAgICogQHJldHVybnMgZmlyc3QgY2hpbGQgKG9yIG51bGwpXHJcbiAgICovXHJcbiAgZ2V0Rmlyc3RDaGlsZChza2lwSGlkZGVuKTogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBza2lwSGlkZGVuIHdoZXRoZXIgdG8gc2tpcCBoaWRkZW4gbm9kZXNcclxuICAgKiBAcmV0dXJucyBsYXN0IGNoaWxkIChvciBudWxsKVxyXG4gICAqL1xyXG4gIGdldExhc3RDaGlsZChza2lwSGlkZGVuKTogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIEZpbmRzIHRoZSB2aXN1YWxseSBuZXh0IG5vZGUgaW4gdGhlIHRyZWUuXHJcbiAgICogQHBhcmFtIGdvSW5zaWRlIHdoZXRoZXIgdG8gbG9vayBmb3IgY2hpbGRyZW4gb3IganVzdCBzaWJsaW5nc1xyXG4gICAqIEByZXR1cm5zIG5leHQgbm9kZS5cclxuICAgKi9cclxuICBmaW5kTmV4dE5vZGUoZ29JbnNpZGU6IGJvb2xlYW4pOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogRmluZHMgdGhlIHZpc3VhbGx5IHByZXZpb3VzIG5vZGUgaW4gdGhlIHRyZWUuXHJcbiAgICogQHBhcmFtIHNraXBIaWRkZW4gd2hldGhlciB0byBza2lwIGhpZGRlbiBub2Rlc1xyXG4gICAqIEByZXR1cm5zIHByZXZpb3VzIG5vZGUuXHJcbiAgICovXHJcbiAgZmluZFByZXZpb3VzTm9kZShza2lwSGlkZGVuKTogSVRyZWVOb2RlO1xyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyAgICAgIHRydWUgaWYgdGhpcyBub2RlIGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgcGFyYW1ldGVyIG5vZGVcclxuICAgKi9cclxuICBpc0Rlc2NlbmRhbnRPZihub2RlOiBJVHJlZU5vZGUpOiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyAgICAgIGluIGNhc2UgbGV2ZWxQYWRkaW5nIG9wdGlvbiBpcyBzdXBwbGllZCwgcmV0dXJucyB0aGUgY3VycmVudCBub2RlJ3MgcGFkZGluZ1xyXG4gICAqL1xyXG4gIGdldE5vZGVQYWRkaW5nKCk6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMgICAgICBpbiBjYXNlIG5vZGVDbGFzcyBvcHRpb24gaXMgc3VwcGxpZWQsIHJldHVybnMgdGhlIGN1cnJlbnQgbm9kZSdzIGNsYXNzXHJcbiAgICovXHJcbiAgZ2V0Q2xhc3MoKTogc3RyaW5nO1xyXG5cclxuICAvLyBhY3Rpb25zXHJcbiAgLyoqXHJcbiAgICogRXhwYW5kcyAvIENvbGxhcHNlcyB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIHRvZ2dsZUV4cGFuZGVkKCk7XHJcbiAgLyoqXHJcbiAgICogRXhwYW5kcyB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIGV4cGFuZCgpO1xyXG4gIC8qKlxyXG4gICAqIENvbGxhcHNlcyB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIGNvbGxhcHNlKCk7XHJcbiAgLyoqXHJcbiAgICogRXhwYW5kcyBhbGwgYW5jZXN0b3JzIG9mIHRoZSBub2RlXHJcbiAgICovXHJcbiAgZW5zdXJlVmlzaWJsZSgpO1xyXG4gIC8qKlxyXG4gICAqIEFjdGl2YXRlcyAvIERlYWN0aXZhdGVzIHRoZSBub2RlIChzZWxlY3RzIC8gZGVzZWxlY3RzKVxyXG4gICAqL1xyXG4gIHRvZ2dsZUFjdGl2YXRlZChtdWx0aSk7XHJcbiAgLyoqXHJcbiAgICogRm9jdXMgb24gdGhlIG5vZGVcclxuICAgKi9cclxuICBmb2N1cygpO1xyXG4gIC8qKlxyXG4gICAqIEJsdXIgKHVuZm9jdXMpIHRoZSBub2RlXHJcbiAgICovXHJcbiAgYmx1cigpO1xyXG4gIC8qKlxyXG4gICAqIEhpZGVzIHRoZSBub2RlXHJcbiAgICovXHJcbiAgaGlkZSgpO1xyXG4gIC8qKlxyXG4gICAqIE1ha2VzIHRoZSBub2RlIHZpc2libGVcclxuICAgKi9cclxuICBzaG93KCk7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHZhbHVlICBpZiB0cnVlIG1ha2VzIHRoZSBub2RlIGhpZGRlbiwgb3RoZXJ3aXNlIHZpc2libGVcclxuICAgKi9cclxuICBzZXRJc0hpZGRlbih2YWx1ZTogYm9vbGVhbik7XHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHRoZSBzY3JlZW4gdG8gbWFrZSB0aGUgbm9kZSB2aXNpYmxlXHJcbiAgICovXHJcbiAgc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAvKipcclxuICAgKiBGaXJlIGFuIGV2ZW50IHRvIHRoZSByZW5kZXJlciBvZiB0aGUgdHJlZSAoaWYgaXQgd2FzIHJlZ2lzdGVyZWQpXHJcbiAgICovXHJcbiAgZmlyZUV2ZW50KGV2ZW50OiBhbnkpO1xyXG4gIC8qKlxyXG4gICAqIEludm9rZXMgYSBtZXRob2QgZm9yIGV2ZXJ5IG5vZGUgdW5kZXIgdGhpcyBvbmUgLSBkZXB0aCBmaXJzdFxyXG4gICAqIEBwYXJhbSBmbiAgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBub2RlXHJcbiAgICovXHJcbiAgZG9Gb3JBbGwoZm46IChub2RlOiBJVHJlZU5vZGUpID0+IGFueSk7XHJcbiAgLyoqXHJcbiAgICogZXhwYW5kIGFsbCBub2RlcyB1bmRlciB0aGlzIG9uZVxyXG4gICAqL1xyXG4gIGV4cGFuZEFsbCgpO1xyXG4gIC8qKlxyXG4gICAqIGNvbGxhcHNlIGFsbCBub2RlcyB1bmRlciB0aGlzIG9uZVxyXG4gICAqL1xyXG4gIGNvbGxhcHNlQWxsKCk7XHJcbiAgLyoqXHJcbiAgICogc2V0cyB0aGUgbm9kZSB0byBhY3RpdmUgLyBpbmFjdGl2ZSBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlLlxyXG4gICAqIElmIG11bHRpIGlzIHRydWUgKGRlZmF1bHQgZmFsc2UpIC0gZG9lcyBhIG11bHRpc2VsZWN0LlxyXG4gICAqL1xyXG4gIHNldElzQWN0aXZlKHZhbHVlOiBib29sZWFuLCBtdWx0aT86IGJvb2xlYW4pO1xyXG4gIC8qKlxyXG4gICAqIHNldHMgdGhlIG5vZGUgdG8gYmUgYWN0aXZlIGFuZCBtYWtlcyBzdXJlIGl0J3MgdmlzaWJsZSBieSBleHBhbmRpbmcgYWxsIG5vZGVzIGFib3ZlIGl0IGFuZCBzY3JvbGxpbmcgaXQgaW50byB2aWV3LlxyXG4gICAqIFZlcnkgc2ltaWxhciB0byBjYWxsaW5nIGBhY3RpdmF0ZWAsIGBlbnN1cmVWaXNpYmxlYCBhbmQgYHNjcm9sbEludG9WaWV3YCBtZXRob2RzLlxyXG4gICAqIElmIG11bHRpIGlzIHRydWUgKGRlZmF1bHQgZmFsc2UpIC0gZG9lcyBhIG11bHRpc2VsZWN0LlxyXG4gICAqL1xyXG4gIHNldEFjdGl2ZUFuZFZpc2libGUobXVsdGk6IGJvb2xlYW4pO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElUcmVlTW9kZWwge1xyXG4gIC8vIHByb3BlcnRpZXNcclxuICAvKipcclxuICAgKiBBbGwgcm9vdCBub2Rlc1xyXG4gICAqL1xyXG4gIHJvb3RzOiBJVHJlZU5vZGVbXTtcclxuICAvKipcclxuICAgKiBDdXJyZW50IGZvY3VzZWQgbm9kZVxyXG4gICAqL1xyXG4gIGZvY3VzZWROb2RlOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogT3B0aW9ucyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSB0cmVlIGNvbXBvbmVudFxyXG4gICAqL1xyXG4gIG9wdGlvbnM6IElUcmVlT3B0aW9ucztcclxuXHJcbiAgLyoqXHJcbiAgICogSXMgdGhlIHRyZWUgY3VycmVudGx5IGZvY3VzZWRcclxuICAgKi9cclxuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMgQ3VycmVudCBhY3RpdmUgbm9kZXNcclxuICAgKi9cclxuICBhY3RpdmVOb2RlczogSVRyZWVOb2RlW107XHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMgQ3VycmVudCBleHBhbmRlZCBub2Rlc1xyXG4gICAqL1xyXG4gIGV4cGFuZGVkTm9kZXM6IElUcmVlTm9kZVtdO1xyXG5cclxuICAvLyBoZWxwZXJzXHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMgQ3VycmVudCBhY3RpdmUgbm9kZS4gSWYgbXVsdGlwbGUgbm9kZXMgYXJlIGFjdGl2ZSAtIHJldHVybnMgdGhlIGZpcnN0IG9uZS5cclxuICAgKi9cclxuICBnZXRBY3RpdmVOb2RlKCk6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBAcmV0dXJucyBDdXJyZW50IGZvY3VzZWQgbm9kZSAoZWl0aGVyIGhvdmVyZWQgb3IgdHJhdmVyc2VkIHdpdGgga2V5cylcclxuICAgKi9cclxuICBnZXRGb2N1c2VkTm9kZSgpOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogU2V0IGZvY3VzIG9uIGEgbm9kZVxyXG4gICAqIEBwYXJhbSB2YWx1ZSAgdHJ1ZSBvciBmYWxzZSAtIHdoZXRoZXIgdG8gc2V0IGZvY3VzIG9yIGJsdXIuXHJcbiAgICovXHJcbiAgc2V0Rm9jdXNlZE5vZGUobm9kZTogSVRyZWVOb2RlKTtcclxuICAvKipcclxuICAgKiBAcGFyYW0gc2tpcEhpZGRlbiAgdHJ1ZSBvciBmYWxzZSAtIHdoZXRoZXIgdG8gc2tpcCBoaWRkZW4gbm9kZXNcclxuICAgKiBAcmV0dXJucyAgICAgIGZpcnN0IHJvb3Qgb2YgdGhlIHRyZWVcclxuICAgKi9cclxuICBnZXRGaXJzdFJvb3Qoc2tpcEhpZGRlbj86IGJvb2xlYW4pOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHNraXBIaWRkZW4gIHRydWUgb3IgZmFsc2UgLSB3aGV0aGVyIHRvIHNraXAgaGlkZGVuIG5vZGVzXHJcbiAgICogQHJldHVybnMgICAgICBsYXN0IHJvb3Qgb2YgdGhlIHRyZWVcclxuICAgKi9cclxuICBnZXRMYXN0Um9vdChza2lwSGlkZGVuPzogYm9vbGVhbik6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBAcmV0dXJucyAgICAgIHRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHlcclxuICAgKi9cclxuICBpc0VtcHR5VHJlZSgpOiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIEFsbCByb290IG5vZGVzIHRoYXQgcGFzcyB0aGUgY3VycmVudCBmaWx0ZXJcclxuICAgKi9cclxuICBnZXRWaXNpYmxlUm9vdHMoKTogSVRyZWVOb2RlW107XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtICAgICBwYXRoICBhcnJheSBvZiBub2RlIElEcyB0byBiZSB0cmF2ZXJzZWQgcmVzcGVjdGl2ZWx5XHJcbiAgICogQHBhcmFtICAgICBzdGF0ck5vZGUgIG9wdGlvbmFsLiBXaGljaCBub2RlIHRvIHN0YXJ0IHRyYXZlcnNpbmcgZnJvbVxyXG4gICAqIEByZXR1cm5zICAgVGhlIG5vZGUsIGlmIGZvdW5kIC0gbnVsbCBvdGhlcndpc2VcclxuICAgKi9cclxuICBnZXROb2RlQnlQYXRoKHBhdGg6IGFueVtdLCBzdGFydE5vZGU/OiBJVHJlZU5vZGUpOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtICAgICBpZCAgbm9kZSBJRCB0byBmaW5kXHJcbiAgICogQHJldHVybnMgICBUaGUgbm9kZSwgaWYgZm91bmQgLSBudWxsIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIGdldE5vZGVCeUlkKGlkOiBJRFR5cGUpOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtICAgICBwcmVkaWNhdGUgLSBlaXRoZXIgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIHVzZWQgYXMgYSB0ZXN0IGNvbmRpdGlvbiBvbiBhbGwgbm9kZXMuXHJcbiAgICogICAgICAgICAgICBDb3VsZCBiZSBldmVyeSBwcmVkaWNhdGUgdGhhdCdzIHN1cHBvcnRlZCBieSBsb2Rhc2gncyBgZmluZGAgbWV0aG9kXHJcbiAgICogQHBhcmFtICAgICBzdGF0ck5vZGUgIG9wdGlvbmFsLiBXaGljaCBub2RlIHRvIHN0YXJ0IHRyYXZlcnNpbmcgZnJvbVxyXG4gICAqIEByZXR1cm5zICAgRmlyc3Qgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZSwgaWYgZm91bmQgLSBudWxsIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIGdldE5vZGVCeShwcmVkaWNhdGU6IGFueSwgc3RhcnROb2RlPzogSVRyZWVOb2RlKTogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIGdldCB0cmVlIHN0YXRlXHJcbiAgICovXHJcbiAgZ2V0U3RhdGUoKTogSVRyZWVTdGF0ZTtcclxuXHJcbiAgLy8gYWN0aW9uc1xyXG4gIC8qKlxyXG4gICAqIEZvY3VzZXMgb3IgYmx1cnMgdGhlIHRyZWVcclxuICAgKiBAcGFyYW0gdmFsdWUgIHRydWUgb3IgZmFsc2UgLSB3aGV0aGVyIHRvIHNldCBmb2N1cyBvciBibHVyLlxyXG4gICAqL1xyXG4gIHNldEZvY3VzKHZhbHVlOiBib29sZWFuKTtcclxuICAvKipcclxuICAgKiBGb2N1c2VzIG9uIHRoZSBuZXh0IG5vZGUgaW4gdGhlIHRyZWUgKHNhbWUgYXMgZG93biBhcnJvdylcclxuICAgKi9cclxuICBmb2N1c05leHROb2RlKCk7XHJcbiAgLyoqXHJcbiAgICogRm9jdXNlcyBvbiB0aGUgcHJldmlvdXMgbm9kZSBpbiB0aGUgdHJlZSAoc2FtZSBhcyB1cCBhcnJvdylcclxuICAgKi9cclxuICBmb2N1c1ByZXZpb3VzTm9kZSgpO1xyXG4gIC8qKlxyXG4gICAqIEZvY3VzZXMgb24gdGhlIGlubmVyIGNoaWxkIG9mIHRoZSBjdXJyZW50IGZvY3VzZWQgbm9kZSAoc2FtZSBhcyByaWdodCBhcnJvdyBvbiBhbiBleHBhbmRlZCBub2RlKVxyXG4gICAqL1xyXG4gIGZvY3VzRHJpbGxEb3duKCk7XHJcbiAgLyoqXHJcbiAgICogRm9jdXNlcyBvbiB0aGUgcGFyZW50IG9mIHRoZSBjdXJyZW50IGZvY3VzZWQgbm9kZSAoc2FtZSBhcyBsZWZ0IGFycm93IG9uIGEgY29sbGFwc2VkIG5vZGUpXHJcbiAgICovXHJcbiAgZm9jdXNEcmlsbFVwKCk7XHJcbiAgLyoqXHJcbiAgICogTWFya3MgaXNIaWRkZW4gZmllbGQgaW4gYWxsIG5vZGVzIHJlY3Vyc2l2ZWx5IGFjY29yZGluZyB0byB0aGUgZmlsdGVyIHBhcmFtLlxyXG4gICAqIElmIGEgbm9kZSBpcyBtYXJrZWQgdmlzaWJsZSwgYWxsIG9mIGl0cyBhbmNlc3RvcnMgd2lsbCBiZSBtYXJrZWQgdmlzaWJsZSBhcyB3ZWxsLlxyXG4gICAqIEBwYXJhbSBmaWx0ZXIgIGVpdGhlciBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLlxyXG4gICAqICAgSW4gY2FzZSBpdCdzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHNlYXJjaGVkIGNhc2UgaW5zZW5zaXRpdmVseSBpbiB0aGUgbm9kZSdzIGRpc3BsYXkgYXR0cmlidXRlXHJcbiAgICogICBJbiBjYXNlIGl0J3MgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBwYXNzZWQgdGhlIG5vZGUsIGFuZCBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqIEBwYXJhbSBhdXRvU2hvdyAgaWYgdHJ1ZSwgbWFrZSBzdXJlIGFsbCBub2RlcyB0aGF0IHBhc3NlZCB0aGUgZmlsdGVyIGFyZSB2aXNpYmxlXHJcbiAgICovXHJcbiAgZmlsdGVyTm9kZXMoZmlsdGVyLCBhdXRvU2hvdz86IGJvb2xlYW4pO1xyXG4gIC8qKlxyXG4gICAqIE1hcmtzIGFsbCBub2RlcyBpc0hpZGRlbiA9IGZhbHNlXHJcbiAgICovXHJcbiAgY2xlYXJGaWx0ZXIoKTtcclxuICAvKipcclxuICAgKiBtb3ZlcyBhIG5vZGUgZnJvbSBvbmUgbG9jYXRpb24gaW4gdGhlIHRyZWUgdG8gYW5vdGhlclxyXG4gICAqIEBwYXJhbSBub2RlIGRlc2NyaWJlcyB3aGljaCBub2RlIG5lZWRzIHRvIGJlIG1vdmVkXHJcbiAgICogQHBhcmFtIHRvIGRlc2NyaWJlcyB3aGVyZSB0byBtb3ZlIHRoZSBub2RlIHRvLlxyXG4gICAqIEBwYXJhbSBmcm9tIGRlc2NyaWJlcyB3aGVyZSB0byBtb3ZlIHRoZSBub2RlIGZyb20uXHJcbiAgICogQ29udGFpbnMgYSAncGFyZW50JyBub2RlLCBhbiAnaW5kZXgnLCBhbmQgYSAnZHJvcE9uTm9kZScgLSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGRyb3BwaW5nIGJldHdlZW4gbm9kZXMgb3Igb24gdGhlIG5vZGVcclxuICAgKi9cclxuICBtb3ZlTm9kZShub2RlOiBJVHJlZU5vZGUsIHRvOiB7cGFyZW50OiBJVHJlZU5vZGUsIGluZGV4OiBudW1iZXIsIGRyb3BPbk5vZGU6IGJvb2xlYW59LCBmcm9tOiB7cGFyZW50OiBJVHJlZU5vZGUsIGluZGV4OiBudW1iZXJ9KTtcclxuICAvKipcclxuICAgKiBJbnZva2VzIGEgbWV0aG9kIGZvciBldmVyeSBub2RlIG9mIHRoZSB0cmVlIC0gZGVwdGggZmlyc3RcclxuICAgKiBAcGFyYW0gZm4gIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIGRvRm9yQWxsKGZuOiAobm9kZTogSVRyZWVOb2RlKSA9PiBhbnkpO1xyXG4gIC8qKlxyXG4gICAqIGV4cGFuZCBhbGwgbm9kZXNcclxuICAgKi9cclxuICBleHBhbmRBbGwoKTtcclxuICAvKipcclxuICAgKiBjb2xsYXBzZSBhbGwgbm9kZXNcclxuICAgKi9cclxuICBjb2xsYXBzZUFsbCgpO1xyXG4gIC8qKlxyXG4gICAqIHNldCB0cmVlIHN0YXRlXHJcbiAgICovXHJcbiAgc2V0U3RhdGUoc3RhdGU6IElUcmVlU3RhdGUpO1xyXG5cclxuICBzdWJzY3JpYmVUb1N0YXRlKGZuOiAoc3RhdGU6IElUcmVlU3RhdGUpID0+IGFueSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGludGVyZmFjZSBvZiB0aGUgVHJlZU5vZGVEcmFnIHNlcnZpY2VcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRyZWVOb2RlRHJhZyB7XHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgY3VycmVudCBkcmFnZ2VkIG5vZGUuIFVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB0aGUgZHJvcCBhY3Rpb24uXHJcbiAgICogQHBhcmFtIG5vZGUgIFRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3VycmVudCBkcmFnZ2VkIG5vZGVcclxuICAgKiBAcGFyYW0gaW5kZXggIFRoZSBpbmRleCBpbnNpZGUgcGFyZW50J3MgY2hpbGRyZW4sIG9mIHRoZSBjdXJyZW50IGRyYWdnZWQgbm9kZVxyXG4gICAqL1xyXG4gIGdldERyYWdOb2RlKCk6IHsgbm9kZTogVHJlZU5vZGUsIGluZGV4OiBudW1iZXIgfTtcclxufVxyXG4iXX0=