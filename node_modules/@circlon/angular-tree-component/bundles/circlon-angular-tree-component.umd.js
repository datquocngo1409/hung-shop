(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('mobx'), require('lodash-es')) :
    typeof define === 'function' && define.amd ? define('@circlon/angular-tree-component', ['exports', '@angular/core', '@angular/common', 'mobx', 'lodash-es'], factory) :
    (global = global || self, factory((global.circlon = global.circlon || {}, global.circlon['angular-tree-component'] = {}), global.ng.core, global.ng.common, global.mobx, global['lodash-es']));
}(this, (function (exports, core, common, mobx, lodashEs) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/mobx-angular/tree-mobx-autorun.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeMobxAutorunDirective = /** @class */ (function () {
        function TreeMobxAutorunDirective(templateRef, viewContainer) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.templateBindings = {};
        }
        /**
         * @return {?}
         */
        TreeMobxAutorunDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.view = this.viewContainer.createEmbeddedView(this.templateRef);
            if (this.dispose) {
                this.dispose();
            }
            if (this.shouldDetach()) {
                this.view.detach();
            }
            this.autoDetect(this.view);
        };
        /**
         * @return {?}
         */
        TreeMobxAutorunDirective.prototype.shouldDetach = /**
         * @return {?}
         */
        function () {
            return this.treeMobxAutorun && this.treeMobxAutorun.detach;
        };
        /**
         * @param {?} view
         * @return {?}
         */
        TreeMobxAutorunDirective.prototype.autoDetect = /**
         * @param {?} view
         * @return {?}
         */
        function (view) {
            this.dispose = mobx.autorun((/**
             * @return {?}
             */
            function () { return view.detectChanges(); }));
        };
        /**
         * @return {?}
         */
        TreeMobxAutorunDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.dispose) {
                this.dispose();
            }
        };
        TreeMobxAutorunDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[treeMobxAutorun]' },] }
        ];
        /** @nocollapse */
        TreeMobxAutorunDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef }
        ]; };
        TreeMobxAutorunDirective.propDecorators = {
            treeMobxAutorun: [{ type: core.Input }]
        };
        return TreeMobxAutorunDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        TreeMobxAutorunDirective.prototype.templateBindings;
        /**
         * @type {?}
         * @protected
         */
        TreeMobxAutorunDirective.prototype.dispose;
        /**
         * @type {?}
         * @protected
         */
        TreeMobxAutorunDirective.prototype.view;
        /** @type {?} */
        TreeMobxAutorunDirective.prototype.treeMobxAutorun;
        /**
         * @type {?}
         * @protected
         */
        TreeMobxAutorunDirective.prototype.templateRef;
        /**
         * @type {?}
         * @protected
         */
        TreeMobxAutorunDirective.prototype.viewContainer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/constants/keys.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var KEYS = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        ENTER: 13,
        SPACE: 32,
        CONTEXT_MENU: 32
    };

    var _a;
    /**
     * @record
     */
    function IActionHandler() { }
    var ɵ0 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node && node.toggleActivated(); }, ɵ1 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node && node.toggleActivated(true); }, ɵ2 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node && node.toggleSelected(); }, ɵ3 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.setIsActive(true); }, ɵ4 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.setIsActive(false); }, ɵ5 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.setIsSelected(true); }, ɵ6 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.setIsSelected(false); }, ɵ7 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.focus(); }, ɵ8 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.hasChildren && node.toggleExpanded(); }, ɵ9 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.expand(); }, ɵ10 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return node.collapse(); }, ɵ11 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return tree.focusDrillDown(); }, ɵ12 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return tree.focusDrillUp(); }, ɵ13 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return tree.focusNextNode(); }, ɵ14 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    function (tree, node, $event) { return tree.focusPreviousNode(); }, ɵ15 = /**
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @param {?} __3
     * @return {?}
     */
    function (tree, node, $event, _a) {
        var from = _a.from, to = _a.to;
        // default action assumes from = node, to = {parent, index}
        if ($event.ctrlKey) {
            tree.copyNode(from, to);
        }
        else {
            tree.moveNode(from, to);
        }
    };
    /** @type {?} */
    var TREE_ACTIONS = {
        TOGGLE_ACTIVE: (ɵ0),
        TOGGLE_ACTIVE_MULTI: (ɵ1),
        TOGGLE_SELECTED: (ɵ2),
        ACTIVATE: (ɵ3),
        DEACTIVATE: (ɵ4),
        SELECT: (ɵ5),
        DESELECT: (ɵ6),
        FOCUS: (ɵ7),
        TOGGLE_EXPANDED: (ɵ8),
        EXPAND: (ɵ9),
        COLLAPSE: (ɵ10),
        DRILL_DOWN: (ɵ11),
        DRILL_UP: (ɵ12),
        NEXT_NODE: (ɵ13),
        PREVIOUS_NODE: (ɵ14),
        MOVE_NODE: (ɵ15)
    };
    /** @type {?} */
    var defaultActionMapping = {
        mouse: {
            click: TREE_ACTIONS.TOGGLE_ACTIVE,
            dblClick: null,
            contextMenu: null,
            expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,
            checkboxClick: TREE_ACTIONS.TOGGLE_SELECTED,
            drop: TREE_ACTIONS.MOVE_NODE
        },
        keys: (_a = {},
            _a[KEYS.RIGHT] = TREE_ACTIONS.DRILL_DOWN,
            _a[KEYS.LEFT] = TREE_ACTIONS.DRILL_UP,
            _a[KEYS.DOWN] = TREE_ACTIONS.NEXT_NODE,
            _a[KEYS.UP] = TREE_ACTIONS.PREVIOUS_NODE,
            _a[KEYS.SPACE] = TREE_ACTIONS.TOGGLE_ACTIVE,
            _a[KEYS.ENTER] = TREE_ACTIONS.TOGGLE_ACTIVE,
            _a)
    };
    /**
     * @record
     */
    function IActionMapping() { }
    if (false) {
        /** @type {?|undefined} */
        IActionMapping.prototype.mouse;
        /** @type {?|undefined} */
        IActionMapping.prototype.keys;
    }
    var TreeOptions = /** @class */ (function () {
        function TreeOptions(options) {
            if (options === void 0) { options = {}; }
            this.options = options;
            this.actionMapping = lodashEs.defaultsDeep({}, this.options.actionMapping, defaultActionMapping);
            if (options.rtl) {
                this.actionMapping.keys[KEYS.RIGHT] = (/** @type {?} */ (lodashEs.get(options, ['actionMapping', 'keys', KEYS.RIGHT]))) || TREE_ACTIONS.DRILL_UP;
                this.actionMapping.keys[KEYS.LEFT] = (/** @type {?} */ (lodashEs.get(options, ['actionMapping', 'keys', KEYS.LEFT]))) || TREE_ACTIONS.DRILL_DOWN;
            }
        }
        Object.defineProperty(TreeOptions.prototype, "hasChildrenField", {
            get: /**
             * @return {?}
             */
            function () { return this.options.hasChildrenField || 'hasChildren'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "childrenField", {
            get: /**
             * @return {?}
             */
            function () { return this.options.childrenField || 'children'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "displayField", {
            get: /**
             * @return {?}
             */
            function () { return this.options.displayField || 'name'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "idField", {
            get: /**
             * @return {?}
             */
            function () { return this.options.idField || 'id'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "isExpandedField", {
            get: /**
             * @return {?}
             */
            function () { return this.options.isExpandedField || 'isExpanded'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "getChildren", {
            get: /**
             * @return {?}
             */
            function () { return this.options.getChildren; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "levelPadding", {
            get: /**
             * @return {?}
             */
            function () { return this.options.levelPadding || 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "useVirtualScroll", {
            get: /**
             * @return {?}
             */
            function () { return this.options.useVirtualScroll; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "animateExpand", {
            get: /**
             * @return {?}
             */
            function () { return this.options.animateExpand; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "animateSpeed", {
            get: /**
             * @return {?}
             */
            function () { return this.options.animateSpeed || 1; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "animateAcceleration", {
            get: /**
             * @return {?}
             */
            function () { return this.options.animateAcceleration || 1.2; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "scrollOnActivate", {
            get: /**
             * @return {?}
             */
            function () { return this.options.scrollOnActivate === undefined ? true : this.options.scrollOnActivate; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "rtl", {
            get: /**
             * @return {?}
             */
            function () { return !!this.options.rtl; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "rootId", {
            get: /**
             * @return {?}
             */
            function () { return this.options.rootId; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "useCheckbox", {
            get: /**
             * @return {?}
             */
            function () { return this.options.useCheckbox; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "useTriState", {
            get: /**
             * @return {?}
             */
            function () { return this.options.useTriState === undefined ? true : this.options.useTriState; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "scrollContainer", {
            get: /**
             * @return {?}
             */
            function () { return this.options.scrollContainer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeOptions.prototype, "allowDragoverStyling", {
            get: /**
             * @return {?}
             */
            function () { return this.options.allowDragoverStyling === undefined ? true : this.options.allowDragoverStyling; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} node
         * @return {?}
         */
        TreeOptions.prototype.getNodeClone = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (this.options.getNodeClone) {
                return this.options.getNodeClone(node);
            }
            return lodashEs.omit(Object.assign({}, node.data), ['id']);
        };
        /**
         * @param {?} element
         * @param {?} to
         * @param {?=} $event
         * @return {?}
         */
        TreeOptions.prototype.allowDrop = /**
         * @param {?} element
         * @param {?} to
         * @param {?=} $event
         * @return {?}
         */
        function (element, to, $event) {
            if (this.options.allowDrop instanceof Function) {
                return this.options.allowDrop(element, to, $event);
            }
            else {
                return this.options.allowDrop === undefined ? true : this.options.allowDrop;
            }
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeOptions.prototype.allowDrag = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (this.options.allowDrag instanceof Function) {
                return this.options.allowDrag(node);
            }
            else {
                return this.options.allowDrag;
            }
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeOptions.prototype.nodeClass = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return this.options.nodeClass ? this.options.nodeClass(node) : '';
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeOptions.prototype.nodeHeight = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (node.data.virtual) {
                return 0;
            }
            /** @type {?} */
            var nodeHeight = this.options.nodeHeight || 22;
            if (typeof nodeHeight === 'function') {
                nodeHeight = nodeHeight(node);
            }
            // account for drop slots:
            return nodeHeight + (node.index === 0 ? 2 : 1) * this.dropSlotHeight;
        };
        Object.defineProperty(TreeOptions.prototype, "dropSlotHeight", {
            get: /**
             * @return {?}
             */
            function () {
                return lodashEs.isNumber(this.options.dropSlotHeight) ? this.options.dropSlotHeight : 2;
            },
            enumerable: true,
            configurable: true
        });
        return TreeOptions;
    }());
    if (false) {
        /** @type {?} */
        TreeOptions.prototype.actionMapping;
        /**
         * @type {?}
         * @private
         */
        TreeOptions.prototype.options;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/constants/events.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TREE_EVENTS = {
        toggleExpanded: 'toggleExpanded',
        activate: 'activate',
        deactivate: 'deactivate',
        nodeActivate: 'nodeActivate',
        nodeDeactivate: 'nodeDeactivate',
        select: 'select',
        deselect: 'deselect',
        focus: 'focus',
        blur: 'blur',
        initialized: 'initialized',
        updateData: 'updateData',
        moveNode: 'moveNode',
        copyNode: 'copyNode',
        event: 'event',
        loadNodeChildren: 'loadNodeChildren',
        changeFilter: 'changeFilter',
        stateChange: 'stateChange'
    };

    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __read = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (this && this.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    var TreeNode = /** @class */ (function () {
        function TreeNode(data, parent, treeModel, index) {
            var _this = this;
            this.data = data;
            this.parent = parent;
            this.treeModel = treeModel;
            this.position = 0;
            this.allowDrop = (/**
             * @param {?} element
             * @param {?=} $event
             * @return {?}
             */
            function (element, $event) {
                return _this.options.allowDrop(element, { parent: _this, index: 0 }, $event);
            });
            this.allowDragoverStyling = (/**
             * @return {?}
             */
            function () {
                return _this.options.allowDragoverStyling;
            });
            if (this.id === undefined || this.id === null) {
                this.id = uuid();
            } // Make sure there's a unique id without overriding existing ids to work with immutable data structures
            this.index = index;
            if (this.getField('children')) {
                this._initChildren();
            }
            this.autoLoadChildren();
        }
        Object.defineProperty(TreeNode.prototype, "isHidden", {
            get: /**
             * @return {?}
             */
            function () { return this.treeModel.isHidden(this); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeNode.prototype, "isExpanded", {
            get: /**
             * @return {?}
             */
            function () { return this.treeModel.isExpanded(this); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeNode.prototype, "isActive", {
            get: /**
             * @return {?}
             */
            function () { return this.treeModel.isActive(this); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeNode.prototype, "isFocused", {
            get: /**
             * @return {?}
             */
            function () { return this.treeModel.isNodeFocused(this); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeNode.prototype, "isSelected", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.isSelectable()) {
                    return this.treeModel.isSelected(this);
                }
                else {
                    return lodashEs.some(this.children, (/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return node.isSelected; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeNode.prototype, "isAllSelected", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.isSelectable()) {
                    return this.treeModel.isSelected(this);
                }
                else {
                    return lodashEs.every(this.children, (/**
                     * @param {?} node
                     * @return {?}
                     */
                    function (node) { return node.isAllSelected; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeNode.prototype, "isPartiallySelected", {
            get: /**
             * @return {?}
             */
            function () {
                return this.isSelected && !this.isAllSelected;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "level", {
            get: /**
             * @return {?}
             */
            function () {
                return this.parent ? this.parent.level + 1 : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "path", {
            get: /**
             * @return {?}
             */
            function () {
                return this.parent ? __spread(this.parent.path, [this.id]) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "elementRef", {
            get: /**
             * @return {?}
             */
            function () {
                throw "Element Ref is no longer supported since introducing virtual scroll\n\n      You may use a template to obtain a reference to the element";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "originalNode", {
            get: /**
             * @return {?}
             */
            function () { return this._originalNode; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeNode.prototype, "hasChildren", {
            // helper get functions:
            get: 
            // helper get functions:
            /**
             * @return {?}
             */
            function () {
                return !!(this.getField('hasChildren') || (this.children && this.children.length > 0));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "isCollapsed", {
            get: /**
             * @return {?}
             */
            function () { return !this.isExpanded; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "isLeaf", {
            get: /**
             * @return {?}
             */
            function () { return !this.hasChildren; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "isRoot", {
            get: /**
             * @return {?}
             */
            function () { return this.parent.data.virtual; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "realParent", {
            get: /**
             * @return {?}
             */
            function () { return this.isRoot ? null : this.parent; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "options", {
            // proxy functions:
            get: 
            // proxy functions:
            /**
             * @return {?}
             */
            function () { return this.treeModel.options; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        TreeNode.prototype.fireEvent = /**
         * @param {?} event
         * @return {?}
         */
        function (event) { this.treeModel.fireEvent(event); };
        Object.defineProperty(TreeNode.prototype, "displayField", {
            // field accessors:
            get: 
            // field accessors:
            /**
             * @return {?}
             */
            function () {
                return this.getField('display');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () {
                return this.getField('id');
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setField('id', value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} key
         * @return {?}
         */
        TreeNode.prototype.getField = /**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            return this.data[this.options[key + "Field"]];
        };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        TreeNode.prototype.setField = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        function (key, value) {
            this.data[this.options[key + "Field"]] = value;
        };
        // traversing:
        // traversing:
        /**
         * @param {?} steps
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype._findAdjacentSibling = 
        // traversing:
        /**
         * @param {?} steps
         * @param {?=} skipHidden
         * @return {?}
         */
        function (steps, skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            /** @type {?} */
            var siblings = this._getParentsChildren(skipHidden);
            /** @type {?} */
            var index = siblings.indexOf(this);
            return siblings.length > index + steps ? siblings[index + steps] : null;
        };
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype.findNextSibling = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            return this._findAdjacentSibling(+1, skipHidden);
        };
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype.findPreviousSibling = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            return this._findAdjacentSibling(-1, skipHidden);
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.getVisibleChildren = /**
         * @return {?}
         */
        function () {
            return this.visibleChildren;
        };
        Object.defineProperty(TreeNode.prototype, "visibleChildren", {
            get: /**
             * @return {?}
             */
            function () {
                return (this.children || []).filter((/**
                 * @param {?} node
                 * @return {?}
                 */
                function (node) { return !node.isHidden; }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype.getFirstChild = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            /** @type {?} */
            var children = skipHidden ? this.visibleChildren : this.children;
            return lodashEs.first(children || []);
        };
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype.getLastChild = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            /** @type {?} */
            var children = skipHidden ? this.visibleChildren : this.children;
            return lodashEs.last(children || []);
        };
        /**
         * @param {?=} goInside
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype.findNextNode = /**
         * @param {?=} goInside
         * @param {?=} skipHidden
         * @return {?}
         */
        function (goInside, skipHidden) {
            if (goInside === void 0) { goInside = true; }
            if (skipHidden === void 0) { skipHidden = false; }
            return goInside && this.isExpanded && this.getFirstChild(skipHidden) ||
                this.findNextSibling(skipHidden) ||
                this.parent && this.parent.findNextNode(false, skipHidden);
        };
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype.findPreviousNode = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            /** @type {?} */
            var previousSibling = this.findPreviousSibling(skipHidden);
            if (!previousSibling) {
                return this.realParent;
            }
            return previousSibling._getLastOpenDescendant(skipHidden);
        };
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype._getLastOpenDescendant = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            /** @type {?} */
            var lastChild = this.getLastChild(skipHidden);
            return (this.isCollapsed || !lastChild)
                ? this
                : lastChild._getLastOpenDescendant(skipHidden);
        };
        /**
         * @private
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype._getParentsChildren = /**
         * @private
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            /** @type {?} */
            var children = this.parent &&
                (skipHidden ? this.parent.getVisibleChildren() : this.parent.children);
            return children || [];
        };
        /**
         * @private
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeNode.prototype.getIndexInParent = /**
         * @private
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            return this._getParentsChildren(skipHidden).indexOf(this);
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeNode.prototype.isDescendantOf = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (this === node)
                return true;
            else
                return this.parent && this.parent.isDescendantOf(node);
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.getNodePadding = /**
         * @return {?}
         */
        function () {
            return this.options.levelPadding * (this.level - 1) + 'px';
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.getClass = /**
         * @return {?}
         */
        function () {
            return [this.options.nodeClass(this), "tree-node-level-" + this.level].join(' ');
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeNode.prototype.onDrop = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            this.mouseAction('drop', $event.event, {
                from: $event.element,
                to: { parent: this, index: 0, dropOnNode: true }
            });
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.allowDrag = /**
         * @return {?}
         */
        function () {
            return this.options.allowDrag(this);
        };
        // helper methods:
        // helper methods:
        /**
         * @return {?}
         */
        TreeNode.prototype.loadNodeChildren = 
        // helper methods:
        /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.options.getChildren) {
                return Promise.resolve(); // Not getChildren method - for using redux
            }
            return Promise.resolve(this.options.getChildren(this))
                .then((/**
             * @param {?} children
             * @return {?}
             */
            function (children) {
                if (children) {
                    _this.setField('children', children);
                    _this._initChildren();
                    if (_this.options.useTriState && _this.treeModel.isSelected(_this)) {
                        _this.setIsSelected(true);
                    }
                    _this.children.forEach((/**
                     * @param {?} child
                     * @return {?}
                     */
                    function (child) {
                        if (child.getField('isExpanded') && child.hasChildren) {
                            child.expand();
                        }
                    }));
                }
            })).then((/**
             * @return {?}
             */
            function () {
                _this.fireEvent({
                    eventName: TREE_EVENTS.loadNodeChildren,
                    node: _this
                });
            }));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        TreeNode.prototype.expand = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            if (!(/** @type {?} */ (this)).isExpanded) {
                (/** @type {?} */ (this)).toggleExpanded();
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        TreeNode.prototype.collapse = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            if ((/** @type {?} */ (this)).isExpanded) {
                (/** @type {?} */ (this)).toggleExpanded();
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        TreeNode.prototype.doForAll = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            var _this = this;
            Promise.resolve(fn(this)).then((/**
             * @return {?}
             */
            function () {
                if (_this.children) {
                    _this.children.forEach((/**
                     * @param {?} child
                     * @return {?}
                     */
                    function (child) { return child.doForAll(fn); }));
                }
            }));
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.expandAll = /**
         * @return {?}
         */
        function () {
            this.doForAll((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return node.expand(); }));
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.collapseAll = /**
         * @return {?}
         */
        function () {
            this.doForAll((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return node.collapse(); }));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        TreeNode.prototype.ensureVisible = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            if ((/** @type {?} */ (this)).realParent) {
                (/** @type {?} */ (this)).realParent.expand();
                (/** @type {?} */ (this)).realParent.ensureVisible();
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        TreeNode.prototype.toggleExpanded = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            (/** @type {?} */ (this)).setIsExpanded(!(/** @type {?} */ (this)).isExpanded);
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} value
         * @return {THIS}
         */
        TreeNode.prototype.setIsExpanded = /**
         * @template THIS
         * @this {THIS}
         * @param {?} value
         * @return {THIS}
         */
        function (value) {
            if ((/** @type {?} */ (this)).hasChildren) {
                (/** @type {?} */ (this)).treeModel.setExpandedNode((/** @type {?} */ (this)), value);
            }
            return (/** @type {?} */ (this));
        };
        ;
        /**
         * @return {?}
         */
        TreeNode.prototype.autoLoadChildren = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.handler =
                mobx.reaction((/**
                 * @return {?}
                 */
                function () { return _this.isExpanded; }), (/**
                 * @param {?} isExpanded
                 * @return {?}
                 */
                function (isExpanded) {
                    if (!_this.children && _this.hasChildren && isExpanded) {
                        _this.loadNodeChildren();
                    }
                }), { fireImmediately: true });
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.dispose = /**
         * @return {?}
         */
        function () {
            if (this.children) {
                this.children.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) { return child.dispose(); }));
            }
            if (this.handler) {
                this.handler();
            }
            this.parent = null;
            this.children = null;
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} value
         * @param {?=} multi
         * @return {THIS}
         */
        TreeNode.prototype.setIsActive = /**
         * @template THIS
         * @this {THIS}
         * @param {?} value
         * @param {?=} multi
         * @return {THIS}
         */
        function (value, multi) {
            if (multi === void 0) { multi = false; }
            (/** @type {?} */ (this)).treeModel.setActiveNode((/** @type {?} */ (this)), value, multi);
            if (value) {
                (/** @type {?} */ (this)).focus((/** @type {?} */ (this)).options.scrollOnActivate);
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.isSelectable = /**
         * @return {?}
         */
        function () {
            return this.isLeaf || !this.children || !this.options.useTriState;
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} value
         * @return {THIS}
         */
        TreeNode.prototype.setIsSelected = /**
         * @template THIS
         * @this {THIS}
         * @param {?} value
         * @return {THIS}
         */
        function (value) {
            if ((/** @type {?} */ (this)).isSelectable()) {
                (/** @type {?} */ (this)).treeModel.setSelectedNode((/** @type {?} */ (this)), value);
            }
            else {
                (/** @type {?} */ (this)).visibleChildren.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) { return child.setIsSelected(value); }));
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        TreeNode.prototype.toggleSelected = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            (/** @type {?} */ (this)).setIsSelected(!(/** @type {?} */ (this)).isSelected);
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?=} multi
         * @return {THIS}
         */
        TreeNode.prototype.toggleActivated = /**
         * @template THIS
         * @this {THIS}
         * @param {?=} multi
         * @return {THIS}
         */
        function (multi) {
            if (multi === void 0) { multi = false; }
            (/** @type {?} */ (this)).setIsActive(!(/** @type {?} */ (this)).isActive, multi);
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?=} multi
         * @return {THIS}
         */
        TreeNode.prototype.setActiveAndVisible = /**
         * @template THIS
         * @this {THIS}
         * @param {?=} multi
         * @return {THIS}
         */
        function (multi) {
            if (multi === void 0) { multi = false; }
            (/** @type {?} */ (this)).setIsActive(true, multi)
                .ensureVisible();
            setTimeout((/** @type {?} */ (this)).scrollIntoView.bind((/** @type {?} */ (this))));
            return (/** @type {?} */ (this));
        };
        /**
         * @param {?=} force
         * @return {?}
         */
        TreeNode.prototype.scrollIntoView = /**
         * @param {?=} force
         * @return {?}
         */
        function (force) {
            if (force === void 0) { force = false; }
            this.treeModel.virtualScroll.scrollIntoView(this, force);
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?=} scroll
         * @return {THIS}
         */
        TreeNode.prototype.focus = /**
         * @template THIS
         * @this {THIS}
         * @param {?=} scroll
         * @return {THIS}
         */
        function (scroll) {
            if (scroll === void 0) { scroll = true; }
            /** @type {?} */
            var previousNode = (/** @type {?} */ (this)).treeModel.getFocusedNode();
            (/** @type {?} */ (this)).treeModel.setFocusedNode((/** @type {?} */ (this)));
            if (scroll) {
                (/** @type {?} */ (this)).scrollIntoView();
            }
            if (previousNode) {
                (/** @type {?} */ (this)).fireEvent({ eventName: TREE_EVENTS.blur, node: previousNode });
            }
            (/** @type {?} */ (this)).fireEvent({ eventName: TREE_EVENTS.focus, node: (/** @type {?} */ (this)) });
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        TreeNode.prototype.blur = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            /** @type {?} */
            var previousNode = (/** @type {?} */ (this)).treeModel.getFocusedNode();
            (/** @type {?} */ (this)).treeModel.setFocusedNode(null);
            if (previousNode) {
                (/** @type {?} */ (this)).fireEvent({ eventName: TREE_EVENTS.blur, node: (/** @type {?} */ (this)) });
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @param {?} value
         * @return {?}
         */
        TreeNode.prototype.setIsHidden = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.treeModel.setIsHidden(this, value);
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.hide = /**
         * @return {?}
         */
        function () {
            this.setIsHidden(true);
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.show = /**
         * @return {?}
         */
        function () {
            this.setIsHidden(false);
        };
        /**
         * @param {?} actionName
         * @param {?} $event
         * @param {?=} data
         * @return {?}
         */
        TreeNode.prototype.mouseAction = /**
         * @param {?} actionName
         * @param {?} $event
         * @param {?=} data
         * @return {?}
         */
        function (actionName, $event, data) {
            if (data === void 0) { data = null; }
            this.treeModel.setFocus(true);
            /** @type {?} */
            var actionMapping = this.options.actionMapping.mouse;
            /** @type {?} */
            var action = actionMapping[actionName];
            if (action) {
                action(this.treeModel, this, $event, data);
            }
        };
        /**
         * @return {?}
         */
        TreeNode.prototype.getSelfHeight = /**
         * @return {?}
         */
        function () {
            return this.options.nodeHeight(this);
        };
        /**
         * @return {?}
         */
        TreeNode.prototype._initChildren = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.children = this.getField('children')
                .map((/**
             * @param {?} c
             * @param {?} index
             * @return {?}
             */
            function (c, index) { return new TreeNode(c, _this, _this.treeModel, index); }));
        };
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "isHidden", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "isExpanded", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "isActive", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "isFocused", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "isSelected", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "isAllSelected", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "isPartiallySelected", null);
        __decorate([
            mobx.observable,
            __metadata("design:type", Array)
        ], TreeNode.prototype, "children", void 0);
        __decorate([
            mobx.observable,
            __metadata("design:type", Number)
        ], TreeNode.prototype, "index", void 0);
        __decorate([
            mobx.observable,
            __metadata("design:type", Object)
        ], TreeNode.prototype, "position", void 0);
        __decorate([
            mobx.observable,
            __metadata("design:type", Number)
        ], TreeNode.prototype, "height", void 0);
        __decorate([
            mobx.computed,
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "level", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Array),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "path", null);
        __decorate([
            mobx.computed,
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], TreeNode.prototype, "visibleChildren", null);
        __decorate([
            mobx.action,
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], TreeNode.prototype, "setIsSelected", null);
        __decorate([
            mobx.action,
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TreeNode.prototype, "_initChildren", null);
        return TreeNode;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TreeNode.prototype.handler;
        /** @type {?} */
        TreeNode.prototype.children;
        /** @type {?} */
        TreeNode.prototype.index;
        /** @type {?} */
        TreeNode.prototype.position;
        /** @type {?} */
        TreeNode.prototype.height;
        /**
         * @type {?}
         * @private
         */
        TreeNode.prototype._originalNode;
        /** @type {?} */
        TreeNode.prototype.allowDrop;
        /** @type {?} */
        TreeNode.prototype.allowDragoverStyling;
        /** @type {?} */
        TreeNode.prototype.data;
        /** @type {?} */
        TreeNode.prototype.parent;
        /** @type {?} */
        TreeNode.prototype.treeModel;
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
    }
    /**
     * @return {?}
     */
    function uuid() {
        return Math.floor(Math.random() * 10000000000000);
    }

    var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$1 = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var TreeModel = /** @class */ (function () {
        function TreeModel() {
            this.options = new TreeOptions();
            this.eventNames = Object.keys(TREE_EVENTS);
            this.expandedNodeIds = {};
            this.selectedLeafNodeIds = {};
            this.activeNodeIds = {};
            this.hiddenNodeIds = {};
            this.focusedNodeId = null;
            this.firstUpdate = true;
            this.subscriptions = [];
        }
        // events
        // events
        /**
         * @param {?} event
         * @return {?}
         */
        TreeModel.prototype.fireEvent = 
        // events
        /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.treeModel = this;
            this.events[event.eventName].emit(event);
            this.events.event.emit(event);
        };
        /**
         * @param {?} eventName
         * @param {?} fn
         * @return {?}
         */
        TreeModel.prototype.subscribe = /**
         * @param {?} eventName
         * @param {?} fn
         * @return {?}
         */
        function (eventName, fn) {
            /** @type {?} */
            var subscription = this.events[eventName].subscribe(fn);
            this.subscriptions.push(subscription);
        };
        // getters
        // getters
        /**
         * @return {?}
         */
        TreeModel.prototype.getFocusedNode = 
        // getters
        /**
         * @return {?}
         */
        function () {
            return this.focusedNode;
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.getActiveNode = /**
         * @return {?}
         */
        function () {
            return this.activeNodes[0];
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.getActiveNodes = /**
         * @return {?}
         */
        function () {
            return this.activeNodes;
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.getVisibleRoots = /**
         * @return {?}
         */
        function () {
            return this.virtualRoot.visibleChildren;
        };
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeModel.prototype.getFirstRoot = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            return lodashEs.first(skipHidden ? this.getVisibleRoots() : this.roots);
        };
        /**
         * @param {?=} skipHidden
         * @return {?}
         */
        TreeModel.prototype.getLastRoot = /**
         * @param {?=} skipHidden
         * @return {?}
         */
        function (skipHidden) {
            if (skipHidden === void 0) { skipHidden = false; }
            return lodashEs.last(skipHidden ? this.getVisibleRoots() : this.roots);
        };
        Object.defineProperty(TreeModel.prototype, "isFocused", {
            get: /**
             * @return {?}
             */
            function () {
                return TreeModel.focusedTree === this;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} node
         * @return {?}
         */
        TreeModel.prototype.isNodeFocused = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return this.focusedNode === node;
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.isEmptyTree = /**
         * @return {?}
         */
        function () {
            return this.roots && this.roots.length === 0;
        };
        Object.defineProperty(TreeModel.prototype, "focusedNode", {
            get: /**
             * @return {?}
             */
            function () {
                return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeModel.prototype, "expandedNodes", {
            get: /**
             * @return {?}
             */
            function () {
                var _this = this;
                /** @type {?} */
                var nodes = Object.keys(this.expandedNodeIds)
                    .filter((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.expandedNodeIds[id]; }))
                    .map((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.getNodeById(id); }));
                return lodashEs.compact(nodes);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeModel.prototype, "activeNodes", {
            get: /**
             * @return {?}
             */
            function () {
                var _this = this;
                /** @type {?} */
                var nodes = Object.keys(this.activeNodeIds)
                    .filter((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.activeNodeIds[id]; }))
                    .map((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.getNodeById(id); }));
                return lodashEs.compact(nodes);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeModel.prototype, "hiddenNodes", {
            get: /**
             * @return {?}
             */
            function () {
                var _this = this;
                /** @type {?} */
                var nodes = Object.keys(this.hiddenNodeIds)
                    .filter((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.hiddenNodeIds[id]; }))
                    .map((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.getNodeById(id); }));
                return lodashEs.compact(nodes);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeModel.prototype, "selectedLeafNodes", {
            get: /**
             * @return {?}
             */
            function () {
                var _this = this;
                /** @type {?} */
                var nodes = Object.keys(this.selectedLeafNodeIds)
                    .filter((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.selectedLeafNodeIds[id]; }))
                    .map((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return _this.getNodeById(id); }));
                return lodashEs.compact(nodes);
            },
            enumerable: true,
            configurable: true
        });
        // locating nodes
        // locating nodes
        /**
         * @param {?} path
         * @param {?=} startNode
         * @return {?}
         */
        TreeModel.prototype.getNodeByPath = 
        // locating nodes
        /**
         * @param {?} path
         * @param {?=} startNode
         * @return {?}
         */
        function (path, startNode) {
            if (startNode === void 0) { startNode = null; }
            if (!path)
                return null;
            startNode = startNode || this.virtualRoot;
            if (path.length === 0)
                return startNode;
            if (!startNode.children)
                return null;
            /** @type {?} */
            var childId = path.shift();
            /** @type {?} */
            var childNode = lodashEs.find(startNode.children, { id: childId });
            if (!childNode)
                return null;
            return this.getNodeByPath(path, childNode);
        };
        /**
         * @param {?} id
         * @return {?}
         */
        TreeModel.prototype.getNodeById = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            /** @type {?} */
            var idStr = id.toString();
            return this.getNodeBy((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return node.id.toString() === idStr; }));
        };
        /**
         * @param {?} predicate
         * @param {?=} startNode
         * @return {?}
         */
        TreeModel.prototype.getNodeBy = /**
         * @param {?} predicate
         * @param {?=} startNode
         * @return {?}
         */
        function (predicate, startNode) {
            var e_1, _a;
            if (startNode === void 0) { startNode = null; }
            startNode = startNode || this.virtualRoot;
            if (!startNode.children)
                return null;
            /** @type {?} */
            var found = lodashEs.find(startNode.children, predicate);
            if (found) { // found in children
                return found;
            }
            else { // look in children's children
                try {
                    for (var _b = __values(startNode.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        /** @type {?} */
                        var foundInChildren = this.getNodeBy(predicate, child);
                        if (foundInChildren)
                            return foundInChildren;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeModel.prototype.isExpanded = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return this.expandedNodeIds[node.id];
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeModel.prototype.isHidden = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return this.hiddenNodeIds[node.id];
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeModel.prototype.isActive = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return this.activeNodeIds[node.id];
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeModel.prototype.isSelected = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return this.selectedLeafNodeIds[node.id];
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.dispose();
            this.unsubscribeAll();
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.dispose = /**
         * @return {?}
         */
        function () {
            // Dispose reactions of the replaced nodes
            if (this.virtualRoot) {
                this.virtualRoot.dispose();
            }
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.unsubscribeAll = /**
         * @return {?}
         */
        function () {
            this.subscriptions.forEach((/**
             * @param {?} subscription
             * @return {?}
             */
            function (subscription) { return subscription.unsubscribe(); }));
            this.subscriptions = [];
        };
        // actions
        // actions
        /**
         * @param {?} __0
         * @return {?}
         */
        TreeModel.prototype.setData = 
        // actions
        /**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var nodes = _a.nodes, _b = _a.options, options = _b === void 0 ? null : _b, _c = _a.events, events = _c === void 0 ? null : _c;
            if (options) {
                this.options = new TreeOptions(options);
            }
            if (events) {
                this.events = events;
            }
            if (nodes) {
                this.nodes = nodes;
            }
            this.update();
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.update = /**
         * @return {?}
         */
        function () {
            var _a;
            // Rebuild tree:
            /** @type {?} */
            var virtualRootConfig = (_a = {
                    id: this.options.rootId,
                    virtual: true
                },
                _a[this.options.childrenField] = this.nodes,
                _a);
            this.dispose();
            this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);
            this.roots = this.virtualRoot.children;
            // Fire event:
            if (this.firstUpdate) {
                if (this.roots) {
                    this.firstUpdate = false;
                    this._calculateExpandedNodes();
                }
            }
            else {
                this.fireEvent({ eventName: TREE_EVENTS.updateData });
            }
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TreeModel.prototype.setFocusedNode = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            this.focusedNodeId = node ? node.id : null;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        TreeModel.prototype.setFocus = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            TreeModel.focusedTree = value ? this : null;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        TreeModel.prototype.doForAll = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.roots.forEach((/**
             * @param {?} root
             * @return {?}
             */
            function (root) { return root.doForAll(fn); }));
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.focusNextNode = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var previousNode = this.getFocusedNode();
            /** @type {?} */
            var nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);
            if (nextNode)
                nextNode.focus();
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.focusPreviousNode = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var previousNode = this.getFocusedNode();
            /** @type {?} */
            var nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);
            if (nextNode)
                nextNode.focus();
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.focusDrillDown = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var previousNode = this.getFocusedNode();
            if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {
                previousNode.toggleExpanded();
            }
            else {
                /** @type {?} */
                var nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);
                if (nextNode)
                    nextNode.focus();
            }
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.focusDrillUp = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var previousNode = this.getFocusedNode();
            if (!previousNode)
                return;
            if (previousNode.isExpanded) {
                previousNode.toggleExpanded();
            }
            else {
                /** @type {?} */
                var nextNode = previousNode.realParent;
                if (nextNode)
                    nextNode.focus();
            }
        };
        /**
         * @param {?} node
         * @param {?} value
         * @param {?=} multi
         * @return {?}
         */
        TreeModel.prototype.setActiveNode = /**
         * @param {?} node
         * @param {?} value
         * @param {?=} multi
         * @return {?}
         */
        function (node, value, multi) {
            if (multi === void 0) { multi = false; }
            if (multi) {
                this._setActiveNodeMulti(node, value);
            }
            else {
                this._setActiveNodeSingle(node, value);
            }
            if (value) {
                node.focus(this.options.scrollOnActivate);
                this.fireEvent({ eventName: TREE_EVENTS.activate, node: node });
                this.fireEvent({ eventName: TREE_EVENTS.nodeActivate, node: node }); // For IE11
            }
            else {
                this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: node });
                this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node: node }); // For IE11
            }
        };
        /**
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        TreeModel.prototype.setSelectedNode = /**
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        function (node, value) {
            var _a;
            this.selectedLeafNodeIds = Object.assign({}, this.selectedLeafNodeIds, (_a = {}, _a[node.id] = value, _a));
            if (value) {
                node.focus();
                this.fireEvent({ eventName: TREE_EVENTS.select, node: node });
            }
            else {
                this.fireEvent({ eventName: TREE_EVENTS.deselect, node: node });
            }
        };
        /**
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        TreeModel.prototype.setExpandedNode = /**
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        function (node, value) {
            var _a;
            this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, (_a = {}, _a[node.id] = value, _a));
            this.fireEvent({ eventName: TREE_EVENTS.toggleExpanded, node: node, isExpanded: value });
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.expandAll = /**
         * @return {?}
         */
        function () {
            this.roots.forEach((/**
             * @param {?} root
             * @return {?}
             */
            function (root) { return root.expandAll(); }));
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.collapseAll = /**
         * @return {?}
         */
        function () {
            this.roots.forEach((/**
             * @param {?} root
             * @return {?}
             */
            function (root) { return root.collapseAll(); }));
        };
        /**
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        TreeModel.prototype.setIsHidden = /**
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        function (node, value) {
            var _a;
            this.hiddenNodeIds = Object.assign({}, this.hiddenNodeIds, (_a = {}, _a[node.id] = value, _a));
        };
        /**
         * @param {?} nodeIds
         * @return {?}
         */
        TreeModel.prototype.setHiddenNodeIds = /**
         * @param {?} nodeIds
         * @return {?}
         */
        function (nodeIds) {
            this.hiddenNodeIds = nodeIds.reduce((/**
             * @param {?} hiddenNodeIds
             * @param {?} id
             * @return {?}
             */
            function (hiddenNodeIds, id) {
                var _a;
                return Object.assign(hiddenNodeIds, (_a = {},
                    _a[id] = true,
                    _a));
            }), {});
        };
        /**
         * @param {?} node
         * @param {?} $event
         * @return {?}
         */
        TreeModel.prototype.performKeyAction = /**
         * @param {?} node
         * @param {?} $event
         * @return {?}
         */
        function (node, $event) {
            /** @type {?} */
            var action = this.options.actionMapping.keys[$event.keyCode];
            if (action) {
                $event.preventDefault();
                action(this, node, $event);
                return true;
            }
            else {
                return false;
            }
        };
        /**
         * @param {?} filter
         * @param {?=} autoShow
         * @return {?}
         */
        TreeModel.prototype.filterNodes = /**
         * @param {?} filter
         * @param {?=} autoShow
         * @return {?}
         */
        function (filter, autoShow) {
            var _this = this;
            if (autoShow === void 0) { autoShow = true; }
            /** @type {?} */
            var filterFn;
            if (!filter) {
                return this.clearFilter();
            }
            // support function and string filter
            if (lodashEs.isString(filter)) {
                filterFn = (/**
                 * @param {?} node
                 * @return {?}
                 */
                function (node) { return node.displayField.toLowerCase().indexOf(filter.toLowerCase()) !== -1; });
            }
            else if (lodashEs.isFunction(filter)) {
                filterFn = filter;
            }
            else {
                console.error('Don\'t know what to do with filter', filter);
                console.error('Should be either a string or function');
                return;
            }
            /** @type {?} */
            var ids = {};
            this.roots.forEach((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return _this._filterNode(ids, node, filterFn, autoShow); }));
            this.hiddenNodeIds = ids;
            this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.clearFilter = /**
         * @return {?}
         */
        function () {
            this.hiddenNodeIds = {};
            this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
        };
        /**
         * @param {?} node
         * @param {?} to
         * @return {?}
         */
        TreeModel.prototype.moveNode = /**
         * @param {?} node
         * @param {?} to
         * @return {?}
         */
        function (node, to) {
            /** @type {?} */
            var fromIndex = node.getIndexInParent();
            /** @type {?} */
            var fromParent = node.parent;
            if (!this.canMoveNode(node, to, fromIndex))
                return;
            /** @type {?} */
            var fromChildren = fromParent.getField('children');
            // If node doesn't have children - create children array
            if (!to.parent.getField('children')) {
                to.parent.setField('children', []);
            }
            /** @type {?} */
            var toChildren = to.parent.getField('children');
            /** @type {?} */
            var originalNode = fromChildren.splice(fromIndex, 1)[0];
            // Compensate for index if already removed from parent:
            /** @type {?} */
            var toIndex = (fromParent === to.parent && to.index > fromIndex) ? to.index - 1 : to.index;
            toChildren.splice(toIndex, 0, originalNode);
            fromParent.treeModel.update();
            if (to.parent.treeModel !== fromParent.treeModel) {
                to.parent.treeModel.update();
            }
            this.fireEvent({
                eventName: TREE_EVENTS.moveNode,
                node: originalNode,
                to: { parent: to.parent.data, index: toIndex },
                from: { parent: fromParent.data, index: fromIndex }
            });
        };
        /**
         * @param {?} node
         * @param {?} to
         * @return {?}
         */
        TreeModel.prototype.copyNode = /**
         * @param {?} node
         * @param {?} to
         * @return {?}
         */
        function (node, to) {
            /** @type {?} */
            var fromIndex = node.getIndexInParent();
            if (!this.canMoveNode(node, to, fromIndex))
                return;
            // If node doesn't have children - create children array
            if (!to.parent.getField('children')) {
                to.parent.setField('children', []);
            }
            /** @type {?} */
            var toChildren = to.parent.getField('children');
            /** @type {?} */
            var nodeCopy = this.options.getNodeClone(node);
            toChildren.splice(to.index, 0, nodeCopy);
            node.treeModel.update();
            if (to.parent.treeModel !== node.treeModel) {
                to.parent.treeModel.update();
            }
            this.fireEvent({ eventName: TREE_EVENTS.copyNode, node: nodeCopy, to: { parent: to.parent.data, index: to.index } });
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.getState = /**
         * @return {?}
         */
        function () {
            return {
                expandedNodeIds: this.expandedNodeIds,
                selectedLeafNodeIds: this.selectedLeafNodeIds,
                activeNodeIds: this.activeNodeIds,
                hiddenNodeIds: this.hiddenNodeIds,
                focusedNodeId: this.focusedNodeId
            };
        };
        /**
         * @param {?} state
         * @return {?}
         */
        TreeModel.prototype.setState = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            if (!state)
                return;
            Object.assign(this, {
                expandedNodeIds: state.expandedNodeIds || {},
                selectedLeafNodeIds: state.selectedLeafNodeIds || {},
                activeNodeIds: state.activeNodeIds || {},
                hiddenNodeIds: state.hiddenNodeIds || {},
                focusedNodeId: state.focusedNodeId
            });
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        TreeModel.prototype.subscribeToState = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            var _this = this;
            mobx.autorun((/**
             * @return {?}
             */
            function () { return fn(_this.getState()); }));
        };
        /**
         * @param {?} node
         * @param {?} to
         * @param {?=} fromIndex
         * @return {?}
         */
        TreeModel.prototype.canMoveNode = /**
         * @param {?} node
         * @param {?} to
         * @param {?=} fromIndex
         * @return {?}
         */
        function (node, to, fromIndex) {
            if (fromIndex === void 0) { fromIndex = undefined; }
            /** @type {?} */
            var fromNodeIndex = fromIndex || node.getIndexInParent();
            // same node:
            if (node.parent === to.parent && fromIndex === to.index) {
                return false;
            }
            return !to.parent.isDescendantOf(node);
        };
        /**
         * @return {?}
         */
        TreeModel.prototype.calculateExpandedNodes = /**
         * @return {?}
         */
        function () {
            this._calculateExpandedNodes();
        };
        // private methods
        // private methods
        /**
         * @private
         * @param {?} ids
         * @param {?} node
         * @param {?} filterFn
         * @param {?} autoShow
         * @return {?}
         */
        TreeModel.prototype._filterNode = 
        // private methods
        /**
         * @private
         * @param {?} ids
         * @param {?} node
         * @param {?} filterFn
         * @param {?} autoShow
         * @return {?}
         */
        function (ids, node, filterFn, autoShow) {
            var _this = this;
            // if node passes function then it's visible
            /** @type {?} */
            var isVisible = filterFn(node);
            if (node.children) {
                // if one of node's children passes filter then this node is also visible
                node.children.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) {
                    if (_this._filterNode(ids, child, filterFn, autoShow)) {
                        isVisible = true;
                    }
                }));
            }
            // mark node as hidden
            if (!isVisible) {
                ids[node.id] = true;
            }
            // auto expand parents to make sure the filtered nodes are visible
            if (autoShow && isVisible) {
                node.ensureVisible();
            }
            return isVisible;
        };
        /**
         * @private
         * @param {?=} startNode
         * @return {?}
         */
        TreeModel.prototype._calculateExpandedNodes = /**
         * @private
         * @param {?=} startNode
         * @return {?}
         */
        function (startNode) {
            var _a;
            var _this = this;
            if (startNode === void 0) { startNode = null; }
            startNode = startNode || this.virtualRoot;
            if (startNode.data[this.options.isExpandedField]) {
                this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, (_a = {}, _a[startNode.id] = true, _a));
            }
            if (startNode.children) {
                startNode.children.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) { return _this._calculateExpandedNodes(child); }));
            }
        };
        /**
         * @private
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        TreeModel.prototype._setActiveNodeSingle = /**
         * @private
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        function (node, value) {
            var _a;
            var _this = this;
            // Deactivate all other nodes:
            this.activeNodes
                .filter((/**
             * @param {?} activeNode
             * @return {?}
             */
            function (activeNode) { return activeNode !== node; }))
                .forEach((/**
             * @param {?} activeNode
             * @return {?}
             */
            function (activeNode) {
                _this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode });
                _this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node: activeNode }); // For IE11
            }));
            if (value) {
                this.activeNodeIds = (_a = {}, _a[node.id] = true, _a);
            }
            else {
                this.activeNodeIds = {};
            }
        };
        /**
         * @private
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        TreeModel.prototype._setActiveNodeMulti = /**
         * @private
         * @param {?} node
         * @param {?} value
         * @return {?}
         */
        function (node, value) {
            var _a;
            this.activeNodeIds = Object.assign({}, this.activeNodeIds, (_a = {}, _a[node.id] = value, _a));
        };
        TreeModel.focusedTree = null;
        TreeModel.decorators = [
            { type: core.Injectable }
        ];
        __decorate$1([
            mobx.observable,
            __metadata$1("design:type", Array)
        ], TreeModel.prototype, "roots", void 0);
        __decorate$1([
            mobx.observable,
            __metadata$1("design:type", Object)
        ], TreeModel.prototype, "expandedNodeIds", void 0);
        __decorate$1([
            mobx.observable,
            __metadata$1("design:type", Object)
        ], TreeModel.prototype, "selectedLeafNodeIds", void 0);
        __decorate$1([
            mobx.observable,
            __metadata$1("design:type", Object)
        ], TreeModel.prototype, "activeNodeIds", void 0);
        __decorate$1([
            mobx.observable,
            __metadata$1("design:type", Object)
        ], TreeModel.prototype, "hiddenNodeIds", void 0);
        __decorate$1([
            mobx.observable,
            __metadata$1("design:type", Object)
        ], TreeModel.prototype, "focusedNodeId", void 0);
        __decorate$1([
            mobx.observable,
            __metadata$1("design:type", TreeNode)
        ], TreeModel.prototype, "virtualRoot", void 0);
        __decorate$1([
            mobx.computed,
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [])
        ], TreeModel.prototype, "focusedNode", null);
        __decorate$1([
            mobx.computed,
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [])
        ], TreeModel.prototype, "expandedNodes", null);
        __decorate$1([
            mobx.computed,
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [])
        ], TreeModel.prototype, "activeNodes", null);
        __decorate$1([
            mobx.computed,
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [])
        ], TreeModel.prototype, "hiddenNodes", null);
        __decorate$1([
            mobx.computed,
            __metadata$1("design:type", Object),
            __metadata$1("design:paramtypes", [])
        ], TreeModel.prototype, "selectedLeafNodes", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setData", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "update", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setFocusedNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setFocus", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "doForAll", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "focusNextNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "focusPreviousNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "focusDrillDown", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "focusDrillUp", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object, Object, Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setActiveNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object, Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setSelectedNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object, Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setExpandedNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "expandAll", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "collapseAll", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object, Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setIsHidden", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setHiddenNodeIds", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object, Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "filterNodes", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", []),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "clearFilter", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object, Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "moveNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object, Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "copyNode", null);
        __decorate$1([
            mobx.action,
            __metadata$1("design:type", Function),
            __metadata$1("design:paramtypes", [Object]),
            __metadata$1("design:returntype", void 0)
        ], TreeModel.prototype, "setState", null);
        return TreeModel;
    }());
    if (false) {
        /** @type {?} */
        TreeModel.focusedTree;
        /** @type {?} */
        TreeModel.prototype.options;
        /** @type {?} */
        TreeModel.prototype.nodes;
        /** @type {?} */
        TreeModel.prototype.eventNames;
        /** @type {?} */
        TreeModel.prototype.virtualScroll;
        /** @type {?} */
        TreeModel.prototype.roots;
        /** @type {?} */
        TreeModel.prototype.expandedNodeIds;
        /** @type {?} */
        TreeModel.prototype.selectedLeafNodeIds;
        /** @type {?} */
        TreeModel.prototype.activeNodeIds;
        /** @type {?} */
        TreeModel.prototype.hiddenNodeIds;
        /** @type {?} */
        TreeModel.prototype.focusedNodeId;
        /** @type {?} */
        TreeModel.prototype.virtualRoot;
        /**
         * @type {?}
         * @private
         */
        TreeModel.prototype.firstUpdate;
        /**
         * @type {?}
         * @private
         */
        TreeModel.prototype.events;
        /**
         * @type {?}
         * @private
         */
        TreeModel.prototype.subscriptions;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/models/tree-dragged-element.model.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeDraggedElement = /** @class */ (function () {
        function TreeDraggedElement() {
            this._draggedElement = null;
        }
        /**
         * @param {?} draggedElement
         * @return {?}
         */
        TreeDraggedElement.prototype.set = /**
         * @param {?} draggedElement
         * @return {?}
         */
        function (draggedElement) {
            this._draggedElement = draggedElement;
        };
        /**
         * @return {?}
         */
        TreeDraggedElement.prototype.get = /**
         * @return {?}
         */
        function () {
            return this._draggedElement;
        };
        /**
         * @return {?}
         */
        TreeDraggedElement.prototype.isDragging = /**
         * @return {?}
         */
        function () {
            return !!this.get();
        };
        TreeDraggedElement.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ TreeDraggedElement.ɵprov = core.ɵɵdefineInjectable({ factory: function TreeDraggedElement_Factory() { return new TreeDraggedElement(); }, token: TreeDraggedElement, providedIn: "root" });
        return TreeDraggedElement;
    }());
    if (false) {
        /** @type {?} */
        TreeDraggedElement.prototype._draggedElement;
    }

    var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$2 = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __read$1 = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread$1 = (this && this.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$1(arguments[i]));
        return ar;
    };
    /** @type {?} */
    var Y_OFFSET = 500;
    // Extra pixels outside the viewport, in each direction, to render nodes in
    /** @type {?} */
    var Y_EPSILON = 150;
    // Minimum pixel change required to recalculate the rendered nodes
    var TreeVirtualScroll = /** @class */ (function () {
        function TreeVirtualScroll(treeModel) {
            var _this = this;
            this.treeModel = treeModel;
            this.yBlocks = 0;
            this.x = 0;
            this.viewportHeight = null;
            this.viewport = null;
            treeModel.virtualScroll = this;
            this._dispose = [mobx.autorun((/**
                 * @return {?}
                 */
                function () { return _this.fixScroll(); }))];
        }
        Object.defineProperty(TreeVirtualScroll.prototype, "y", {
            get: /**
             * @return {?}
             */
            function () {
                return this.yBlocks * Y_EPSILON;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeVirtualScroll.prototype, "totalHeight", {
            get: /**
             * @return {?}
             */
            function () {
                return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        TreeVirtualScroll.prototype.fireEvent = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.treeModel.fireEvent(event);
        };
        /**
         * @return {?}
         */
        TreeVirtualScroll.prototype.init = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var fn = this.recalcPositions.bind(this);
            fn();
            this._dispose = __spread$1(this._dispose, [
                mobx.reaction((/**
                 * @return {?}
                 */
                function () { return _this.treeModel.roots; }), fn),
                mobx.reaction((/**
                 * @return {?}
                 */
                function () { return _this.treeModel.expandedNodeIds; }), fn),
                mobx.reaction((/**
                 * @return {?}
                 */
                function () { return _this.treeModel.hiddenNodeIds; }), fn)
            ]);
            this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);
        };
        /**
         * @return {?}
         */
        TreeVirtualScroll.prototype.isEnabled = /**
         * @return {?}
         */
        function () {
            return this.treeModel.options.useVirtualScroll;
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        TreeVirtualScroll.prototype._setYBlocks = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.yBlocks = value;
        };
        /**
         * @return {?}
         */
        TreeVirtualScroll.prototype.recalcPositions = /**
         * @return {?}
         */
        function () {
            this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);
        };
        /**
         * @private
         * @param {?} nodes
         * @param {?} startPos
         * @return {?}
         */
        TreeVirtualScroll.prototype._getPositionAfter = /**
         * @private
         * @param {?} nodes
         * @param {?} startPos
         * @return {?}
         */
        function (nodes, startPos) {
            var _this = this;
            /** @type {?} */
            var position = startPos;
            nodes.forEach((/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                node.position = position;
                position = _this._getPositionAfterNode(node, position);
            }));
            return position;
        };
        /**
         * @private
         * @param {?} node
         * @param {?} startPos
         * @return {?}
         */
        TreeVirtualScroll.prototype._getPositionAfterNode = /**
         * @private
         * @param {?} node
         * @param {?} startPos
         * @return {?}
         */
        function (node, startPos) {
            /** @type {?} */
            var position = node.getSelfHeight() + startPos;
            if (node.children && node.isExpanded) { // TBD: consider loading component as well
                position = this._getPositionAfter(node.visibleChildren, position);
            }
            node.height = position - startPos;
            return position;
        };
        /**
         * @return {?}
         */
        TreeVirtualScroll.prototype.clear = /**
         * @return {?}
         */
        function () {
            this._dispose.forEach((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return d(); }));
        };
        /**
         * @param {?} viewport
         * @return {?}
         */
        TreeVirtualScroll.prototype.setViewport = /**
         * @param {?} viewport
         * @return {?}
         */
        function (viewport) {
            Object.assign(this, {
                viewport: viewport,
                x: viewport.scrollLeft,
                yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),
                viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0
            });
        };
        /**
         * @param {?} node
         * @param {?} force
         * @param {?=} scrollToMiddle
         * @return {?}
         */
        TreeVirtualScroll.prototype.scrollIntoView = /**
         * @param {?} node
         * @param {?} force
         * @param {?=} scrollToMiddle
         * @return {?}
         */
        function (node, force, scrollToMiddle) {
            if (scrollToMiddle === void 0) { scrollToMiddle = true; }
            if (node.options.scrollContainer) {
                /** @type {?} */
                var scrollContainer = node.options.scrollContainer;
                /** @type {?} */
                var scrollContainerHeight = scrollContainer.getBoundingClientRect().height;
                /** @type {?} */
                var scrollContainerTop = scrollContainer.getBoundingClientRect().top;
                /** @type {?} */
                var nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;
                if (force || // force scroll to node
                    nodeTop < scrollContainer.scrollTop || // node is above scroll container
                    nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) { // node is below container
                    scrollContainer.scrollTop = scrollToMiddle ?
                        nodeTop - scrollContainerHeight / 2 : // scroll to middle
                        nodeTop; // scroll to start
                }
            }
            else {
                if (force || // force scroll to node
                    node.position < this.y || // node is above viewport
                    node.position + node.getSelfHeight() > this.y + this.viewportHeight) { // node is below viewport
                    if (this.viewport) {
                        this.viewport.scrollTop = scrollToMiddle ?
                            node.position - this.viewportHeight / 2 : // scroll to middle
                            node.position; // scroll to start
                        this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));
                    }
                }
            }
        };
        /**
         * @param {?} nodes
         * @return {?}
         */
        TreeVirtualScroll.prototype.getViewportNodes = /**
         * @param {?} nodes
         * @return {?}
         */
        function (nodes) {
            var _this = this;
            if (!nodes)
                return [];
            /** @type {?} */
            var visibleNodes = nodes.filter((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return !node.isHidden; }));
            if (!this.isEnabled())
                return visibleNodes;
            if (!this.viewportHeight || !visibleNodes.length)
                return [];
            // Search for first node in the viewport using binary search
            // Look for first node that starts after the beginning of the viewport (with buffer)
            // Or that ends after the beginning of the viewport
            /** @type {?} */
            var firstIndex = binarySearch(visibleNodes, (/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                return (node.position + Y_OFFSET > _this.y) ||
                    (node.position + node.height > _this.y);
            }));
            // Search for last node in the viewport using binary search
            // Look for first node that starts after the end of the viewport (with buffer)
            /** @type {?} */
            var lastIndex = binarySearch(visibleNodes, (/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                return node.position - Y_OFFSET > _this.y + _this.viewportHeight;
            }), firstIndex);
            /** @type {?} */
            var viewportNodes = [];
            // Loading async top nodes' children is too long.
            // It happens when first node is visible withing viewport range (including Y_OFFSET).
            // In that case firstIndex == 0 and lastIndex == visibleNodes.length - 1 (e.g. 1000),
            // which means that it loops through every visibleNodes item and push them into viewportNodes array.
            // lastIndex should not equal visibleNodes.length - 1, but something around 50-100 (depending on the viewport)
            /** @type {?} */
            var nodeHeight = visibleNodes[0].treeModel.options.options.nodeHeight;
            /** @type {?} */
            var renderedNodesMaxLength = (Y_OFFSET * 2 + this.viewportHeight) / nodeHeight;
            // Something is probably wrong, prevent nodes from being pushed to an array.
            if (lastIndex - firstIndex > renderedNodesMaxLength) {
                return [];
            }
            for (var i = firstIndex; i <= lastIndex; i++) {
                viewportNodes.push(visibleNodes[i]);
            }
            return viewportNodes;
        };
        /**
         * @return {?}
         */
        TreeVirtualScroll.prototype.fixScroll = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var maxY = Math.max(0, this.totalHeight - this.viewportHeight);
            if (this.y < 0)
                this._setYBlocks(0);
            if (this.y > maxY)
                this._setYBlocks(maxY / Y_EPSILON);
        };
        TreeVirtualScroll.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        TreeVirtualScroll.ctorParameters = function () { return [
            { type: TreeModel }
        ]; };
        __decorate$2([
            mobx.observable,
            __metadata$2("design:type", Object)
        ], TreeVirtualScroll.prototype, "yBlocks", void 0);
        __decorate$2([
            mobx.observable,
            __metadata$2("design:type", Object)
        ], TreeVirtualScroll.prototype, "x", void 0);
        __decorate$2([
            mobx.observable,
            __metadata$2("design:type", Object)
        ], TreeVirtualScroll.prototype, "viewportHeight", void 0);
        __decorate$2([
            mobx.computed,
            __metadata$2("design:type", Object),
            __metadata$2("design:paramtypes", [])
        ], TreeVirtualScroll.prototype, "y", null);
        __decorate$2([
            mobx.computed,
            __metadata$2("design:type", Object),
            __metadata$2("design:paramtypes", [])
        ], TreeVirtualScroll.prototype, "totalHeight", null);
        __decorate$2([
            mobx.action,
            __metadata$2("design:type", Function),
            __metadata$2("design:paramtypes", [Object]),
            __metadata$2("design:returntype", void 0)
        ], TreeVirtualScroll.prototype, "_setYBlocks", null);
        __decorate$2([
            mobx.action,
            __metadata$2("design:type", Function),
            __metadata$2("design:paramtypes", []),
            __metadata$2("design:returntype", void 0)
        ], TreeVirtualScroll.prototype, "recalcPositions", null);
        __decorate$2([
            mobx.action,
            __metadata$2("design:type", Function),
            __metadata$2("design:paramtypes", [Object]),
            __metadata$2("design:returntype", void 0)
        ], TreeVirtualScroll.prototype, "setViewport", null);
        __decorate$2([
            mobx.action,
            __metadata$2("design:type", Function),
            __metadata$2("design:paramtypes", [Object, Object, Object]),
            __metadata$2("design:returntype", void 0)
        ], TreeVirtualScroll.prototype, "scrollIntoView", null);
        return TreeVirtualScroll;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TreeVirtualScroll.prototype._dispose;
        /** @type {?} */
        TreeVirtualScroll.prototype.yBlocks;
        /** @type {?} */
        TreeVirtualScroll.prototype.x;
        /** @type {?} */
        TreeVirtualScroll.prototype.viewportHeight;
        /** @type {?} */
        TreeVirtualScroll.prototype.viewport;
        /**
         * @type {?}
         * @private
         */
        TreeVirtualScroll.prototype.treeModel;
    }
    /**
     * @param {?} nodes
     * @param {?} condition
     * @param {?=} firstIndex
     * @return {?}
     */
    function binarySearch(nodes, condition, firstIndex) {
        if (firstIndex === void 0) { firstIndex = 0; }
        /** @type {?} */
        var index = firstIndex;
        /** @type {?} */
        var toIndex = nodes.length - 1;
        while (index !== toIndex) {
            /** @type {?} */
            var midIndex = Math.floor((index + toIndex) / 2);
            if (condition(nodes[midIndex])) {
                toIndex = midIndex;
            }
            else {
                if (index === midIndex)
                    index = toIndex;
                else
                    index = midIndex;
            }
        }
        return index;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/loading.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LoadingComponent = /** @class */ (function () {
        function LoadingComponent() {
        }
        LoadingComponent.decorators = [
            { type: core.Component, args: [{
                        encapsulation: core.ViewEncapsulation.None,
                        selector: 'tree-loading-component',
                        template: "\n    <span *ngIf=\"!template\">loading...</span>\n    <ng-container\n      [ngTemplateOutlet]=\"template\"\n      [ngTemplateOutletContext]=\"{ $implicit: node }\">\n    </ng-container>\n  "
                    }] }
        ];
        LoadingComponent.propDecorators = {
            template: [{ type: core.Input }],
            node: [{ type: core.Input }]
        };
        return LoadingComponent;
    }());
    if (false) {
        /** @type {?} */
        LoadingComponent.prototype.template;
        /** @type {?} */
        LoadingComponent.prototype.node;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-viewport.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeViewportComponent = /** @class */ (function () {
        function TreeViewportComponent(elementRef, ngZone, virtualScroll) {
            var _this = this;
            this.elementRef = elementRef;
            this.ngZone = ngZone;
            this.virtualScroll = virtualScroll;
            this.setViewport = lodashEs.throttle((/**
             * @return {?}
             */
            function () {
                _this.virtualScroll.setViewport(_this.elementRef.nativeElement);
            }), 17);
            this.scrollEventHandler = this.setViewport.bind(this);
        }
        /**
         * @return {?}
         */
        TreeViewportComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.virtualScroll.init();
        };
        /**
         * @return {?}
         */
        TreeViewportComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.setViewport();
                _this.virtualScroll.fireEvent({ eventName: TREE_EVENTS.initialized });
            }));
            /** @type {?} */
            var el = this.elementRef.nativeElement;
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                el.addEventListener('scroll', _this.scrollEventHandler);
            }));
        };
        /**
         * @return {?}
         */
        TreeViewportComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.virtualScroll.clear();
            /** @type {?} */
            var el = this.elementRef.nativeElement;
            el.removeEventListener('scroll', this.scrollEventHandler);
        };
        /**
         * @return {?}
         */
        TreeViewportComponent.prototype.getTotalHeight = /**
         * @return {?}
         */
        function () {
            return ((this.virtualScroll.isEnabled() &&
                this.virtualScroll.totalHeight + 'px') ||
                'auto');
        };
        TreeViewportComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tree-viewport',
                        providers: [TreeVirtualScroll],
                        template: "\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div [style.height]=\"getTotalHeight()\">\n        <ng-content></ng-content>\n      </div>\n    </ng-container>\n  "
                    }] }
        ];
        /** @nocollapse */
        TreeViewportComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: TreeVirtualScroll }
        ]; };
        return TreeViewportComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeViewportComponent.prototype.setViewport;
        /**
         * @type {?}
         * @private
         */
        TreeViewportComponent.prototype.scrollEventHandler;
        /**
         * @type {?}
         * @private
         */
        TreeViewportComponent.prototype.elementRef;
        /**
         * @type {?}
         * @private
         */
        TreeViewportComponent.prototype.ngZone;
        /** @type {?} */
        TreeViewportComponent.prototype.virtualScroll;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeComponent = /** @class */ (function () {
        function TreeComponent(treeModel, treeDraggedElement) {
            var _this = this;
            this.treeModel = treeModel;
            this.treeDraggedElement = treeDraggedElement;
            treeModel.eventNames.forEach((/**
             * @param {?} name
             * @return {?}
             */
            function (name) { return _this[name] = new core.EventEmitter(); }));
            treeModel.subscribeToState((/**
             * @param {?} state
             * @return {?}
             */
            function (state) { return _this.stateChange.emit(state); }));
        }
        Object.defineProperty(TreeComponent.prototype, "nodes", {
            // Will be handled in ngOnChanges
            set: 
            // Will be handled in ngOnChanges
            /**
             * @param {?} nodes
             * @return {?}
             */
            function (nodes) {
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeComponent.prototype, "options", {
            set: /**
             * @param {?} options
             * @return {?}
             */
            function (options) {
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(TreeComponent.prototype, "focused", {
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.treeModel.setFocus(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeComponent.prototype, "state", {
            set: /**
             * @param {?} state
             * @return {?}
             */
            function (state) {
                this.treeModel.setState(state);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeComponent.prototype.onKeydown = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if (!this.treeModel.isFocused)
                return;
            if (lodashEs.includes(['input', 'textarea'], document.activeElement.tagName.toLowerCase()))
                return;
            /** @type {?} */
            var focusedNode = this.treeModel.getFocusedNode();
            this.treeModel.performKeyAction(focusedNode, $event);
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeComponent.prototype.onMousedown = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            /**
             * @param {?} startElement
             * @param {?} nodeName
             * @return {?}
             */
            function isOutsideClick(startElement, nodeName) {
                return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);
            }
            if (isOutsideClick($event.target, 'tree-root')) {
                this.treeModel.setFocus(false);
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        TreeComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.options || changes.nodes) {
                this.treeModel.setData({
                    options: changes.options && changes.options.currentValue,
                    nodes: changes.nodes && changes.nodes.currentValue,
                    events: lodashEs.pick(this, this.treeModel.eventNames)
                });
            }
        };
        /**
         * @return {?}
         */
        TreeComponent.prototype.sizeChanged = /**
         * @return {?}
         */
        function () {
            this.viewportComponent.setViewport();
        };
        TreeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'Tree, tree-root',
                        providers: [TreeModel],
                        template: "\n      <tree-viewport #viewport>\n          <div\n                  class=\"angular-tree-component\"\n                  [class.node-dragging]=\"treeDraggedElement.isDragging()\"\n                  [class.angular-tree-component-rtl]=\"treeModel.options.rtl\">\n              <tree-node-collection\n                      *ngIf=\"treeModel.roots\"\n                      [nodes]=\"treeModel.roots\"\n                      [treeModel]=\"treeModel\"\n                      [templates]=\"{\n            loadingTemplate: loadingTemplate,\n            treeNodeTemplate: treeNodeTemplate,\n            treeNodeWrapperTemplate: treeNodeWrapperTemplate,\n            treeNodeFullTemplate: treeNodeFullTemplate\n          }\">\n              </tree-node-collection>\n              <tree-node-drop-slot\n                      class=\"empty-tree-drop-slot\"\n                      *ngIf=\"treeModel.isEmptyTree()\"\n                      [dropIndex]=\"0\"\n                      [node]=\"treeModel.virtualRoot\">\n              </tree-node-drop-slot>\n          </div>\n      </tree-viewport>\n  "
                    }] }
        ];
        /** @nocollapse */
        TreeComponent.ctorParameters = function () { return [
            { type: TreeModel },
            { type: TreeDraggedElement }
        ]; };
        TreeComponent.propDecorators = {
            loadingTemplate: [{ type: core.ContentChild, args: ['loadingTemplate', { static: false },] }],
            treeNodeTemplate: [{ type: core.ContentChild, args: ['treeNodeTemplate', { static: false },] }],
            treeNodeWrapperTemplate: [{ type: core.ContentChild, args: ['treeNodeWrapperTemplate', { static: false },] }],
            treeNodeFullTemplate: [{ type: core.ContentChild, args: ['treeNodeFullTemplate', { static: false },] }],
            viewportComponent: [{ type: core.ViewChild, args: ['viewport', { static: false },] }],
            nodes: [{ type: core.Input }],
            options: [{ type: core.Input }],
            focused: [{ type: core.Input }],
            state: [{ type: core.Input }],
            toggleExpanded: [{ type: core.Output }],
            activate: [{ type: core.Output }],
            deactivate: [{ type: core.Output }],
            nodeActivate: [{ type: core.Output }],
            nodeDeactivate: [{ type: core.Output }],
            select: [{ type: core.Output }],
            deselect: [{ type: core.Output }],
            focus: [{ type: core.Output }],
            blur: [{ type: core.Output }],
            updateData: [{ type: core.Output }],
            initialized: [{ type: core.Output }],
            moveNode: [{ type: core.Output }],
            copyNode: [{ type: core.Output }],
            loadNodeChildren: [{ type: core.Output }],
            changeFilter: [{ type: core.Output }],
            event: [{ type: core.Output }],
            stateChange: [{ type: core.Output }],
            onKeydown: [{ type: core.HostListener, args: ['body: keydown', ['$event'],] }],
            onMousedown: [{ type: core.HostListener, args: ['body: mousedown', ['$event'],] }]
        };
        return TreeComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeComponent.prototype._nodes;
        /** @type {?} */
        TreeComponent.prototype._options;
        /** @type {?} */
        TreeComponent.prototype.loadingTemplate;
        /** @type {?} */
        TreeComponent.prototype.treeNodeTemplate;
        /** @type {?} */
        TreeComponent.prototype.treeNodeWrapperTemplate;
        /** @type {?} */
        TreeComponent.prototype.treeNodeFullTemplate;
        /** @type {?} */
        TreeComponent.prototype.viewportComponent;
        /** @type {?} */
        TreeComponent.prototype.toggleExpanded;
        /** @type {?} */
        TreeComponent.prototype.activate;
        /** @type {?} */
        TreeComponent.prototype.deactivate;
        /** @type {?} */
        TreeComponent.prototype.nodeActivate;
        /** @type {?} */
        TreeComponent.prototype.nodeDeactivate;
        /** @type {?} */
        TreeComponent.prototype.select;
        /** @type {?} */
        TreeComponent.prototype.deselect;
        /** @type {?} */
        TreeComponent.prototype.focus;
        /** @type {?} */
        TreeComponent.prototype.blur;
        /** @type {?} */
        TreeComponent.prototype.updateData;
        /** @type {?} */
        TreeComponent.prototype.initialized;
        /** @type {?} */
        TreeComponent.prototype.moveNode;
        /** @type {?} */
        TreeComponent.prototype.copyNode;
        /** @type {?} */
        TreeComponent.prototype.loadNodeChildren;
        /** @type {?} */
        TreeComponent.prototype.changeFilter;
        /** @type {?} */
        TreeComponent.prototype.event;
        /** @type {?} */
        TreeComponent.prototype.stateChange;
        /** @type {?} */
        TreeComponent.prototype.treeModel;
        /** @type {?} */
        TreeComponent.prototype.treeDraggedElement;
        /* Skipping unhandled member: ;*/
        /* Skipping unhandled member: ;*/
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-node.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeNodeComponent = /** @class */ (function () {
        function TreeNodeComponent() {
        }
        TreeNodeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'TreeNode, tree-node',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div\n        *ngIf=\"!templates.treeNodeFullTemplate\"\n        [class]=\"node.getClass()\"\n        [class.tree-node]=\"true\"\n        [class.tree-node-expanded]=\"node.isExpanded && node.hasChildren\"\n        [class.tree-node-collapsed]=\"node.isCollapsed && node.hasChildren\"\n        [class.tree-node-leaf]=\"node.isLeaf\"\n        [class.tree-node-active]=\"node.isActive\"\n        [class.tree-node-focused]=\"node.isFocused\"\n      >\n        <tree-node-drop-slot\n          *ngIf=\"index === 0\"\n          [dropIndex]=\"node.index\"\n          [node]=\"node.parent\"\n        ></tree-node-drop-slot>\n\n        <tree-node-wrapper\n          [node]=\"node\"\n          [index]=\"index\"\n          [templates]=\"templates\"\n        ></tree-node-wrapper>\n\n        <tree-node-children\n          [node]=\"node\"\n          [templates]=\"templates\"\n        ></tree-node-children>\n        <tree-node-drop-slot\n          [dropIndex]=\"node.index + 1\"\n          [node]=\"node.parent\"\n        ></tree-node-drop-slot>\n      </div>\n      <ng-container\n        [ngTemplateOutlet]=\"templates.treeNodeFullTemplate\"\n        [ngTemplateOutletContext]=\"{\n          $implicit: node,\n          node: node,\n          index: index,\n          templates: templates\n        }\"\n      >\n      </ng-container>\n    </ng-container>\n  "
                    }] }
        ];
        TreeNodeComponent.propDecorators = {
            node: [{ type: core.Input }],
            index: [{ type: core.Input }],
            templates: [{ type: core.Input }]
        };
        return TreeNodeComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeComponent.prototype.node;
        /** @type {?} */
        TreeNodeComponent.prototype.index;
        /** @type {?} */
        TreeNodeComponent.prototype.templates;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-node-content.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeNodeContent = /** @class */ (function () {
        function TreeNodeContent() {
        }
        TreeNodeContent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tree-node-content',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n  <span *ngIf=\"!template\">{{ node.displayField }}</span>\n  <ng-container\n    [ngTemplateOutlet]=\"template\"\n    [ngTemplateOutletContext]=\"{ $implicit: node, node: node, index: index }\">\n  </ng-container>"
                    }] }
        ];
        TreeNodeContent.propDecorators = {
            node: [{ type: core.Input }],
            index: [{ type: core.Input }],
            template: [{ type: core.Input }]
        };
        return TreeNodeContent;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeContent.prototype.node;
        /** @type {?} */
        TreeNodeContent.prototype.index;
        /** @type {?} */
        TreeNodeContent.prototype.template;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-node-drop-slot.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeNodeDropSlot = /** @class */ (function () {
        function TreeNodeDropSlot() {
        }
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeNodeDropSlot.prototype.onDrop = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            this.node.mouseAction('drop', $event.event, {
                from: $event.element,
                to: { parent: this.node, index: this.dropIndex }
            });
        };
        /**
         * @param {?} element
         * @param {?} $event
         * @return {?}
         */
        TreeNodeDropSlot.prototype.allowDrop = /**
         * @param {?} element
         * @param {?} $event
         * @return {?}
         */
        function (element, $event) {
            return this.node.options.allowDrop(element, { parent: this.node, index: this.dropIndex }, $event);
        };
        TreeNodeDropSlot.decorators = [
            { type: core.Component, args: [{
                        selector: 'TreeNodeDropSlot, tree-node-drop-slot',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n    <div\n      class=\"node-drop-slot\"\n      (treeDrop)=\"onDrop($event)\"\n      [treeAllowDrop]=\"allowDrop.bind(this)\"\n      [allowDragoverStyling]=\"true\">\n    </div>\n  "
                    }] }
        ];
        TreeNodeDropSlot.propDecorators = {
            node: [{ type: core.Input }],
            dropIndex: [{ type: core.Input }]
        };
        return TreeNodeDropSlot;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeDropSlot.prototype.node;
        /** @type {?} */
        TreeNodeDropSlot.prototype.dropIndex;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-node-expander.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeNodeExpanderComponent = /** @class */ (function () {
        function TreeNodeExpanderComponent() {
        }
        TreeNodeExpanderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tree-node-expander',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <span\n        *ngIf=\"node.hasChildren\"\n        [class.toggle-children-wrapper-expanded]=\"node.isExpanded\"\n        [class.toggle-children-wrapper-collapsed]=\"node.isCollapsed\"\n        class=\"toggle-children-wrapper\"\n        (click)=\"node.mouseAction('expanderClick', $event)\"\n      >\n        <span class=\"toggle-children\"></span>\n      </span>\n      <span *ngIf=\"!node.hasChildren\" class=\"toggle-children-placeholder\">\n      </span>\n    </ng-container>\n  "
                    }] }
        ];
        TreeNodeExpanderComponent.propDecorators = {
            node: [{ type: core.Input }]
        };
        return TreeNodeExpanderComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeExpanderComponent.prototype.node;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-node-children.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeNodeChildrenComponent = /** @class */ (function () {
        function TreeNodeChildrenComponent() {
        }
        TreeNodeChildrenComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tree-node-children',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div\n        [class.tree-children]=\"true\"\n        [class.tree-children-no-padding]=\"node.options.levelPadding\"\n        *treeAnimateOpen=\"\n          node.isExpanded;\n          speed: node.options.animateSpeed;\n          acceleration: node.options.animateAcceleration;\n          enabled: node.options.animateExpand\n        \"\n      >\n        <tree-node-collection\n          *ngIf=\"node.children\"\n          [nodes]=\"node.children\"\n          [templates]=\"templates\"\n          [treeModel]=\"node.treeModel\"\n        >\n        </tree-node-collection>\n        <tree-loading-component\n          [style.padding-left]=\"node.getNodePadding()\"\n          class=\"tree-node-loading\"\n          *ngIf=\"!node.children\"\n          [template]=\"templates.loadingTemplate\"\n          [node]=\"node\"\n        ></tree-loading-component>\n      </div>\n    </ng-container>\n  "
                    }] }
        ];
        TreeNodeChildrenComponent.propDecorators = {
            node: [{ type: core.Input }],
            templates: [{ type: core.Input }]
        };
        return TreeNodeChildrenComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeChildrenComponent.prototype.node;
        /** @type {?} */
        TreeNodeChildrenComponent.prototype.templates;
    }

    var __read$2 = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread$2 = (this && this.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$2(arguments[i]));
        return ar;
    };
    // Re-export mobx operators to be able to use inside components with AOT:
    /**
     * @param {...?} args
     * @return {?}
     */
    function actionInternal() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return ((/** @type {?} */ (mobx.action))).apply(void 0, __spread$2(args));
    }
    /** @type {?} */
    var action = (/** @type {?} */ (Object.assign(actionInternal, mobx.action)));
    /**
     * @param {...?} args
     * @return {?}
     */
    function computedInternal() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return ((/** @type {?} */ (mobx.computed))).apply(void 0, __spread$2(args));
    }
    /** @type {?} */
    var computed = (/** @type {?} */ (Object.assign(computedInternal, mobx.computed)));
    /**
     * @param {...?} args
     * @return {?}
     */
    function observableInternal() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return ((/** @type {?} */ (mobx.observable))).apply(void 0, __spread$2(args));
    }
    /** @type {?} */
    var observable = (/** @type {?} */ (Object.assign(observableInternal, mobx.observable)));

    var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$3 = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var TreeNodeCollectionComponent = /** @class */ (function () {
        function TreeNodeCollectionComponent() {
            this._dispose = [];
        }
        Object.defineProperty(TreeNodeCollectionComponent.prototype, "nodes", {
            get: /**
             * @return {?}
             */
            function () {
                return this._nodes;
            },
            set: /**
             * @param {?} nodes
             * @return {?}
             */
            function (nodes) {
                this.setNodes(nodes);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeNodeCollectionComponent.prototype, "marginTop", {
            get: /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];
                /** @type {?} */
                var relativePosition = firstNode && firstNode.parent
                    ? firstNode.position -
                        firstNode.parent.position -
                        firstNode.parent.getSelfHeight()
                    : 0;
                return relativePosition + "px";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} nodes
         * @return {?}
         */
        TreeNodeCollectionComponent.prototype.setNodes = /**
         * @param {?} nodes
         * @return {?}
         */
        function (nodes) {
            this._nodes = nodes;
        };
        /**
         * @return {?}
         */
        TreeNodeCollectionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.virtualScroll = this.treeModel.virtualScroll;
            this._dispose = [
                // return node indexes so we can compare structurally,
                mobx.reaction((/**
                 * @return {?}
                 */
                function () {
                    return _this.virtualScroll
                        .getViewportNodes(_this.nodes)
                        .map((/**
                     * @param {?} n
                     * @return {?}
                     */
                    function (n) { return n.index; }));
                }), (/**
                 * @param {?} nodeIndexes
                 * @return {?}
                 */
                function (nodeIndexes) {
                    _this.viewportNodes = nodeIndexes.map((/**
                     * @param {?} i
                     * @return {?}
                     */
                    function (i) { return _this.nodes[i]; }));
                }), (/** @type {?} */ ({ compareStructural: true, fireImmediately: true }))),
                mobx.reaction((/**
                 * @return {?}
                 */
                function () { return _this.nodes; }), (/**
                 * @param {?} nodes
                 * @return {?}
                 */
                function (nodes) {
                    _this.viewportNodes = _this.virtualScroll.getViewportNodes(nodes);
                }))
            ];
        };
        /**
         * @return {?}
         */
        TreeNodeCollectionComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._dispose.forEach((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return d(); }));
        };
        /**
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        TreeNodeCollectionComponent.prototype.trackNode = /**
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        function (index, node) {
            return node.id;
        };
        TreeNodeCollectionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tree-node-collection',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <div [style.margin-top]=\"marginTop\">\n        <tree-node\n          *ngFor=\"let node of viewportNodes; let i = index; trackBy: trackNode\"\n          [node]=\"node\"\n          [index]=\"i\"\n          [templates]=\"templates\"\n        >\n        </tree-node>\n      </div>\n    </ng-container>\n  "
                    }] }
        ];
        TreeNodeCollectionComponent.propDecorators = {
            nodes: [{ type: core.Input }],
            treeModel: [{ type: core.Input }],
            templates: [{ type: core.Input }]
        };
        __decorate$3([
            observable,
            __metadata$3("design:type", Object)
        ], TreeNodeCollectionComponent.prototype, "_nodes", void 0);
        __decorate$3([
            observable,
            __metadata$3("design:type", Array)
        ], TreeNodeCollectionComponent.prototype, "viewportNodes", void 0);
        __decorate$3([
            computed,
            __metadata$3("design:type", String),
            __metadata$3("design:paramtypes", [])
        ], TreeNodeCollectionComponent.prototype, "marginTop", null);
        __decorate$3([
            action,
            __metadata$3("design:type", Function),
            __metadata$3("design:paramtypes", [Object]),
            __metadata$3("design:returntype", void 0)
        ], TreeNodeCollectionComponent.prototype, "setNodes", null);
        return TreeNodeCollectionComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeCollectionComponent.prototype.treeModel;
        /** @type {?} */
        TreeNodeCollectionComponent.prototype._nodes;
        /**
         * @type {?}
         * @private
         */
        TreeNodeCollectionComponent.prototype.virtualScroll;
        /** @type {?} */
        TreeNodeCollectionComponent.prototype.templates;
        /** @type {?} */
        TreeNodeCollectionComponent.prototype.viewportNodes;
        /** @type {?} */
        TreeNodeCollectionComponent.prototype._dispose;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-node-wrapper.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeNodeWrapperComponent = /** @class */ (function () {
        function TreeNodeWrapperComponent() {
        }
        TreeNodeWrapperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tree-node-wrapper',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n      <div *ngIf=\"!templates.treeNodeWrapperTemplate\" class=\"node-wrapper\" [style.padding-left]=\"node.getNodePadding()\">\n          <tree-node-checkbox *ngIf=\"node.options.useCheckbox\" [node]=\"node\"></tree-node-checkbox>\n          <tree-node-expander [node]=\"node\"></tree-node-expander>\n          <div class=\"node-content-wrapper\"\n               [class.node-content-wrapper-active]=\"node.isActive\"\n               [class.node-content-wrapper-focused]=\"node.isFocused\"\n               (click)=\"node.mouseAction('click', $event)\"\n               (dblclick)=\"node.mouseAction('dblClick', $event)\"\n               (mouseover)=\"node.mouseAction('mouseOver', $event)\"\n               (mouseout)=\"node.mouseAction('mouseOut', $event)\"\n               (contextmenu)=\"node.mouseAction('contextMenu', $event)\"\n               (treeDrop)=\"node.onDrop($event)\"\n               (treeDropDragOver)=\"node.mouseAction('dragOver', $event)\"\n               (treeDropDragLeave)=\"node.mouseAction('dragLeave', $event)\"\n               (treeDropDragEnter)=\"node.mouseAction('dragEnter', $event)\"\n               [treeAllowDrop]=\"node.allowDrop\"\n               [allowDragoverStyling]=\"node.allowDragoverStyling()\"\n               [treeDrag]=\"node\"\n               [treeDragEnabled]=\"node.allowDrag()\">\n\n              <tree-node-content [node]=\"node\" [index]=\"index\" [template]=\"templates.treeNodeTemplate\">\n              </tree-node-content>\n          </div>\n      </div>\n      <ng-container\n              [ngTemplateOutlet]=\"templates.treeNodeWrapperTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: node, node: node, index: index, templates: templates }\">\n      </ng-container>\n  "
                    }] }
        ];
        /** @nocollapse */
        TreeNodeWrapperComponent.ctorParameters = function () { return []; };
        TreeNodeWrapperComponent.propDecorators = {
            node: [{ type: core.Input }],
            index: [{ type: core.Input }],
            templates: [{ type: core.Input }]
        };
        return TreeNodeWrapperComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeWrapperComponent.prototype.node;
        /** @type {?} */
        TreeNodeWrapperComponent.prototype.index;
        /** @type {?} */
        TreeNodeWrapperComponent.prototype.templates;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/tree-node-checkbox.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeNodeCheckboxComponent = /** @class */ (function () {
        function TreeNodeCheckboxComponent() {
        }
        TreeNodeCheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'tree-node-checkbox',
                        encapsulation: core.ViewEncapsulation.None,
                        template: "\n    <ng-container *treeMobxAutorun=\"{ dontDetach: true }\">\n      <input\n        class=\"tree-node-checkbox\"\n        type=\"checkbox\"\n        (click)=\"node.mouseAction('checkboxClick', $event)\"\n        [checked]=\"node.isSelected\"\n        [indeterminate]=\"node.isPartiallySelected\"\n      />\n    </ng-container>\n  "
                    }] }
        ];
        TreeNodeCheckboxComponent.propDecorators = {
            node: [{ type: core.Input }]
        };
        return TreeNodeCheckboxComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeNodeCheckboxComponent.prototype.node;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/tree-drop.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DRAG_OVER_CLASS = 'is-dragging-over';
    /** @type {?} */
    var DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';
    var TreeDropDirective = /** @class */ (function () {
        function TreeDropDirective(el, renderer, treeDraggedElement, ngZone) {
            this.el = el;
            this.renderer = renderer;
            this.treeDraggedElement = treeDraggedElement;
            this.ngZone = ngZone;
            this.allowDragoverStyling = true;
            this.onDropCallback = new core.EventEmitter();
            this.onDragOverCallback = new core.EventEmitter();
            this.onDragLeaveCallback = new core.EventEmitter();
            this.onDragEnterCallback = new core.EventEmitter();
            this._allowDrop = (/**
             * @param {?} element
             * @param {?} $event
             * @return {?}
             */
            function (element, $event) { return true; });
            this.dragOverEventHandler = this.onDragOver.bind(this);
            this.dragEnterEventHandler = this.onDragEnter.bind(this);
            this.dragLeaveEventHandler = this.onDragLeave.bind(this);
        }
        Object.defineProperty(TreeDropDirective.prototype, "treeAllowDrop", {
            set: /**
             * @param {?} allowDrop
             * @return {?}
             */
            function (allowDrop) {
                if (allowDrop instanceof Function) {
                    this._allowDrop = allowDrop;
                }
                else
                    this._allowDrop = (/**
                     * @param {?} element
                     * @param {?} $event
                     * @return {?}
                     */
                    function (element, $event) { return allowDrop; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeDropDirective.prototype.allowDrop = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            return this._allowDrop(this.treeDraggedElement.get(), $event);
        };
        /**
         * @return {?}
         */
        TreeDropDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var el = this.el.nativeElement;
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                el.addEventListener('dragover', _this.dragOverEventHandler);
                el.addEventListener('dragenter', _this.dragEnterEventHandler);
                el.addEventListener('dragleave', _this.dragLeaveEventHandler);
            }));
        };
        /**
         * @return {?}
         */
        TreeDropDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var el = this.el.nativeElement;
            el.removeEventListener('dragover', this.dragOverEventHandler);
            el.removeEventListener('dragenter', this.dragEnterEventHandler);
            el.removeEventListener('dragleave', this.dragLeaveEventHandler);
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeDropDirective.prototype.onDragOver = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if (!this.allowDrop($event)) {
                if (this.allowDragoverStyling) {
                    return this.addDisabledClass();
                }
                return;
            }
            this.onDragOverCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
            $event.preventDefault();
            if (this.allowDragoverStyling) {
                this.addClass();
            }
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeDropDirective.prototype.onDragEnter = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if (!this.allowDrop($event))
                return;
            $event.preventDefault();
            this.onDragEnterCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeDropDirective.prototype.onDragLeave = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if (!this.allowDrop($event)) {
                if (this.allowDragoverStyling) {
                    return this.removeDisabledClass();
                }
                return;
            }
            this.onDragLeaveCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
            if (this.allowDragoverStyling) {
                this.removeClass();
            }
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        TreeDropDirective.prototype.onDrop = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            if (!this.allowDrop($event))
                return;
            $event.preventDefault();
            this.onDropCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
            if (this.allowDragoverStyling) {
                this.removeClass();
            }
            this.treeDraggedElement.set(null);
        };
        /**
         * @private
         * @return {?}
         */
        TreeDropDirective.prototype.addClass = /**
         * @private
         * @return {?}
         */
        function () {
            this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS);
        };
        /**
         * @private
         * @return {?}
         */
        TreeDropDirective.prototype.removeClass = /**
         * @private
         * @return {?}
         */
        function () {
            this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS);
        };
        /**
         * @private
         * @return {?}
         */
        TreeDropDirective.prototype.addDisabledClass = /**
         * @private
         * @return {?}
         */
        function () {
            this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
        };
        /**
         * @private
         * @return {?}
         */
        TreeDropDirective.prototype.removeDisabledClass = /**
         * @private
         * @return {?}
         */
        function () {
            this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
        };
        TreeDropDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[treeDrop]'
                    },] }
        ];
        /** @nocollapse */
        TreeDropDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: TreeDraggedElement },
            { type: core.NgZone }
        ]; };
        TreeDropDirective.propDecorators = {
            allowDragoverStyling: [{ type: core.Input }],
            onDropCallback: [{ type: core.Output, args: ['treeDrop',] }],
            onDragOverCallback: [{ type: core.Output, args: ['treeDropDragOver',] }],
            onDragLeaveCallback: [{ type: core.Output, args: ['treeDropDragLeave',] }],
            onDragEnterCallback: [{ type: core.Output, args: ['treeDropDragEnter',] }],
            treeAllowDrop: [{ type: core.Input }],
            onDrop: [{ type: core.HostListener, args: ['drop', ['$event'],] }]
        };
        return TreeDropDirective;
    }());
    if (false) {
        /** @type {?} */
        TreeDropDirective.prototype.allowDragoverStyling;
        /** @type {?} */
        TreeDropDirective.prototype.onDropCallback;
        /** @type {?} */
        TreeDropDirective.prototype.onDragOverCallback;
        /** @type {?} */
        TreeDropDirective.prototype.onDragLeaveCallback;
        /** @type {?} */
        TreeDropDirective.prototype.onDragEnterCallback;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype.dragOverEventHandler;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype.dragEnterEventHandler;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype.dragLeaveEventHandler;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype._allowDrop;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype.el;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype.treeDraggedElement;
        /**
         * @type {?}
         * @private
         */
        TreeDropDirective.prototype.ngZone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/tree-drag.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DRAG_OVER_CLASS$1 = 'is-dragging-over';
    var TreeDragDirective = /** @class */ (function () {
        function TreeDragDirective(el, renderer, treeDraggedElement, ngZone) {
            this.el = el;
            this.renderer = renderer;
            this.treeDraggedElement = treeDraggedElement;
            this.ngZone = ngZone;
            this.dragEventHandler = this.onDrag.bind(this);
        }
        /**
         * @return {?}
         */
        TreeDragDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var el = this.el.nativeElement;
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                el.addEventListener('drag', _this.dragEventHandler);
            }));
        };
        /**
         * @return {?}
         */
        TreeDragDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');
        };
        /**
         * @return {?}
         */
        TreeDragDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var el = this.el.nativeElement;
            el.removeEventListener('drag', this.dragEventHandler);
        };
        /**
         * @param {?} ev
         * @return {?}
         */
        TreeDragDirective.prototype.onDragStart = /**
         * @param {?} ev
         * @return {?}
         */
        function (ev) {
            // setting the data is required by firefox
            ev.dataTransfer.setData('text', ev.target.id);
            this.treeDraggedElement.set(this.draggedElement);
            if (this.draggedElement.mouseAction) {
                this.draggedElement.mouseAction('dragStart', ev);
            }
        };
        /**
         * @param {?} ev
         * @return {?}
         */
        TreeDragDirective.prototype.onDrag = /**
         * @param {?} ev
         * @return {?}
         */
        function (ev) {
            if (this.draggedElement.mouseAction) {
                this.draggedElement.mouseAction('drag', ev);
            }
        };
        /**
         * @return {?}
         */
        TreeDragDirective.prototype.onDragEnd = /**
         * @return {?}
         */
        function () {
            if (this.draggedElement.mouseAction) {
                this.draggedElement.mouseAction('dragEnd');
            }
            this.treeDraggedElement.set(null);
        };
        TreeDragDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[treeDrag]'
                    },] }
        ];
        /** @nocollapse */
        TreeDragDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: TreeDraggedElement },
            { type: core.NgZone }
        ]; };
        TreeDragDirective.propDecorators = {
            draggedElement: [{ type: core.Input, args: ['treeDrag',] }],
            treeDragEnabled: [{ type: core.Input }],
            onDragStart: [{ type: core.HostListener, args: ['dragstart', ['$event'],] }],
            onDragEnd: [{ type: core.HostListener, args: ['dragend',] }]
        };
        return TreeDragDirective;
    }());
    if (false) {
        /** @type {?} */
        TreeDragDirective.prototype.draggedElement;
        /** @type {?} */
        TreeDragDirective.prototype.treeDragEnabled;
        /**
         * @type {?}
         * @private
         */
        TreeDragDirective.prototype.dragEventHandler;
        /**
         * @type {?}
         * @private
         */
        TreeDragDirective.prototype.el;
        /**
         * @type {?}
         * @private
         */
        TreeDragDirective.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        TreeDragDirective.prototype.treeDraggedElement;
        /**
         * @type {?}
         * @private
         */
        TreeDragDirective.prototype.ngZone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/tree-animate-open.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EASE_ACCELERATION = 1.005;
    var TreeAnimateOpenDirective = /** @class */ (function () {
        function TreeAnimateOpenDirective(renderer, templateRef, viewContainerRef) {
            this.renderer = renderer;
            this.templateRef = templateRef;
            this.viewContainerRef = viewContainerRef;
        }
        Object.defineProperty(TreeAnimateOpenDirective.prototype, "isOpen", {
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value) {
                    this._show();
                    if (this.isEnabled && this._isOpen === false) {
                        this._animateOpen();
                    }
                }
                else {
                    this.isEnabled ? this._animateClose() : this._hide();
                }
                this._isOpen = !!value;
            },
            enumerable: true,
            configurable: true
        });
        ;
        /**
         * @private
         * @return {?}
         */
        TreeAnimateOpenDirective.prototype._show = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.innerElement)
                return;
            // create child view
            this.innerElement = this.viewContainerRef.createEmbeddedView(this.templateRef).rootNodes[0];
        };
        /**
         * @private
         * @return {?}
         */
        TreeAnimateOpenDirective.prototype._hide = /**
         * @private
         * @return {?}
         */
        function () {
            this.viewContainerRef.clear();
            this.innerElement = null;
        };
        /**
         * @private
         * @return {?}
         */
        TreeAnimateOpenDirective.prototype._animateOpen = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var delta = this.animateSpeed;
            /** @type {?} */
            var ease = this.animateAcceleration;
            /** @type {?} */
            var maxHeight = 0;
            // set height to 0
            this.renderer.setStyle(this.innerElement, 'max-height', "0");
            // increase maxHeight until height doesn't change
            setTimeout((/**
             * @return {?}
             */
            function () {
                // Allow inner element to create its content
                /** @type {?} */
                var i = setInterval((/**
                 * @return {?}
                 */
                function () {
                    if (!_this._isOpen || !_this.innerElement)
                        return clearInterval(i);
                    maxHeight += delta;
                    /** @type {?} */
                    var roundedMaxHeight = Math.round(maxHeight);
                    _this.renderer.setStyle(_this.innerElement, 'max-height', roundedMaxHeight + "px");
                    /** @type {?} */
                    var height = _this.innerElement.getBoundingClientRect ? _this.innerElement.getBoundingClientRect().height : 0;
                    delta *= ease;
                    ease *= EASE_ACCELERATION;
                    if (height < roundedMaxHeight) {
                        // Make maxHeight auto because animation finished and container might change height later on
                        _this.renderer.setStyle(_this.innerElement, 'max-height', null);
                        clearInterval(i);
                    }
                }), 17);
            }));
        };
        /**
         * @private
         * @return {?}
         */
        TreeAnimateOpenDirective.prototype._animateClose = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.innerElement)
                return;
            /** @type {?} */
            var delta = this.animateSpeed;
            /** @type {?} */
            var ease = this.animateAcceleration;
            /** @type {?} */
            var height = this.innerElement.getBoundingClientRect().height;
            // TBD use renderer
            // slowly decrease maxHeight to 0, starting from current height
            /** @type {?} */
            var i = setInterval((/**
             * @return {?}
             */
            function () {
                if (_this._isOpen || !_this.innerElement)
                    return clearInterval(i);
                height -= delta;
                _this.renderer.setStyle(_this.innerElement, 'max-height', height + "px");
                delta *= ease;
                ease *= EASE_ACCELERATION;
                if (height <= 0) {
                    // after animation complete - remove child element
                    _this.viewContainerRef.clear();
                    _this.innerElement = null;
                    clearInterval(i);
                }
            }), 17);
        };
        TreeAnimateOpenDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[treeAnimateOpen]'
                    },] }
        ];
        /** @nocollapse */
        TreeAnimateOpenDirective.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.TemplateRef },
            { type: core.ViewContainerRef }
        ]; };
        TreeAnimateOpenDirective.propDecorators = {
            animateSpeed: [{ type: core.Input, args: ['treeAnimateOpenSpeed',] }],
            animateAcceleration: [{ type: core.Input, args: ['treeAnimateOpenAcceleration',] }],
            isEnabled: [{ type: core.Input, args: ['treeAnimateOpenEnabled',] }],
            isOpen: [{ type: core.Input, args: ['treeAnimateOpen',] }]
        };
        return TreeAnimateOpenDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TreeAnimateOpenDirective.prototype._isOpen;
        /** @type {?} */
        TreeAnimateOpenDirective.prototype.animateSpeed;
        /** @type {?} */
        TreeAnimateOpenDirective.prototype.animateAcceleration;
        /** @type {?} */
        TreeAnimateOpenDirective.prototype.isEnabled;
        /**
         * @type {?}
         * @private
         */
        TreeAnimateOpenDirective.prototype.innerElement;
        /**
         * @type {?}
         * @private
         */
        TreeAnimateOpenDirective.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        TreeAnimateOpenDirective.prototype.templateRef;
        /**
         * @type {?}
         * @private
         */
        TreeAnimateOpenDirective.prototype.viewContainerRef;
        /* Skipping unhandled member: ;*/
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/vendor/closest.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // element-closest | CC0-1.0 | github.com/jonathantneal/closest
    if (typeof Element !== 'undefined') {
        if (typeof Element.prototype.matches !== 'function') {
            Element.prototype.matches = ((/** @type {?} */ (Element.prototype))).msMatchesSelector ||
                Element.prototype['mozMatchesSelector'] ||
                Element.prototype.webkitMatchesSelector ||
                (/**
                 * @param {?} selector
                 * @return {?}
                 */
                function matches(selector) {
                    /** @type {?} */
                    var element = this;
                    /** @type {?} */
                    var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
                    /** @type {?} */
                    var index = 0;
                    while (elements[index] && elements[index] !== element) {
                        ++index;
                    }
                    return Boolean(elements[index]);
                });
        }
        if (typeof Element.prototype['closest'] !== 'function') {
            Element.prototype['closest'] = (/**
             * @param {?} selector
             * @return {?}
             */
            function closest(selector) {
                /** @type {?} */
                var element = this;
                while (element && element.nodeType === 1) {
                    if (element.matches(selector)) {
                        return element;
                    }
                    element = element.parentNode;
                }
                return null;
            });
        }
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/polyfills.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/angular-tree-component.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TreeModule = /** @class */ (function () {
        function TreeModule() {
        }
        TreeModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            TreeComponent,
                            TreeNodeComponent,
                            TreeNodeContent,
                            LoadingComponent,
                            TreeDropDirective,
                            TreeDragDirective,
                            TreeNodeExpanderComponent,
                            TreeNodeChildrenComponent,
                            TreeNodeDropSlot,
                            TreeNodeCollectionComponent,
                            TreeViewportComponent,
                            TreeNodeWrapperComponent,
                            TreeNodeCheckboxComponent,
                            TreeAnimateOpenDirective,
                            TreeMobxAutorunDirective
                        ],
                        exports: [
                            TreeComponent,
                            TreeNodeComponent,
                            TreeNodeContent,
                            LoadingComponent,
                            TreeDropDirective,
                            TreeDragDirective,
                            TreeNodeExpanderComponent,
                            TreeNodeChildrenComponent,
                            TreeNodeDropSlot,
                            TreeNodeCollectionComponent,
                            TreeViewportComponent,
                            TreeNodeWrapperComponent,
                            TreeNodeCheckboxComponent,
                            TreeAnimateOpenDirective,
                            TreeMobxAutorunDirective
                        ],
                        imports: [common.CommonModule],
                        providers: []
                    },] }
        ];
        return TreeModule;
    }());

    exports.KEYS = KEYS;
    exports.LoadingComponent = LoadingComponent;
    exports.TREE_ACTIONS = TREE_ACTIONS;
    exports.TreeAnimateOpenDirective = TreeAnimateOpenDirective;
    exports.TreeComponent = TreeComponent;
    exports.TreeDragDirective = TreeDragDirective;
    exports.TreeDraggedElement = TreeDraggedElement;
    exports.TreeDropDirective = TreeDropDirective;
    exports.TreeModel = TreeModel;
    exports.TreeModule = TreeModule;
    exports.TreeNode = TreeNode;
    exports.TreeNodeCheckboxComponent = TreeNodeCheckboxComponent;
    exports.TreeNodeChildrenComponent = TreeNodeChildrenComponent;
    exports.TreeNodeCollectionComponent = TreeNodeCollectionComponent;
    exports.TreeNodeComponent = TreeNodeComponent;
    exports.TreeNodeContent = TreeNodeContent;
    exports.TreeNodeDropSlot = TreeNodeDropSlot;
    exports.TreeNodeExpanderComponent = TreeNodeExpanderComponent;
    exports.TreeNodeWrapperComponent = TreeNodeWrapperComponent;
    exports.TreeViewportComponent = TreeViewportComponent;
    exports.TreeVirtualScroll = TreeVirtualScroll;
    exports.ɵa = actionInternal;
    exports.ɵb = action;
    exports.ɵc = computed;
    exports.ɵd = observable;
    exports.ɵe = TreeMobxAutorunDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=circlon-angular-tree-component.umd.js.map
